[{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"Quick start guide for **emmeans**","text":"three basic steps One-factor model Two factors, interaction Two interacting factors Three factors Additional options see versus get Common things can go wrong reading","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"steps","dir":"Articles","previous_headings":"","what":"The three basic steps","title":"Quick start guide for **emmeans**","text":"Much emmeans package involves three basic steps: Fit good model data, reasonable checks make sure adequately explains respons(es) reasonably meets underlying statistical assumptions. Modeling focus emmeans, extremely important step emmeans analyze data, summarizes model. bad model, likely get misleading results package – garbage , garbage principle. ’re sure whether model good, good time get statistical consulting help. really like rocket science, just matter getting programs run. Run EMM <- emmeans(...) (see scenarios ) obtain estimates means marginal means Run contrast(EMM, ...) pairs(EMM) one times obtain estimates contrasts pairwise comparisons among means. Note: lot users developed habit running something like emmeans(model, pairwise ~ factor(s)), conflates steps 1 2. recommend often yields output don’t want need – especially one factor. better keeping steps 1 2 separate. step 2 depends many factors , relate.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"one-factor","dir":"Articles","previous_headings":"The three basic steps","what":"One-factor model","title":"Quick start guide for **emmeans**","text":"one-factor model fits well factor named treatment, may specify contrasts second argument contrast() call, e.g. \"trt.vs.ctrl\", ref = 1 (compare mean first), \"consec\" (compare 2 vs 1, 3 vs 2, etc.), \"poly\", max.degree = 3 (polynomial contrasts)","code":"EMM <- emmeans(model, \"treatment\")   # or emmeans(model, ~ treatment) EMM    # display the means  ### pairwise comparisons contrast(EMM, \"pairwise\")    # or pairs(EMM)"},{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"additive","dir":"Articles","previous_headings":"The three basic steps","what":"Two factors, no interaction","title":"Quick start guide for **emmeans**","text":"model fits well factors named treat dose, don’t interact, follow steps one factor time. , something like analyses yield estimated marginal means factor, comparisons/contrasts thereof. Back Contents","code":"(EMM1 <- emmeans(model, ~ treat)) pairs(EMM1)  (EMM2 <- emmeans(model, ~ dose)) pairs(EMM2)"},{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"interactions","dir":"Articles","previous_headings":"The three basic steps","what":"Two interacting factors","title":"Quick start guide for **emmeans**","text":"case, unless interaction effect negligible, usually want “simple comparisons” cell means. , compare contrast means separately, holding one factor fixed level. default apply separate Tukey adjustment P values group (group just 2 means, adjustment applied). want adjust whole family combined, need undo variable specify desired adjustment (can’t Tukey method invalid one set pairwise comparisons.) example","code":"EMM <- emmeans(model, ~ treat * dose) EMM    # display the cell means  ### Simple pairwise comparisons... pairs(EMM, simple = \"treat\")    # compare treats for each dose -- \"simple effects\" pairs(EMM, simple = \"dose\")     # compare doses for each treat test(pairs(EMM, by = \"dose\"), by = NULL, adjust = \"mvt\")"},{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"diagonal-comparisons","dir":"Articles","previous_headings":"The three basic steps > Two interacting factors","what":"Diagonal comparisons","title":"Quick start guide for **emmeans**","text":"“diagonal” comparisons (factors differ) interest, pairs(EMM) without variable. get lot comparisons way.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"interaction-contrasts","dir":"Articles","previous_headings":"The three basic steps > Two interacting factors","what":"Interaction contrasts","title":"Quick start guide for **emmeans**","text":"Sometimes may want examine interaction contrasts, contrasts contrasts. thing know contrast() (pairs()) creates kind object emmeans(), can run multiple times. example, equivalently, named argument interaction can used","code":"CON <- pairs(EMM, by = \"dose\") contrast(CON, \"consec\", by = NULL)    # by = NULL is essential here! contrast(EMM, interaction = c(\"pairwise\", \"consec\"))"},{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"multi-factor","dir":"Articles","previous_headings":"The three basic steps","what":"Three or more factors","title":"Quick start guide for **emmeans**","text":"mastered strategies two factors, can adapt three factors appropriate, based interact need. Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"options","dir":"Articles","previous_headings":"","what":"Additional options","title":"Quick start guide for **emmeans**","text":"See help files emmeans() ref_grid() additional arguments may prove useful. Many useful arguments passed ref_grid(). number vignettes provided package include examples discussions different kinds situations. also index vignette topics.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"objects","dir":"Articles","previous_headings":"","what":"What you see versus what you get","title":"Quick start guide for **emmeans**","text":"non-graphical functions emmeans package produce one two classes objects. functions emmeans(), emtrends(), ref_grid(), contrast(), pairs() return emmGrid objects (lists thereof, class emm_list). example functions summary(), confint(), test(), joint_tests(), others return summary_emm objects (lists thereof, class summary_eml): display EMM SEMM, look identical; ’s emmGrid objects displayed using summary(). identical. EMM ingredients needed analysis, e.g. contrast(EMM, \"consec\") estimate comparisons consecutive Treatment means. SEMM just annotated data frame can analysis . Similarly, can change EMM displayed via arguments summary() relatives, whil;e SEMM, everything computed results locked-.","code":"EMM <- emmeans(mod, \"Treatment\") SEMM <- summary(EMM)"},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"covar","dir":"Articles","previous_headings":"Common things that can go wrong","what":"Only one mean is obtained – or fewer than expected","title":"Quick start guide for **emmeans**","text":"probably common issue, can happen treatment coded numeric predictor rather factor. Instead getting mean treatment, get mean average numerical values. cases, model often inappropriate; replace treatment factor(treatment) re-fit model. situation appropriate consider treatment quantitative predictor, can get separate means specified values adding argument like = list(treatment = c(3,5,7)) emmeans() call. numerical predictor interacting factor, may useful estimate slope level factor. See documentation emtrends()","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"pairwise","dir":"Articles","previous_headings":"Common things that can go wrong","what":"Having trouble with follow-up analyses, and the pairwise ~ ... recipe","title":"Quick start guide for **emmeans**","text":"basic object returned emmeans() contrast() class emmGrid, additional emmeans() contrast() calls can accept emmGrid objects. However, options create lists emmGrid objects, makes things bit confusing. common case using call like emmeans(model, pairwise ~ treat * dose), computes means pairwise comparisons – list two emmGrids. try obtain additional contrasts, say, result, contrast() makes guess want run just first element. causes confusion (know, get lot questions ). recommend avoid using pairwise ~ construct altogether: Get means one step, get contrasts separate step(s). pairwise ~ construct generally useful one factor; otherwise, likely gives results don’t want.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/AQuickStart.html","id":"more","dir":"Articles","previous_headings":"","what":"Further reading","title":"Quick start guide for **emmeans**","text":"several vignettes offser details advanced topics. index vignette topics available . strings linked names vignettes; .e., can also accessed via vignette(\"name\", \"emmeans\") Models supported emmeans (lots ) “models” Basic ideas underlie estimated marginal means (EMMs): “basics”. concepts emphasize experimental data, distinct observational studies. Confidence intervals tests: “confidence-intervals” Often, users want compare contrast EMMs: “comparisons” Working response transformations link functions: “transformations” Multi-factor models interactions: “interactions” Making predictions model: “predictions” Examples sophisticated models (e.g., mixed, ordinal, MCMC) “sophisticated” Working messy data, counterfactuals, mediating covariates, nested effects: “messy-data”. may see emmeans might help observational data. Utilities working emmGrid objects: “utilities” Adding emmeans support package: “xtending” Explanations unusual aspects emmeans: “xplanations” custom variations compact letter displays: “re-engineering-clds” Frequently asked questions: “FAQs” Back Contents Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"Basics of estimated marginal means","text":"Emphasis experimental data Emphasis models Illustration: pigs experiment Estimated marginal means reference grid, definition EMMs reference grid Passing arguments Transformations Derived covariates Non-predictor variables Graphical displays Formatting results Using weights Multivariate responses Objects, structures, methods P values, “significance”, recommendations Summary reading Index vignette topics","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"exper","dir":"Articles","previous_headings":"Foundations","what":"Emphasis on experimental data","title":"Basics of estimated marginal means","text":"start , emphasize underpinnings estimated marginal means – much emmeans package offers – relate experimental data observational data. observational data, sample population, goal statistical analysis characterize population way. contrast, experimental data, experimenter controls environment test runs conducted, responses observed recorded. Thus experimentation, population abstract entity consisting potential outcomes test runs made conditions enforce, rather physical entity observe without changing . say default behavior emmeans() function average groups together equal weights; common analysis experiments, common analysis observational data; think misunderstandings underlie criticisms found . Consider, example, classic Latin square experimental design. RA Fisher others expounded designs. Suppose want compare four treatments, say fertilizers, agricultural experiment. Latin square plan involve dividing parcel land four rows four columns, defining 16 plots. apply one fertilizers plot way fertilizer appears row column (thus, row column contains four fertilizers). scheme, extent, controls possible spatial effects within land parcel. compare fertilizer, average together response values (say, yield crop) observed four plots fertilizer used. seems right average together equal weight, experimental condition seems equally valid reason give one weight another. illustration, fertilizer means marginal means physical population; simply means obtained four test conditions defined experiment.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"models","dir":"Articles","previous_headings":"Foundations","what":"Emphasis on models","title":"Basics of estimated marginal means","text":"emmeans package requires fit model data. results obtained emmeans rely model. , really, analysis obtained really analysis model, data. analysis depend data, insofar fitted model depends data. use predictions model compute estimated marginal means (EMMs), defined explicitly . now, two things know: change model, changes EMMs model fits poorly, EMMs represent data poorly (garbage , garbage principle) use package analyze data, important first step fit good model. Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"pigs","dir":"Articles","previous_headings":"Foundations","what":"Illustration: pigs experiment","title":"Basics of estimated marginal means","text":"Consider pigs dataset provided package (help(\"pigs\") provides details). data come experiment pigs given different percentages protein (percent) different sources (source) diet, later measured concentration (conc) leucine. percent values quantitative, chose particular values deliberately, (least initially) want separate estimates percent level; , want view percent factor, quantitative predictor. discussed, first task come good model. requires lot skill, don’t want labor much details; really need references deal aspect adequately. briefly discuss five models settle one : models \\(R^2\\) values 0.808 0.700, adjusted \\(R^2\\) values 0.684 0.634. mod1 preferable mod2, suggesting need interaction term. However, residual-vs-predicted plot mod2 classic “horn” shape (curving fanning ), indicating situation response transformation might help better including interaction. turns inverse transformation, (1/conc) really serves us well. (Perhaps isn’t surprising, concentrations typically determined titration, actual measurements volumes; reciprocally related concentrations, .e., amounts per unit volume.) three models: (Note: used 1/conc response variable, emmeans provides equivalent inverse() function prove advantageous later.) residual plots models look lot like random scatter points (good). \\(R^2\\) values models 0.818, 0.787, 0.749, respectively; adjusted \\(R^2\\)s 0.700, 0.740, 0.719. mod4 best adjusted \\(R^2\\) choice. Back Contents","code":"mod1 <- lm(conc ~ source * factor(percent), data = pigs) mod2 <- update(mod1, . ~ source + factor(percent))   # no interaction mod3 <- update(mod1, inverse(conc) ~ .) mod4 <- update(mod2, inverse(conc) ~ .)     # no interaction mod5 <- update(mod4, . ~ source + percent)  # linear term for percent"},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"emms","dir":"Articles","previous_headings":"Foundations","what":"Estimated marginal means","title":"Basics of estimated marginal means","text":"Now good model, let’s use emmeans() function obtain estimated marginal means (EMMs). ’ll explain later. Let’s compare ordinary marginal means (OMMs) inverse(conc): sets OMMs vaguely similar corresponding EMMs. However, please note EMMs percent form decreasing sequence, OMMs decrease increase end.","code":"(EMM.source <- emmeans(mod4, \"source\")) ##  source emmean       SE df lower.CL upper.CL ##  fish   0.0337 0.000926 23   0.0318   0.0356 ##  soy    0.0257 0.000945 23   0.0237   0.0276 ##  skim   0.0229 0.000994 23   0.0208   0.0249 ##  ## Results are averaged over the levels of: percent  ## Results are given on the inverse (not the response) scale.  ## Confidence level used: 0.95 (EMM.percent <- emmeans(mod4, \"percent\")) ##  percent emmean       SE df lower.CL upper.CL ##        9 0.0322 0.001032 23   0.0301   0.0344 ##       12 0.0270 0.000969 23   0.0250   0.0290 ##       15 0.0263 0.001104 23   0.0240   0.0286 ##       18 0.0241 0.001337 23   0.0213   0.0268 ##  ## Results are averaged over the levels of: source  ## Results are given on the inverse (not the response) scale.  ## Confidence level used: 0.95 with(pigs, tapply(inverse(conc), source, mean)) ##       fish        soy       skim  ## 0.03331687 0.02632333 0.02372024 with(pigs, tapply(inverse(conc), percent, mean)) ##          9         12         15         18  ## 0.03146170 0.02700341 0.02602757 0.02659336"},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"refgrid","dir":"Articles","previous_headings":"Foundations","what":"The reference grid, and definition of EMMs","title":"Basics of estimated marginal means","text":"Estimated marginal means defined marginal means model predictions grid comprising factor combinations – called reference grid. example hand, reference grid get EMMs, first need obtain predictions grid: obtain marginal means predictions: marginal averages match EMMs obtained earlier via emmeans(). Now let’s go back comparison ordinary marginal means. source levels represented columns pred; note row pred decreasing set values. wonder marginal means – EMMs source – decreasing. OMMs percent behave way due imbalance sample sizes: shows OMMs last column give weight (3/5) first source, tends higher inverse(conc), making OMM 18 percent higher 15 percent, even though reverse true every level source. kind disconnect example Simpson’s paradox, confounding factor can distort findings. EMMs subject paradox, OMMs , sample sizes correlated expected values. summary, obtain references grid factor combinations, obtain model predictions grid, expected marginal means estimated equally-weighted marginal averages predictions. EMMs subject confounding factors, might happen ordinary marginal means data. Moreover, unlike OMMs, EMMs based model fitted data. Back Contents","code":"(RG <- expand.grid(source = levels(pigs$source), percent = unique(pigs$percent))) ##    source percent ## 1    fish       9 ## 2     soy       9 ## 3    skim       9 ## 4    fish      12 ## 5     soy      12 ## 6    skim      12 ## 7    fish      15 ## 8     soy      15 ## 9    skim      15 ## 10   fish      18 ## 11    soy      18 ## 12   skim      18 (preds <- matrix(predict(mod4, newdata = RG), nrow = 3)) ##            [,1]       [,2]       [,3]       [,4] ## [1,] 0.03853514 0.03329091 0.03256404 0.03036586 ## [2,] 0.03050486 0.02526063 0.02453376 0.02233558 ## [3,] 0.02770292 0.02245869 0.02173182 0.01953364 apply(preds, 1, mean)   # row means -- for source ## [1] 0.03368899 0.02565870 0.02285677 apply(preds, 2, mean)   # column means -- for percent ## [1] 0.03224764 0.02700341 0.02627654 0.02407836 with(pigs, table(source, percent)) ##       percent ## source 9 12 15 18 ##   fish 2  3  2  3 ##   soy  3  3  3  1 ##   skim 3  3  2  1"},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"RG","dir":"Articles","previous_headings":"Foundations","what":"More on the reference grid","title":"Basics of estimated marginal means","text":"previous section, discussed reference grid set factor combinations. slightly complicated numerical predictors (AKA covariates) model. default, use average covariate – thus enlarging number combinations comprising grid. Using covariate average(s) yields often called adjusted means. one exception, though: covariate two different values, treat factor two levels. example, model include indicator variable male 1 subject male, 0 otherwise. male viewed factor levels 0 1. Note, , reference grid formulated model using. can see snapshot reference grid via ref_grid function; example reference grid mod5 different mod4 models, percent factor mod4 covariate mod5. possible modify reference grid. context present example, might inetersting compare EMMs based mod4 mod5, can put equal footing using percent values reference levels: also done using … tells ref_grid() set covariate levels using unique values. ’s safer use cov.reduce affects covariates instead specific ones. ###### {#emmip}  two models’ predictions can compared using interaction-style plots via emmip() function  plots show three parallel trends, neither model includes interaction term; course mod5, trends straight lines. Back Contents","code":"(RG4 <- ref_grid(mod4)) ## 'emmGrid' object with variables: ##     source = fish, soy, skim ##     percent =  9, 12, 15, 18 ## Transformation: \"inverse\" ref_grid(mod5) ## 'emmGrid' object with variables: ##     source = fish, soy, skim ##     percent = 12.931 ## Transformation: \"inverse\" (RG5 <- ref_grid(mod5, at = list(percent = c(9, 12, 15, 18)))) ## 'emmGrid' object with variables: ##     source = fish, soy, skim ##     percent =  9, 12, 15, 18 ## Transformation: \"inverse\" (RG5 <- ref_grid(mod5, cov.reduce = FALSE) emmip(RG4, source ~ percent, style = \"factor\") emmip(RG5, source ~ percent, style = \"factor\")"},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"arguments","dir":"Articles","previous_headings":"Other topics","what":"Passing arguments","title":"Basics of estimated marginal means","text":"Quite functions emmeans package, including emmeans() emmip(), can take either model object reference-grid object first argument. Thus can obtain EMMs mod5 directly RG5, e.g. slightly different results earlier mod4. functions model reference grid interchangeable, first thing function check ; model object, constructs reference grid. , passes arguments ref_grid() case needed. instance, EMMs obtained using great convenience able pass arguments ref_grid(), also can confuse new users, look help page emmeans(), list possible argument. mentioned, though, look ... argument. develop habit looking documentation functions, especially ref_grid(), arguments may affect results. Back Contents","code":"emmeans(RG5, \"source\") ##  source emmean       SE df lower.CL upper.CL ##  fish   0.0336 0.000958 25   0.0316   0.0355 ##  soy    0.0255 0.000971 25   0.0235   0.0275 ##  skim   0.0227 0.001030 25   0.0206   0.0248 ##  ## Results are averaged over the levels of: percent  ## Results are given on the inverse (not the response) scale.  ## Confidence level used: 0.95 emmeans(mod5, \"source\", at = list(percent = c(9, 12, 15, 18))) ## (same results as above)"},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"transf","dir":"Articles","previous_headings":"Other topics","what":"Transformations","title":"Basics of estimated marginal means","text":"running example pigs, now surely tired seeing answers inverse(conc) scale. estimating things conc scale? may noticed inverse transformation forgotten; mentioned annotations emmeans() output. [’d also comment used inverse(conc) rather 1/conc response variable model made easier sort things , inverse() named transformation emmeans() can work .] can back-transform results specifying type = \"response\" function call makes sense. instance, now conc scale, likely less confusing. Compared earlier plots trends decreasing parallel, plot increasing (inverse relationship) non-parallel. interaction occurs response scale pretty well explained model interactions inverse scale. Transformations lot nuances, refer vignette transformations details. Back Contents","code":"emmeans(RG4, \"source\", type = \"response\") ##  source response    SE df lower.CL upper.CL ##  fish       29.7 0.816 23     28.1     31.5 ##  soy        39.0 1.436 23     36.2     42.2 ##  skim       43.8 1.903 23     40.1     48.1 ##  ## Results are averaged over the levels of: percent  ## Confidence level used: 0.95  ## Intervals are back-transformed from the inverse scale emmip(RG4, source ~ percent, type = \"response\")"},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"depcovs","dir":"Articles","previous_headings":"Other topics","what":"Derived covariates","title":"Basics of estimated marginal means","text":"need careful one covariate depends value another. illustrate using datasets::mtcars data, suppose want predict mpg using cyl (number cylinders) factor disp (displacement) covariate, include quadratic term disp. two equivalent models: two models exactly predicted values. look EMMs: Wow! really different results – even though models equivalent. – (either) right? understand, look reference grids: models, reference grid uses disp mean 230.72. mcmod2, dispsq separate covariate, set mean 68113. right, impossible disp equal 230.72 square equal 68113 time! use consistent values disp anddispsq, get results mcmod1: summary, polynomial models others covariates depend others nonlinear ways, definitely best include dependence model formula (mcmod1) using () poly() expressions, alter reference grid dependency among covariates correct. Back Contents","code":"mcmod1 <- lm(mpg ~ factor(cyl) + disp + I(disp^2), data = mtcars) mtcars <- transform(mtcars,                      dispsq = disp^2) mcmod2 <- lm(mpg ~ factor(cyl) + disp + dispsq, data = mtcars) emmeans(mcmod1, \"cyl\") ##  cyl emmean   SE df lower.CL upper.CL ##    4   19.3 2.66 27     13.9     24.8 ##    6   17.2 1.36 27     14.4     20.0 ##    8   18.8 1.47 27     15.7     21.8 ##  ## Confidence level used: 0.95 emmeans(mcmod2, \"cyl\") ##  cyl emmean   SE df lower.CL upper.CL ##    4   20.8 2.05 27     16.6     25.0 ##    6   18.7 1.19 27     16.3     21.1 ##    8   20.2 1.77 27     16.6     23.9 ##  ## Confidence level used: 0.95 ref_grid(mcmod1) ## 'emmGrid' object with variables: ##     cyl = 4, 6, 8 ##     disp = 230.72 ref_grid(mcmod2) ## 'emmGrid' object with variables: ##     cyl = 4, 6, 8 ##     disp = 230.72 ##     dispsq = 68113 emmeans(mcmod2, \"cyl\", at = list(disp = 230.72, dispsq = 230.72^2)) ##  cyl emmean   SE df lower.CL upper.CL ##    4   19.3 2.66 27     13.9     24.8 ##    6   17.2 1.36 27     14.4     20.0 ##    8   18.8 1.47 27     15.7     21.8 ##  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"params","dir":"Articles","previous_headings":"Other topics","what":"Non-predictor variables","title":"Basics of estimated marginal means","text":"Reference grids derived using variables right-hand side model formula. sometimes, variables actually predictors. example: call ref_grid() emmeans() model, try construct grid values treat, x, deg – causing error deg predictor model. get things work correctly, need name deg params argument, e.g., Back Contents","code":"deg <- 2 mod <- lm(y ~ treat * poly(x, degree = deg), data = mydata) emmeans(mod, ~ treat | x, at = list(x = 1:3), params = \"deg\")"},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"plots","dir":"Articles","previous_headings":"Other topics","what":"Graphical displays","title":"Basics of estimated marginal means","text":"results ref_grid() emmeans() (objects class emmGrid) may plotted two different ways. One already seen interaction-style plot, using emmip(). formula specification used emmip(RG4, source ~ percent) sets x variable one right-hand side “trace” factor (used define different curves) left.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"plot-emmGrid","dir":"Articles","previous_headings":"","what":"Basics of estimated marginal means","title":"Basics of estimated marginal means","text":"graphics option offered plot() method emmGrid objects. Let’s consider different model mtcars data cyl disp covariates following, display estimates 95% confidence intervals RG4 separate panels source.  plot illustrates, much anything else, silly try predict mileage 4-cylinder car high displacement, 8-cylinder car low displacement. widths intervals give us clue extrapolating. better idea acknowledge displacement largely depends number cylinders. yet another way use cov.reduce modify reference grid: ref_grid call specifies disp depends cyl; linear model fitted given formula fitted values used disp values – one cyl. plot grid, results sensible, reflecting model predicts typical cars number cylinders:","code":"mcmod3 <- lm(mpg ~ disp * cyl, data = mtcars) EMM3 <- emmeans(mcmod3, ~ cyl | disp,                  at = list(cyl = c(4,6,8), disp = c(100,200,300))) plot(EMM3) mcrg <- ref_grid(mcmod3, at = list(cyl = c(4,6,8)),                          cov.reduce = disp ~ cyl) mcrg @ grid ##        disp cyl .wgt. ## 1  93.78673   4     1 ## 2 218.98458   6     1 ## 3 344.18243   8     1 plot(mcrg)"},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"ggplot","dir":"Articles","previous_headings":"","what":"Basics of estimated marginal means","title":"Basics of estimated marginal means","text":"Wizards ggplot2 package can enhance plots like. example, can add data interaction plot – time opt include confidence intervals put three sources separate panels:  Back Contents","code":"require(\"ggplot2\") emmip(mod4, ~ percent | source, CIs = TRUE, type = \"response\") +     geom_point(aes(x = percent, y = conc), data = pigs, pch = 2, color = \"blue\")"},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"formatting","dir":"Articles","previous_headings":"Other topics","what":"Formatting results","title":"Basics of estimated marginal means","text":"want include emmeans() results report, might want nicer format just printed output. provide little bit help , especially using RMarkdown SWeave prepare report. xtable method exporting results, illustrate works similarly xtable() contexts. Also, export option print() method allows user save exactly seen printed output text, saved formatted user likes (see documentation print.emmGrid details). example using one objects :  Confidence level used: 0.9 Conf-level adjustment: scheffe method rank 3 Back Contents","code":"ci <- confint(mcrg, level = 0.90, adjust = \"scheffe\") xport <- print(ci, export = TRUE) cat(\"<font color = 'blue'>\\n\") knitr::kable(xport$summary, align = \"r\") for (a in xport$annotations) cat(paste(a, \"<br>\")) cat(\"<\/font>\\n\")"},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"weights","dir":"Articles","previous_headings":"Other topics","what":"Using weights","title":"Basics of estimated marginal means","text":"mentioned, emmeans() uses equal weighting default, based foundations experimental situations. observational data, likely use unequal weights accurately characterize population. Accordingly, weights argument provided emmeans(). example, using weights = \"cells\" call weight predictions according cell frequencies (recall information retained reference grid). produces results comparable ordinary marginal means: Note , ordinary marginal means obtained long ago, highest estimate percent = 15 rather percent = 18. interesting compare results model includes percent predictor. EMMs two tables identical, sense, weights = \"cells\" amounts throwing-uninvolved factors. However, note outputs show markedly different standard errors. model mod4 accounts variations due source mod6 . lesson possible obtain statistics comparable ordinary marginal means, still accounting variations due factors averaged . Back Contents","code":"emmeans(mod4, \"percent\", weights = \"cells\") ##  percent emmean       SE df lower.CL upper.CL ##        9 0.0315 0.001028 23   0.0293   0.0336 ##       12 0.0270 0.000969 23   0.0250   0.0290 ##       15 0.0260 0.001099 23   0.0238   0.0283 ##       18 0.0266 0.001300 23   0.0239   0.0293 ##  ## Results are averaged over the levels of: source  ## Results are given on the inverse (not the response) scale.  ## Confidence level used: 0.95 mod6 <- lm(inverse(conc) ~ factor(percent), data = pigs) emmeans(mod6, \"percent\") ##  percent emmean      SE df lower.CL upper.CL ##        9 0.0315 0.00196 25   0.0274   0.0355 ##       12 0.0270 0.00185 25   0.0232   0.0308 ##       15 0.0260 0.00210 25   0.0217   0.0303 ##       18 0.0266 0.00248 25   0.0215   0.0317 ##  ## Results are given on the inverse (not the response) scale.  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"multiv","dir":"Articles","previous_headings":"Other topics","what":"Multivariate responses","title":"Basics of estimated marginal means","text":"emmeans package supports various multivariate models. multivariate response, dimensions response treated levels factor. example, MOats dataset provided package predictors Block Variety, four-dimensional response yield giving yields observed varying amounts nitrogen added soil. model reference grid: , nitro regarded factor 4 levels corresponding 4 dimensions yield. can subsequently obtain EMMs factors Block, Variety, nitro, combinations thereof. argument mult.name = \"nitro\" optional; excluded, multivariate levels named rep.meas. Back Contents","code":"MOats.lm <- lm (yield ~ Block + Variety, data = MOats) ref_grid (MOats.lm, mult.name = \"nitro\") ## 'emmGrid' object with variables: ##     Block = VI, V, III, IV, II, I ##     Variety = Golden Rain, Marvellous, Victory ##     nitro = multivariate response levels: 0, 0.2, 0.4, 0.6"},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"emmobj","dir":"Articles","previous_headings":"","what":"Objects, structures, and methods","title":"Basics of estimated marginal means","text":"ref_grid() emmeans() functions introduced previously. functions, related ones, return object class emmGrid. previously defined objects: simply show objects, get different-looking results: based guessing users need see displaying object. can override defaults; example just see quick summary , important method emmGrid objects summary(). used print method displaying emmeans() result. reason, arguments summary() may also specified within functions produce kinds results.emmGrid` objects. example: summary() method emmGrid objects) actually produces data.frame, extra bells whistles: can useful know want actually use emmeans() results computations, save summary, can access results just like access data data frame. emmGrid object accessible. print.summary_emm() function actually produces output see – data frame extra annotations. Back Contents","code":"class(RG4) ## [1] \"emmGrid\" ## attr(,\"package\") ## [1] \"emmeans\" class(EMM.source) ## [1] \"emmGrid\" ## attr(,\"package\") ## [1] \"emmeans\" RG4 ## 'emmGrid' object with variables: ##     source = fish, soy, skim ##     percent =  9, 12, 15, 18 ## Transformation: \"inverse\" EMM.source ##  source emmean       SE df lower.CL upper.CL ##  fish   0.0337 0.000926 23   0.0318   0.0356 ##  soy    0.0257 0.000945 23   0.0237   0.0276 ##  skim   0.0229 0.000994 23   0.0208   0.0249 ##  ## Results are averaged over the levels of: percent  ## Results are given on the inverse (not the response) scale.  ## Confidence level used: 0.95 str(EMM.source) ## 'emmGrid' object with variables: ##     source = fish, soy, skim ## Transformation: \"inverse\" # equivalent to summary(emmeans(mod4, \"percent\"), level = 0.90, infer = TRUE)) emmeans(mod4, \"percent\", level = 0.90, infer = TRUE) ##  percent emmean       SE df lower.CL upper.CL t.ratio p.value ##        9 0.0322 0.001032 23   0.0305   0.0340  31.240  <.0001 ##       12 0.0270 0.000969 23   0.0253   0.0287  27.872  <.0001 ##       15 0.0263 0.001104 23   0.0244   0.0282  23.802  <.0001 ##       18 0.0241 0.001337 23   0.0218   0.0264  18.009  <.0001 ##  ## Results are averaged over the levels of: source  ## Results are given on the inverse (not the response) scale.  ## Confidence level used: 0.9 class(summary(EMM.source)) ## [1] \"summary_emm\" \"data.frame\""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"pvalues","dir":"Articles","previous_headings":"","what":"P values, “significance”, and recommendations","title":"Basics of estimated marginal means","text":"debate among statisticians researchers appropriateness P values, term “statistical significance” can misleading. small P value, means effect tested unlikely explained chance variation alone, context current study current statistical model underlying test. large P value, means observed effect plausibly due chance alone: wrong conclude effect. American Statistical Association time advocating cautious use P values (Wasserstein et al. 2014) often misinterpreted, often used carelessly. Wasserstein et al. (2019) even goes far advise ever using term “statistically significant”. 43 articles accompanies issue TAS, recommend number alternatives. agree said main article, portions cutesy wander -topic. , quite dizzying try digest accompanying articles, reconcile disagreeing viewpoints. agree one frequent point: really substantive difference \\(P=.051\\) \\(P=.049\\), one avoid making sweeping statements based hard cutoff \\(P=.05\\) value. time included summary Wasserstein et al.’s recommendations ATOM paradigm (Acceptance uncertainty, Thoughtfulness, Openness, Modesty). meantime, handled large number user questions, many made clear important fish fry vignette section like . just fact P values used, useful. set recommendations regarding .","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"recs1","dir":"Articles","previous_headings":"P values, “significance”, and recommendations","what":"A set of comparisons or well-chosen contrasts is more useful and interpretable than an omnibus F test","title":"Basics of estimated marginal means","text":"F tests useful model selection, don’t tell anything specific nature effect. F small P value, suggests effect, somewhere. doesn’t even necessarily imply two means differ statistically.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"use-adjusted-p-values","dir":"Articles","previous_headings":"P values, “significance”, and recommendations","what":"Use adjusted P values","title":"Basics of estimated marginal means","text":"run bunch tests, risk making many type-errors, adjusted P values (e.g., Tukey adjustment pairwise comparisons) keep making many mistakes. said, possible go overboard; ’s usually reasonable regard “” group separate family tests purposes adjustment.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"recs2","dir":"Articles","previous_headings":"P values, “significance”, and recommendations","what":"It is not necessary to have a significant F test as a prerequisite to doing comparisons or contrasts","title":"Basics of estimated marginal means","text":"… long appropriate adjustment used. exist rules “protected LSD” one given license unadjusted comparisons provided \\(F\\) statistic “significant.” However, weak form protection justification , basically, “\\(F\\) significant, can say absolutely anything want.”","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"get-the-model-right-first","dir":"Articles","previous_headings":"P values, “significance”, and recommendations","what":"Get the model right first","title":"Basics of estimated marginal means","text":"Everything emmeans package interpretation model fitted data. model bad, get bad results emmeans() functions. Every single limitation model, presuming constant error variance, omitting interaction terms, etc., becomes limitation results emmeans() produces. responsible job fitting model. don’t know ’s meant …","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"recs3","dir":"Articles","previous_headings":"P values, “significance”, and recommendations","what":"Consider seeking the advice of a statistical consultant","title":"Basics of estimated marginal means","text":"Statistics hard. lot just running programs copying output. began vignette emphasizing need start good model; artful task, certainly shown hints required; may need help . research; important done right? Many academic statistics biostatistics departments can refer someone can help. Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary of main points","title":"Basics of estimated marginal means","text":"EMMs derived model. different model data may lead different EMMs. EMMs based reference grid consisting combinations factor levels, covariate set average (default). purposes defining reference grid, dimensions multivariate response treated levels factor. EMMs predictions reference grid, marginal averages thereof (equally weighted default). Reference grids may modified using arguments ref_grid() Reference grids emmeans() results may plotted via plot() (parallel confidence intervals) emmip() (interaction-style plot). cautious terms “significant” “nonsignificant”, don’t ever interpret “nonsignificant” result saying effect. Follow good statistical practices getting model right first, using adjusted P values appropriately chosen families comparisons contrasts. Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"references","dir":"Articles","previous_headings":"Summary of main points","what":"References","title":"Basics of estimated marginal means","text":"Wasserstein RL, Lazar NA (2016) “ASA’s Statement p-Values: Context, Process, Purpose,” American Statistician, 70, 129–133, https://doi.org/10.1080/00031305.2016.1154108 Wasserstein RL, Schirm AL, Lazar, NA (2019) “Moving World Beyond ‘p < 0.05’,” American Statistician, 73, 1–19, https://doi.org/10.1080/00031305.2019.1583913","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/basics.html","id":"more","dir":"Articles","previous_headings":"","what":"Further reading","title":"Basics of estimated marginal means","text":"reader referred vignettes details advanced use. strings linked names vignettes; .e., can also accessed via vignette(\"name\", \"emmeans\") Models supported emmeans (lots ) “models” Confidence intervals tests: “confidence-intervals” Often, users want compare contrast EMMs: “comparisons” Working response transformations link functions: “transformations” Multi-factor models interactions: “interactions” Working messy data nested effects: “messy-data” Making predictions model: “predictions” Examples sophisticated models (e.g., mixed, ordinal, MCMC) “sophisticated” Utilities working emmGrid objects: “utilities” Frequently asked questions: “FAQs” Adding emmeans support package: “xtending” Back Contents Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/comparisons.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"Comparisons and contrasts in emmeans","text":"vignette covers techniques comparing EMMs levels factor predictor, related analyses. Pairwise comparisons contrasts Formula interface Custom contrasts linear functions Special behavior log transformations Interaction contrasts (“interactions” vignette) Multivariate contrasts (“interactions” vignette) Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/comparisons.html","id":"pairwise","dir":"Articles","previous_headings":"","what":"Pairwise comparisons","title":"Comparisons and contrasts in emmeans","text":"common follow-analysis models factors predictors compare EMMs one another. may done simply via pairs() method emmGrid objects. code , obtain EMMs source pigs data, compare sources pairwise. ---box configuration, pairs() sets two defaults summary(): adjust = \"tukey\" (multiplicity adjustment), infer = c(FALSE, TRUE) (test statistics, confidence intervals). may override , course, calling summary() result different values . example , EMMs later factor levels subtracted earlier levels; want comparisons go direction, use pairs(pigs.emm.s, reverse = TRUE). Also, multi-factor situations, may specify factor(s) perform comparisons separately levels factors.","code":"pigs.lm <- lm(log(conc) ~ source + factor(percent), data = pigs) pigs.emm.s <- emmeans(pigs.lm, \"source\") pairs(pigs.emm.s) ##  contrast    estimate     SE df t.ratio p.value ##  fish - soy    -0.273 0.0529 23  -5.153  0.0001 ##  fish - skim   -0.402 0.0542 23  -7.428  <.0001 ##  soy - skim    -0.130 0.0530 23  -2.442  0.0570 ##  ## Results are averaged over the levels of: percent  ## Results are given on the log (not the response) scale.  ## P value adjustment: tukey method for comparing a family of 3 estimates"},{"path":"https://rvlenth.github.io/emmeans/articles/comparisons.html","id":"pwpm","dir":"Articles","previous_headings":"Pairwise comparisons","what":"Matrix displays","title":"Comparisons and contrasts in emmeans","text":"numerical main results associated pairwise comparisons can presented compactly matrix form via pwpm() function. simply hand emmGrid object use making comparisons: matrix shows EMMs along diagonal, \\(P\\) values upper triangle, differences lower triangle. Options exist switch one switch triangle used latter two. Also, optional arguments passed. instance, can reverse direction comparisons, suppress display EMMs, swap \\(P\\) values go, perform noninferiority tests threshold 0.05 follows: three P values small, fish, soy, skim increasing order noninferiority based given threshold. one factor present, existing newly specified variables() can split results l list matrices.","code":"pwpm(pigs.emm.s) ##        fish    soy   skim ## fish [3.39] <.0001 <.0001 ## soy  -0.273 [3.67] 0.0570 ## skim -0.402 -0.130 [3.80] ##  ## Row and column labels: source ## Upper triangle: P values   adjust = \"tukey\" ## Diagonal: [Estimates] (emmean)  ## Lower triangle: Comparisons (estimate)   earlier vs. later pwpm(pigs.emm.s, means = FALSE, flip = TRUE,     # args for pwpm()      reverse = TRUE,                             # args for pairs()      side = \">\", delta = 0.05, adjust = \"none\")  # args for test() ##        fish    soy  skim ## fish         0.273 0.402 ## soy  <.0001        0.130 ## skim <.0001 0.0013       ##  ## Row and column labels: source ## Lower triangle: P values   side = \">\"  delta = 0.05 ## Upper triangle: Comparisons (estimate)   later vs. earlier"},{"path":"https://rvlenth.github.io/emmeans/articles/comparisons.html","id":"effect-size","dir":"Articles","previous_headings":"Pairwise comparisons","what":"Effect size","title":"Comparisons and contrasts in emmeans","text":"users desire standardized effect-size measures. popular probably Cohen’s d, defined observed difference, divided population SD; obviously Cohen effect sizes close cousins pairwise differences. available via eff_size() function, user must specify emmGrid object means compared, estimated population SD sigma, degrees freedom edf. illustrated current example: confidence intervals shown take account error estimating sigma well error differences. Note intervals narrower claim know sigma perfectly (.e., infinite degrees freedom): Note eff_size() expects object means, differences. want use differences, use method argument specify don’t want compute pairwise differences ; e.g., (results identical first effect sizes shown).","code":"eff_size(pigs.emm.s, sigma = sigma(pigs.lm), edf = 23) ##  contrast    effect.size    SE df lower.CL upper.CL ##  fish - soy        -2.37 0.577 23    -3.56   -1.175 ##  fish - skim       -3.49 0.698 23    -4.94   -2.051 ##  soy - skim        -1.12 0.490 23    -2.14   -0.112 ##  ## Results are averaged over the levels of: percent  ## sigma used for effect sizes: 0.1151  ## Confidence level used: 0.95 eff_size(pigs.emm.s, sigma = sigma(pigs.lm), edf = Inf) ##  contrast    effect.size    SE df lower.CL upper.CL ##  fish - soy        -2.37 0.460 23    -3.32   -1.418 ##  fish - skim       -3.49 0.470 23    -4.47   -2.521 ##  soy - skim        -1.12 0.461 23    -2.08   -0.172 ##  ## Results are averaged over the levels of: percent  ## sigma used for effect sizes: 0.1151  ## Confidence level used: 0.95 eff_size(pairs(pigs.emm.s), sigma = sigma(pigs.lm), edf = 23, method = \"identity\")"},{"path":"https://rvlenth.github.io/emmeans/articles/comparisons.html","id":"graphical","dir":"Articles","previous_headings":"Pairwise comparisons","what":"Graphical comparisons","title":"Comparisons and contrasts in emmeans","text":"Comparisons may summarized graphically via comparisons argument plot.emm():  blue bars confidence intervals EMMs, red arrows comparisons among . arrow one mean overlaps arrow another group, difference “significant,” based adjust setting (defaults \"tukey\") value alpha (defaults 0.05). See “xplanations” supplement details derived. Note: Don’t ever use confidence intervals EMMs perform comparisons; can misleading. Use comparison arrows instead; better yet, use pwpp(). caution: really good practice draw bright distinction based whether P value exceeds cutoff. display dim distinctions somewhat allowing viewer judge whether P value close alpha one way ; better strategy simply obtain P values using pairs(), look individually.","code":"plot(pigs.emm.s, comparisons = TRUE)"},{"path":"https://rvlenth.github.io/emmeans/articles/comparisons.html","id":"pwpp","dir":"Articles","previous_headings":"Pairwise comparisons > Graphical comparisons","what":"Pairwise P-value plots","title":"Comparisons and contrasts in emmeans","text":"trying develop alternative compact letter displays (see next subsection), devised “pairwise P-value plot” displaying P values pairwise comparisons:  comparison associated vertical line segment joins scale positions two EMMs compared, whose horizontal position determined P value comparison. kind plot can get quite “busy” number means compared goes . example, suppose include interactions model pigs data, compare 12 cell means:  plot lot stuff going , consider looking row--row. Next EMM, can visualize P values 11 comparisons EMM (along color codes). Also, note can include arguments passed summary(); case, display back-transformed means. willing forgo diagonal comparisons (neither factor common level), can make lot less cluttered via specification:  latter plot can see comparisons skim source tend statistically stronger. also opportunity remind user multiplicity adjustments made relative group. example, comparing skim:9 versus skim:15 Tukey-adjusted P value somewhat greater 0.1 one family 12 means, 0.02 relative smaller family 4 means depicted three-paneled plot.","code":"pwpp(pigs.emm.s) pigs.lmint <- lm(log(conc) ~ source * factor(percent), data = pigs) pigs.cells <- emmeans(pigs.lmint, ~ source * percent) pwpp(pigs.cells, type = \"response\") pwpp(pigs.cells, by = \"source\", type = \"response\")"},{"path":"https://rvlenth.github.io/emmeans/articles/comparisons.html","id":"CLD","dir":"Articles","previous_headings":"Pairwise comparisons > Graphical comparisons","what":"Compact letter displays (CLDs)","title":"Comparisons and contrasts in emmeans","text":"Another way depict comparisons compact letter displays, whereby two EMMs sharing one grouping symbols “significantly” different. may generated multcomp::cld() function. really recommend kind display, though, decline illustrate . displays promote visually idea two means “significantly different” judged equal; wrong interpretation. addition, draw artificial “bright line” P values either side alpha, even ones close. Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/comparisons.html","id":"contrasts","dir":"Articles","previous_headings":"","what":"Other contrasts","title":"Comparisons and contrasts in emmeans","text":"Pairwise comparisons example linear functions EMMs. may use coef() see coefficients linear functions: pairwise comparisons correspond columns results. example, first pairwise comparison, fish - soy, gives coefficients 1, -1, 0 fish, soy, skim, respectively. cases, one, column coefficients sums zero, linear functions termed contrasts contrast() function provides general contrasts (linear functions, well) factor levels. second argument, method, used specify method used. section describe built-ones, simply provide name built-method. Consider, example, factor percent model pigs.lm . treated factor model, corresponds equally-spaced values numeric variable. cases, users often want compute orthogonal polynomial contrasts: obtain tests linear, quadratic, cubic trends. coefficients can found tables many experimental-design texts. important understand estimated linear contrast slope line fitted data. simply contrast coefficients increase linearly. test linear trend, however. number named contrast methods, example \"trt.vs.ctrl\", \"eff\", \"consec\". \"pairwise\" \"revpairwise\" methods contrast() Pairs() pairs(..., reverse = TRUE). See help(\"contrast-methods\") details. Back Contents","code":"coef(pairs(pigs.emm.s)) ##      source c.1 c.2 c.3 ## fish   fish   1   1   0 ## soy     soy  -1   0   1 ## skim   skim   0  -1  -1 pigs.emm.p <- emmeans(pigs.lm, \"percent\") ply <- contrast(pigs.emm.p, \"poly\") ply ##  contrast  estimate     SE df t.ratio p.value ##  linear      0.9374 0.2106 23   4.452  0.0002 ##  quadratic  -0.0971 0.0883 23  -1.099  0.2830 ##  cubic       0.1863 0.1877 23   0.992  0.3313 ##  ## Results are averaged over the levels of: source  ## Results are given on the log (not the response) scale. coef(ply) ##           percent c.1 c.2 c.3 ## percent9        9  -3   1  -1 ## percent12      12  -1  -1   3 ## percent15      15   1  -1  -3 ## percent18      18   3   1   1"},{"path":"https://rvlenth.github.io/emmeans/articles/comparisons.html","id":"formulas","dir":"Articles","previous_headings":"","what":"Formula interface","title":"Comparisons and contrasts in emmeans","text":"already know contrasts want calling emmeans(), quick way get specify method left-hand side formula second argument. example, oranges dataset provided package, contrasts shown day--day changes. two-sided formula technique quite convenient, can also create confusion. one thing, result emmGrid object anymore; list emmGrid objects, called emm_list. may need cognizant contrasts analyzes. example want \"eff\" contrasts well, need contrast(org.emml[[1]], \"eff\") contrast(org.emml, \"eff\", = 1). Another issue may unclear part results affected certain options. example, add adjust = \"bonf\" org.emm call , Bonferroni adjustment applied EMMs, contrasts? (See documentation interested; best practice avoid dilemmas.) Back Contents","code":"org.aov <- aov(sales1 ~ day + Error(store), data = oranges,                contrasts = list(day = \"contr.sum\")) org.emml <- emmeans(org.aov, consec ~ day) org.emml ## $emmeans ##  day emmean   SE   df lower.CL upper.CL ##  1     7.87 2.77 29.2     2.21     13.5 ##  2     7.10 2.77 29.2     1.43     12.8 ##  3    13.76 2.77 29.2     8.09     19.4 ##  4     8.04 2.77 29.2     2.37     13.7 ##  5    12.92 2.77 29.2     7.26     18.6 ##  6    11.60 2.77 29.2     5.94     17.3 ##  ## Warning: EMMs are biased unless design is perfectly balanced  ## Confidence level used: 0.95  ##  ## $contrasts ##  contrast    estimate   SE df t.ratio p.value ##  day2 - day1   -0.772 3.78 25  -0.204  0.9997 ##  day3 - day2    6.658 3.78 25   1.763  0.3242 ##  day4 - day3   -5.716 3.78 25  -1.513  0.4678 ##  day5 - day4    4.882 3.78 25   1.293  0.6128 ##  day6 - day5   -1.321 3.78 25  -0.350  0.9965 ##  ## P value adjustment: mvt method for 5 tests"},{"path":"https://rvlenth.github.io/emmeans/articles/comparisons.html","id":"linfcns","dir":"Articles","previous_headings":"","what":"Custom contrasts and linear functions","title":"Comparisons and contrasts in emmeans","text":"user may write custom contrast function use contrast(). ’s needed function desired name \".emmc\" appended, generates needed coefficients list data frame. function take vector levels first argument, optional parameters additional arguments. also always ... argument allow unspecified arguments may occur call. example, suppose want compare every third level treatment. following function provides : test , try 5 levels: (latter \"consec\" contrasts.) Now try oranges example previously:","code":"skip_comp.emmc <- function(levels, skip = 1, reverse = FALSE, ...) {     if((k <- length(levels)) < skip + 1)         stop(\"Need at least \", skip + 1, \" levels\")     coef <- data.frame()     coef <- as.data.frame(lapply(seq_len(k - skip - 1), function(i) {         sgn <- ifelse(reverse, -1, 1)         sgn * c(rep(0, i - 1), 1, rep(0, skip), -1, rep(0, k - i - skip - 1))     }))     names(coef) <- sapply(coef, function(x)         paste(which(x == 1), \"-\", which(x == -1)))     attr(coef, \"adjust\") = \"fdr\"   # default adjustment method     coef } skip_comp.emmc(1:5) ##   1 - 3 2 - 4 3 - 5 ## 1     1     0     0 ## 2     0     1     0 ## 3    -1     0     1 ## 4     0    -1     0 ## 5     0     0    -1 skip_comp.emmc(1:5, skip = 0, reverse = TRUE) ##   2 - 1 3 - 2 4 - 3 5 - 4 ## 1    -1     0     0     0 ## 2     1    -1     0     0 ## 3     0     1    -1     0 ## 4     0     0     1    -1 ## 5     0     0     0     1 contrast(org.emml[[1]], \"skip_comp\", skip = 2, reverse = TRUE) ##  contrast estimate   SE df t.ratio p.value ##  4 - 1        0.17 3.78 25   0.045  0.9645 ##  5 - 2        5.82 3.78 25   1.542  0.4069 ##  6 - 3       -2.15 3.78 25  -0.571  0.8601 ##  ## P value adjustment: fdr method for 3 tests"},{"path":"https://rvlenth.github.io/emmeans/articles/comparisons.html","id":null,"dir":"Articles","previous_headings":"","what":"Comparisons and contrasts in emmeans","title":"Comparisons and contrasts in emmeans","text":"contrast() function may fact used compute arbitrary linear functions EMMs. Suppose reason want estimate quantities \\(\\lambda_1 = \\mu_1+2\\mu_2-7\\) \\(\\lambda_2 = 3\\mu_2-2\\mu_3+1\\), \\(\\mu_j\\) population values source EMMs pigs example. may done providing coefficients list, added constants offset argument: Back Contents","code":"LF <- contrast(pigs.emm.s,                 list(lambda1 = c(1, 2, 0), lambda2 = c(0, 3, -2)),                offset = c(-7, 1)) confint(LF, adjust = \"bonferroni\") ##  contrast estimate     SE df lower.CL upper.CL ##  lambda1      3.73 0.0827 23     3.53     3.93 ##  lambda2      4.41 0.1341 23     4.09     4.73 ##  ## Results are averaged over the levels of: percent  ## Note: contrasts are still on the log scale  ## Confidence level used: 0.95  ## Conf-level adjustment: bonferroni method for 2 estimates"},{"path":"https://rvlenth.github.io/emmeans/articles/comparisons.html","id":"logs","dir":"Articles","previous_headings":"","what":"Special properties of log (and logit) transformations","title":"Comparisons and contrasts in emmeans","text":"Suppose obtain EMMs model response transformation link function. cases, compute contrasts EMMs, natural way express contrasts anything transformed scale. example, model fitted using glm() gamma() family, default link function inverse. Predictions model estimates \\(1/\\mu_j\\) various \\(j\\). Comparisons predictions estimates \\(1/\\mu_j - 1/\\mu_{k}\\) \\(j \\ne k\\). natural way back-transform differences interpretable scale. However, logs exception, \\(\\log\\mu_j - \\log\\mu_k = \\log(\\mu_j/\\mu_k)\\). Accordingly, contrast() (pairs()) notices response log scale, back-transforms contrasts ratios results response type. example: true EMM summaries type = \"response\", tests confidence intervals done back-transforming. ratios estimated actually ratios geometric means. general, model log response fact model relative effects linear predictors, back-transformation ratios goes hand--hand . generalized linear models, behaviors occur two common cases: Poisson count regression, usual link log; logistic regression, logits logs odds ratios. Back Contents Index vignette topics","code":"pairs(pigs.emm.s, type = \"lp\") ##  contrast    estimate     SE df t.ratio p.value ##  fish - soy    -0.273 0.0529 23  -5.153  0.0001 ##  fish - skim   -0.402 0.0542 23  -7.428  <.0001 ##  soy - skim    -0.130 0.0530 23  -2.442  0.0570 ##  ## Results are averaged over the levels of: percent  ## Results are given on the log (not the response) scale.  ## P value adjustment: tukey method for comparing a family of 3 estimates pairs(pigs.emm.s, type = \"response\") ##  contrast    ratio     SE df null t.ratio p.value ##  fish / soy  0.761 0.0403 23    1  -5.153  0.0001 ##  fish / skim 0.669 0.0362 23    1  -7.428  <.0001 ##  soy / skim  0.879 0.0466 23    1  -2.442  0.0570 ##  ## Results are averaged over the levels of: percent  ## P value adjustment: tukey method for comparing a family of 3 estimates  ## Tests are performed on the log scale"},{"path":"https://rvlenth.github.io/emmeans/articles/confidence-intervals.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"Confidence intervals and tests in emmeans","text":"vignette describes various ways summarizing emmGrid objects. summary(), confint(), test() Back-transforming response scale (See also “transformations” vignette) Multiplicity adjustments Using “” variables Joint (omnibus) tests Testing equivalence, noninferiority, nonsuperiority Graphics (“basics” vignette) Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/confidence-intervals.html","id":"summary","dir":"Articles","previous_headings":"","what":"summary(), confint(), and test()","title":"Confidence intervals and tests in emmeans","text":"important method emmGrid objects summary(). one thing, called default display emmeans() result. summary() function lot options, detailed documentation via help(\"summary.emmGrid\") worth look. ongoing illustrations, let’s re-create objects “basics” vignette pigs example: Just summary(<object>) produce summary varies somewhat according context. setting different defaults infer argument, consists two logical values, specifying confidence intervals tests, respectively. [exception models fitted using MCMC methods, summary() diverted hpd.summary() function, preferable summary many Bayesians.] summary newly made reference grid show just estimates standard errors, confidence intervals tests (, infer = c(FALSE, FALSE)). summary emmeans() result, see , intervals, tests (.e., infer = c(TRUE, FALSE)); result contrast() call (see comparisons contrasts) show test statistics P values, intervals (.e., infer = c(FALSE, TRUE)). courtesy methods confint() test() just call summary() appropriate infer setting; example, particularly useful, though, test EMMs default zero – tests usually shown. makes lot sense test target concentration, say 40. suppose want one-sided test see concentration greater 40. Remembering response inverse-transformed model, inverse transformation reverses direction comparisons, right-tailed test conc scale becomes left-tailed test inverse(conc) scale, also possible add calculated columns summary, via calc argument. calculations can include columns df summary, well variable object’s grid slot. Among latter usually weights column named .wgt., can use include sample size summary: Back Contents","code":"mod4 <- lm(inverse(conc) ~ source + factor(percent), data = pigs) RG <- ref_grid(mod4) EMM.source <- emmeans(RG, \"source\") test(EMM.source) ##  source emmean       SE df t.ratio p.value ##  fish   0.0337 0.000926 23  36.380  <.0001 ##  soy    0.0257 0.000945 23  27.141  <.0001 ##  skim   0.0229 0.000994 23  22.989  <.0001 ##  ## Results are averaged over the levels of: percent  ## Results are given on the inverse (not the response) scale. test(EMM.source, null = inverse(40), side = \"<\") ##  source emmean       SE df  null t.ratio p.value ##  fish   0.0337 0.000926 23 0.025   9.383  1.0000 ##  soy    0.0257 0.000945 23 0.025   0.697  0.7535 ##  skim   0.0229 0.000994 23 0.025  -2.156  0.0209 ##  ## Results are averaged over the levels of: percent  ## Results are given on the inverse (not the response) scale.  ## P values are left-tailed confint(EMM.source, calc = c(n = ~.wgt.)) ##  source emmean       SE df  n lower.CL upper.CL ##  fish   0.0337 0.000926 23 10   0.0318   0.0356 ##  soy    0.0257 0.000945 23 10   0.0237   0.0276 ##  skim   0.0229 0.000994 23  9   0.0208   0.0249 ##  ## Results are averaged over the levels of: percent  ## Results are given on the inverse (not the response) scale.  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/confidence-intervals.html","id":"tran","dir":"Articles","previous_headings":"","what":"Back-transforming","title":"Confidence intervals and tests in emmeans","text":"Transformations link functions supported several ways emmeans, making complex topic worthy vignette. , show just basic approach. Namely, specifying argument type = \"response\" cause displayed results back-transformed response scale, transformation link function incorporated model. example, let’s try preceding test() call : Note changes doesn’t change. test() call, still use 1/40 null value; null must always specified linear-prediction scale, case inverse. output, displayed estimates, well null value, shown back-transformed. well, standard errors altered (using delta method). However, t ratios P values identical preceding results. , tests still conducted linear-predictor scale (noted output). Similar statements apply confidence intervals response scale: side = \"<\", upper confidence limit computed inverse scale, limit back-transformed response scale; since inverse reverses everything, upper confidence limits become lower ones response scale. (also illustrated change confidence level.) Back Contents","code":"test(EMM.source, null = inverse(40), side = \"<\", type = \"response\") ##  source response    SE df null t.ratio p.value ##  fish       29.7 0.816 23   40   9.383  1.0000 ##  soy        39.0 1.436 23   40   0.697  0.7535 ##  skim       43.8 1.903 23   40  -2.156  0.0209 ##  ## Results are averaged over the levels of: percent  ## P values are left-tailed  ## Tests are performed on the inverse scale confint(EMM.source, side = \"<\", level = .90, type = \"response\") ##  source response    SE df lower.CL upper.CL ##  fish       29.7 0.816 23     28.6      Inf ##  soy        39.0 1.436 23     37.2      Inf ##  skim       43.8 1.903 23     41.4      Inf ##  ## Results are averaged over the levels of: percent  ## Confidence level used: 0.9  ## Intervals are back-transformed from the inverse scale"},{"path":"https://rvlenth.github.io/emmeans/articles/confidence-intervals.html","id":"adjust","dir":"Articles","previous_headings":"","what":"Multiplicity adjustments","title":"Confidence intervals and tests in emmeans","text":"tests confidence intervals may adjusted simultaneous inference. adjustments ensure confidence coefficient whole set intervals least specified level, control multiplicity whole family tests. done via adjust argument. ref_grid() emmeans() results, default adjust = \"none\". contrast() results, adjust often something else, depending type contrasts created. example, pairwise comparisons default adjust = \"tukey\", .e., Tukey HSD method. summary() function sometimes changes adjust inappropriate. example, adjustment changed Sidak method Tukey adjustment inappropriate unless pairwise comparisons.","code":"confint(EMM.source, adjust = \"tukey\") ## Note: adjust = \"tukey\" was changed to \"sidak\" ## because \"tukey\" is only appropriate for one set of pairwise comparisons ##  source emmean       SE df lower.CL upper.CL ##  fish   0.0337 0.000926 23   0.0313   0.0361 ##  soy    0.0257 0.000945 23   0.0232   0.0281 ##  skim   0.0229 0.000994 23   0.0203   0.0254 ##  ## Results are averaged over the levels of: percent  ## Results are given on the inverse (not the response) scale.  ## Confidence level used: 0.95  ## Conf-level adjustment: sidak method for 3 estimates"},{"path":"https://rvlenth.github.io/emmeans/articles/confidence-intervals.html","id":null,"dir":"Articles","previous_headings":"","what":"Confidence intervals and tests in emmeans","title":"Confidence intervals and tests in emmeans","text":"adjustment method usually appropriate Bonferroni; however, can quite conservative. Using adjust = \"mvt\" closest “exact” -around method “single-step” method, uses multivariate t distribution (mvtnorm package) covariance structure estimates determine adjustment. However, comes high computational expense computations done using simulation techniques. large set tests (especially confidence intervals), computational lag becomes noticeable intolerable. tests, adjust increases P values otherwise obtained adjust = \"none\". Compare following adjusted tests unadjusted ones previously computed. Back Contents","code":"test(EMM.source, null = inverse(40), side = \"<\", adjust = \"bonferroni\") ##  source emmean       SE df  null t.ratio p.value ##  fish   0.0337 0.000926 23 0.025   9.383  1.0000 ##  soy    0.0257 0.000945 23 0.025   0.697  1.0000 ##  skim   0.0229 0.000994 23 0.025  -2.156  0.0627 ##  ## Results are averaged over the levels of: percent  ## Results are given on the inverse (not the response) scale.  ## P value adjustment: bonferroni method for 3 tests  ## P values are left-tailed"},{"path":"https://rvlenth.github.io/emmeans/articles/confidence-intervals.html","id":"byvars","dir":"Articles","previous_headings":"","what":"“By” variables","title":"Confidence intervals and tests in emmeans","text":"Sometimes want break summary smaller pieces; purpose, argument summary() useful. example, also adjust force variables used, default, adjustment made separately group; e.g., , adjusting sets 4 intervals, 12 together (see “cross-adjustments” .) can specification emmeans() (equivalently, | formula); , passed summary() used unless overridden another . examples, run: Specifying = NULL remove grouping.","code":"confint(RG, by = \"source\") ## source = fish: ##  percent prediction      SE df lower.CL upper.CL ##        9     0.0385 0.00135 23   0.0357   0.0413 ##       12     0.0333 0.00125 23   0.0307   0.0359 ##       15     0.0326 0.00138 23   0.0297   0.0354 ##       18     0.0304 0.00138 23   0.0275   0.0332 ##  ## source = soy: ##  percent prediction      SE df lower.CL upper.CL ##        9     0.0305 0.00126 23   0.0279   0.0331 ##       12     0.0253 0.00124 23   0.0227   0.0278 ##       15     0.0245 0.00128 23   0.0219   0.0272 ##       18     0.0223 0.00162 23   0.0190   0.0257 ##  ## source = skim: ##  percent prediction      SE df lower.CL upper.CL ##        9     0.0277 0.00127 23   0.0251   0.0303 ##       12     0.0225 0.00125 23   0.0199   0.0250 ##       15     0.0217 0.00139 23   0.0189   0.0246 ##       18     0.0195 0.00163 23   0.0162   0.0229 ##  ## Results are given on the inverse (not the response) scale.  ## Confidence level used: 0.95 emmeans(mod4, ~ percent | source)     ### same results as above summary(.Last.value, by = \"percent\")       ### grouped the other way"},{"path":"https://rvlenth.github.io/emmeans/articles/confidence-intervals.html","id":"cross-adjust","dir":"Articles","previous_headings":"“By” variables","what":"Adjustments across by groups","title":"Confidence intervals and tests in emmeans","text":"mentioned, group regarded separate family regards adjust procedure. example, consider model interaction warpbreaks data, construct pairwise comparisons tension wool: two sets 3 comparisons, (default) Tukey adjustment made separately group. However, sometimes want multiplicity adjustment broader. broadening can done two ways. One remove variable, treats results one family. example: accomplishes goal putting comparisons one family 6 comparisons. Note Tukey adjustment may used longer one set pairwise comparisons. alternative specify cross.adjust, specifies additional adjustment method apply corresponding sets within-group adjusted P values: adjustments less conservative previous result, still conservative adjustment set 6 tests. also specified adjust = \"bonferroni\", obtained adjusted P values obtained = NULL.","code":"warp.lm <- lm(breaks ~ wool * tension, data = warpbreaks) warp.pw <- pairs(emmeans(warp.lm, ~ tension | wool)) warp.pw ## wool = A: ##  contrast estimate   SE df t.ratio p.value ##  L - M      20.556 5.16 48   3.986  0.0007 ##  L - H      20.000 5.16 48   3.878  0.0009 ##  M - H      -0.556 5.16 48  -0.108  0.9936 ##  ## wool = B: ##  contrast estimate   SE df t.ratio p.value ##  L - M      -0.556 5.16 48  -0.108  0.9936 ##  L - H       9.444 5.16 48   1.831  0.1704 ##  M - H      10.000 5.16 48   1.939  0.1389 ##  ## P value adjustment: tukey method for comparing a family of 3 estimates test(warp.pw, by = NULL, adjust = \"bonferroni\") ##  contrast wool estimate   SE df t.ratio p.value ##  L - M    A      20.556 5.16 48   3.986  0.0014 ##  L - H    A      20.000 5.16 48   3.878  0.0019 ##  M - H    A      -0.556 5.16 48  -0.108  1.0000 ##  L - M    B      -0.556 5.16 48  -0.108  1.0000 ##  L - H    B       9.444 5.16 48   1.831  0.4396 ##  M - H    B      10.000 5.16 48   1.939  0.3504 ##  ## P value adjustment: bonferroni method for 6 tests test(warp.pw, adjust = \"tukey\", cross.adjust = \"bonferroni\") ## wool = A: ##  contrast estimate   SE df t.ratio p.value ##  L - M      20.556 5.16 48   3.986  0.0013 ##  L - H      20.000 5.16 48   3.878  0.0018 ##  M - H      -0.556 5.16 48  -0.108  1.0000 ##  ## wool = B: ##  contrast estimate   SE df t.ratio p.value ##  L - M      -0.556 5.16 48  -0.108  1.0000 ##  L - H       9.444 5.16 48   1.831  0.3407 ##  M - H      10.000 5.16 48   1.939  0.2777 ##  ## P value adjustment: tukey method for comparing a family of 3 estimates  ## Cross-group P-value adjustment: bonferroni"},{"path":"https://rvlenth.github.io/emmeans/articles/confidence-intervals.html","id":"simple","dir":"Articles","previous_headings":"“By” variables","what":"Simple comparisons","title":"Confidence intervals and tests in emmeans","text":"also simple argument contrast() essence inverse ; contrasts run using everything except specified variables variables. illustrate, let’s consider model pigs includes interaction (levels one factor compare differently levels factor). fact, may one-factor comparisons specifying simple = \"\". typically produces lot output, use care. Back Contents","code":"mod5 <- lm(inverse(conc) ~ source * factor(percent), data = pigs) RG5 <- ref_grid(mod5) contrast(RG5, \"consec\", simple = \"percent\") ## source = fish: ##  contrast               estimate      SE df t.ratio p.value ##  percent12 - percent9  -6.64e-03 0.00285 17  -2.328  0.0833 ##  percent15 - percent12 -6.68e-05 0.00285 17  -0.023  1.0000 ##  percent18 - percent15 -1.40e-03 0.00285 17  -0.489  0.9283 ##  ## source = soy: ##  contrast               estimate      SE df t.ratio p.value ##  percent12 - percent9  -4.01e-03 0.00255 17  -1.572  0.3168 ##  percent15 - percent12  2.61e-04 0.00255 17   0.102  0.9993 ##  percent18 - percent15 -2.18e-03 0.00361 17  -0.605  0.8872 ##  ## source = skim: ##  contrast               estimate      SE df t.ratio p.value ##  percent12 - percent9  -5.26e-03 0.00255 17  -2.061  0.1401 ##  percent15 - percent12 -2.86e-03 0.00285 17  -1.001  0.6526 ##  percent18 - percent15 -3.76e-03 0.00383 17  -0.982  0.6650 ##  ## Note: contrasts are still on the inverse scale  ## P value adjustment: mvt method for 3 tests"},{"path":"https://rvlenth.github.io/emmeans/articles/confidence-intervals.html","id":"joint","dir":"Articles","previous_headings":"","what":"Joint tests","title":"Confidence intervals and tests in emmeans","text":", already know test individual results. pairwise comparisons (details “comparisons” vignette), might suppose want omnibus test comparisons zero. Easy enough, using joint argument test (note: joint argument available summary(); test()): Notice three comparisons, 2 d.f. test, cautioned message. test produced joint = TRUE “type III” test (assuming default equal weights used obtain EMMs). See types tests higher-order effects “interactions” vignette section contrasts.","code":"PRS.source <- pairs(EMM.source) PRS.source ##  contrast    estimate      SE df t.ratio p.value ##  fish - soy   0.00803 0.00134 23   6.009  <.0001 ##  fish - skim  0.01083 0.00137 23   7.922  <.0001 ##  soy - skim   0.00280 0.00134 23   2.092  0.1136 ##  ## Results are averaged over the levels of: percent  ## Note: contrasts are still on the inverse scale  ## P value adjustment: tukey method for comparing a family of 3 estimates test(PRS.source, joint = TRUE) ##  df1 df2 F.ratio p.value note ##    2  23  34.009  <.0001  d   ##  ## d: df1 reduced due to linear dependence"},{"path":"https://rvlenth.github.io/emmeans/articles/confidence-intervals.html","id":null,"dir":"Articles","previous_headings":"","what":"Confidence intervals and tests in emmeans","title":"Confidence intervals and tests in emmeans","text":"convenience, also joint_tests() function performs joint tests contrasts among term model emmGrid object. tests main effects families contrasts; interaction effects interaction contrasts. results essentially “Type-III ANOVA”, may differ situations empty cells non-estimability issues, generalizations present unequal weighting. (Another distinction sums squares mean squares shown; really tests contrasts among predictions, may may correspond model sums squares.) One may use variables joint_tests. example: models, possible specify submodel = \"type2\", thereby obtaining something akin Type II analysis variance. See messy-data vignette example. Back Contents","code":"joint_tests(RG5) ##  model term     df1 df2 F.ratio p.value ##  source           2  17  30.309  <.0001 ##  percent          3  17   8.441  0.0012 ##  source:percent   6  17   0.481  0.8135 joint_tests(RG5, by = \"source\") ## source = fish: ##  model term df1 df2 F.ratio p.value ##  percent      3  17   2.967  0.0614 ##  ## source = soy: ##  model term df1 df2 F.ratio p.value ##  percent      3  17   1.376  0.2840 ##  ## source = skim: ##  model term df1 df2 F.ratio p.value ##  percent      3  17   4.835  0.0130"},{"path":"https://rvlenth.github.io/emmeans/articles/confidence-intervals.html","id":"equiv","dir":"Articles","previous_headings":"","what":"Testing equivalence, noninferiority, and nonsuperiority","title":"Confidence intervals and tests in emmeans","text":"delta argument summary() test() allows user specify threshold value use test equivalence, noninferiority, nonsuperiority. equivalence test kind backwards significance test, small P values associated small differences relative specified threshold value delta. help page summary.emmGrid gives details tests. Suppose present example, consider two sources equivalent within 0.005 . can test follows: Using 0.005 threshold, P value quite small comparing soy skim, providing statistical evidence difference enough smaller threshold consider equivalent. Back Contents","code":"test(PRS.source, delta = 0.005, adjust = \"none\") ##  contrast    estimate      SE df t.ratio p.value ##  fish - soy   0.00803 0.00134 23   2.268  0.9835 ##  fish - skim  0.01083 0.00137 23   4.266  0.9999 ##  soy - skim   0.00280 0.00134 23  -1.641  0.0572 ##  ## Results are averaged over the levels of: percent  ## Note: contrasts are still on the inverse scale  ## Statistics are tests of equivalence with a threshold of 0.005  ## P values are left-tailed"},{"path":"https://rvlenth.github.io/emmeans/articles/confidence-intervals.html","id":"graphics","dir":"Articles","previous_headings":"","what":"Graphics","title":"Confidence intervals and tests in emmeans","text":"Graphical displays emmGrid objects described “basics” vignette Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"FAQs for emmeans","text":"EMMs/lsmeans? fastest way obtain EMMs pairwise comparisons? wanted comparisons, get (nothing) model fitted supported emmeans three (two four) factors interact covariate(s) interact(s) factor(s) covariate(s) fitting polynomial model “significant” comparisons overlapping confidence intervals pairwise comparisons P value emmeans() doesn’t work expected results NA analyze subsets data separately, get different results lsmeans/EMMs way expected get Inf degrees freedom? get exactly comparisons “” group ANOVA F significant, pairwise comparisons wanted differences, instead got ratios (odds ratios) asked Tukey adjustments, ’s got emmeans() completely ignores P-value adjustments emmeans() gives pooled t tests, expected Welch’s t Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"what","dir":"Articles","previous_headings":"","what":"What are EMMs/lsmeans?","title":"FAQs for emmeans","text":"Estimated marginal means (EMMs), .k.. least-squares means, predictions reference grid predictor settings, marginal averages thereof. See details “basics” vignette.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"fastest","dir":"Articles","previous_headings":"","what":"What is the fastest way to obtain EMMs and pairwise comparisons?","title":"FAQs for emmeans","text":"two answers (.e., careful wish ): Don’t think; just fit first model comes mind run emmeans(model, pairwise ~ treatment). fastest way; however, results good chance invalid. think: Make sure fit model really explains responses. diagnostic residual plots, include appropriate interactions, account heteroscadesticity necessary, etc. fastest way obtain appropriate estimates comparisons. point emmeans() summarizes model, data directly. use bad model, get bad results. use good model, get appropriate results. ’s : ’s research—important? Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"nopairs","dir":"Articles","previous_headings":"","what":"I wanted comparisons, but all I get is (nothing)","title":"FAQs for emmeans","text":"happens one estimate; can’t compare ! turn can happen situation like : fitted treat coded dataset numbers 1, 2, 3, … . Since treat numeric predictor, emmeans() just reduces single number, mean, rather separate values treatment. Also, please note almost certainly model want, forces assumption treatment effects fall straight line. fit model like much better luck comparisons.","code":"mod <- lm(RT ~ treat, data = mydata) mod <- lm(RT ~ factor(treat), data = mydata)"},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"qdrg","dir":"Articles","previous_headings":"","what":"The model I fitted is not supported by emmeans","title":"FAQs for emmeans","text":"may still able get results using qdrg() (quick dirty reference grid). See ?qdrg details examples.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"interactions","dir":"Articles","previous_headings":"","what":"I have three (or two or four) factors that interact","title":"FAQs for emmeans","text":"Perhaps question interacting factors, want kind post hoc analysis comparing levels one () factors response. specific versions question… Perhaps tried simple comparison one treatment got warning message don’t understand pairwise comparisons factor combinations ’s just much – want just even approach ? first answer : plots almost always help. factors , B, C, try something like emmip(model, ~ B | C), creates interaction-style plot predictions B, , separate panels C. help visualize effects stand practical way. can guide post-hoc tests make sense. See “interactions” vignette discussion examples. Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"trends","dir":"Articles","previous_headings":"","what":"I have covariate(s) that interact(s) with factor(s)","title":"FAQs for emmeans","text":"situation may well appropriate compare slopes trend lines, rather EMMs. See help(\"emtrends\"()“)` discussion topic “interactions” vignette","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"polys","dir":"Articles","previous_headings":"","what":"I have covariate(s) and am fitting a polynomial model","title":"FAQs for emmeans","text":"need careful define reference grid consistently. example, use covariates x xsq (equal x^2) fit quadratic curve, default reference grid uses mean covariate – mean(xsq) usually mean(x)^2. need use ensure covariates set consistently respect model. See subsection “basics” vignette example.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"CIerror","dir":"Articles","previous_headings":"","what":"Some “significant” comparisons have overlapping confidence intervals","title":"FAQs for emmeans","text":"can happen just plain wrong use [non-]overlapping CIs individual means comparisons. Look printed results something like emmeans(mymodel, pairwise ~ treatment). particular, note SE values *, may even different degrees freedom. Means one thing statistically, differences means quite another thing. Don’t ever mix , don’t ever use CI display comparing means. ’ll add making hard-line decisions “significant” “non-significant” poor practice. See discussion “basics” vignette","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"notfactor","dir":"Articles","previous_headings":"","what":"All my pairwise comparisons have the same P value","title":"FAQs for emmeans","text":"happen fitted model treatments want compare put numeric predictor; example dose, values 1, 2, 3. dose modeled numeric, fitting linear trend dose values, rather model allows doses differ arbitrary ways. Go back fit different model using factor(dose) instead; make difference. closely related next topic.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"numeric","dir":"Articles","previous_headings":"","what":"emmeans() doesn’t work as expected","title":"FAQs for emmeans","text":"Equivalently, users ask get post hoc comparisons covariates rather factors. Yes, work, tell appropriate reference grid. saying , question : sure model meaningful? question concerns two-level predictors sex (coded 1 female, 2 male), problem. model produce predictions ’d get ’d used factors. predictors 3 levels, may fitted nonsense model, case need fit different model make sense kind post hoc analysis. instance, model contains covariate brand (coded 1 Acme, 2 Ajax, 3 Al’s), model implying difference Acme Ajax exactly equal difference Ajax Al’s, owing fact linear trend brand fitted. instead coded 1 Ajax, 2 Al’s, 3 Acme, model produce different fitted values. Ask makes sense brand = 2.319. , need fit another model using factor(brand) place brand. Assuming appropriateness model settled, current version emmeans automatically casts two-value covariates factors, covariates higher numbers unique values. Suppose model covariate dose experimentally varied four levels, can sensibly interpreted numerical predictor. want include separate values dose rather mean dose, can using something like emmeans(model, \"dose\", = list(dose = 1:4)), emmeans(model, \"dose\", cov.keep = \"dose\"), emmeans(model, \"dose\", cov.keep = \"4\"). small differences . last one regards covariate 4 fewer unique values factor. See “altering reference grid” “basics” vignette discussion. Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"NAs","dir":"Articles","previous_headings":"","what":"All or some of the results are NA","title":"FAQs for emmeans","text":"emmeans package uses tools estimability package determine whether results uniquely estimable. example, two-way model interactions included, observations particular cell (factor combination), estimate mean cell. EMMs estimable others , information missing information data. ’s possible remove terms model (particularly interactions), may make things estimable re-fit terms excluded; don’t delete terms really needed model fit well. estimates non-estimable, symptomatic something else. possibilities include: overly ambitious model; example, Latin square design, interaction effects confounded main effects; interactions included model, render main effects inestimable. Possibly nested structure needs included model specified via nesting argument. Perhaps levels B can depend level force. B nested model specify + :B, main effect B. Modeling factors numeric predictors (see also related section covariates). illustrate, suppose data particular state legislatures, model includes predictors state_name well dem_gov coded 1 governor Democrat 0 otherwise. model fitted state_name factor character variable, dem_gov numeric predictor, , chances , emmeans() return non-estimable results. instead, use factor(dem_gov) model, fact state_name nested dem_gov detected, causing EMMs computed separately party’s states, thus making things estimable. things may fact estimable. illustration, ’s easy construct example EMMs non-estimable, pairwise comparisons estimable: “messy-data” vignette examples discussion. Back Contents","code":"pg <- transform(pigs, x = rep(1:3, c(10, 10, 9))) pg.lm <- lm(log(conc) ~ x + source + factor(percent), data = pg) emmeans(pg.lm, consec ~ percent) ## $emmeans ##  percent emmean SE df asymp.LCL asymp.UCL ##        9 nonEst NA NA        NA        NA ##       12 nonEst NA NA        NA        NA ##       15 nonEst NA NA        NA        NA ##       18 nonEst NA NA        NA        NA ##  ## Results are averaged over the levels of: source  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95  ##  ## $contrasts ##  contrast              estimate     SE df t.ratio p.value ##  percent12 - percent9    0.1796 0.0561 23   3.202  0.0114 ##  percent15 - percent12   0.0378 0.0582 23   0.650  0.8613 ##  percent18 - percent15   0.0825 0.0691 23   1.194  0.5201 ##  ## Results are averaged over the levels of: source  ## Results are given on the log (not the response) scale.  ## P value adjustment: mvt method for 3 tests"},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"model","dir":"Articles","previous_headings":"","what":"If I analyze subsets of the data separately, I get different results","title":"FAQs for emmeans","text":"Estimated marginal means summarize model fitted data – data . Many common models rely several simplifying assumptions – certain effects linear, error variance constant, etc. – assumptions passed forward emmeans() results. separate analyses subsets usually comprises departing overall model, course results different.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"transformations","dir":"Articles","previous_headings":"","what":"My lsmeans/EMMs are way off from what I expected","title":"FAQs for emmeans","text":"First step: Carefully read annotations output. say something like “results log scale, response scale”? , explains . Poisson logistic model involves link function, default, emmeans() produces results scale. can add type = \"response\" emmeans() call put results scale expect. always best approach. “transformations” vignette examples discussion.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"asymp","dir":"Articles","previous_headings":"","what":"Why do I get Inf for the degrees of freedom?","title":"FAQs for emmeans","text":"simply way emmeans labels asymptotic results (, estimates tested standard normal distribution – z tests – rather t distribution). Note obtaining quantiles probabilities t distribution infinite degrees freedom obtaining corresponding values standard normal. example: see infinite d.f., just means z test z confidence interval. Back Contents","code":"qt(c(.9, .95, .975), df = Inf) ## [1] 1.281552 1.644854 1.959964 qnorm(c(.9, .95, .975)) ## [1] 1.281552 1.644854 1.959964"},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"additive","dir":"Articles","previous_headings":"","what":"I get exactly the same comparisons for each “by” group","title":"FAQs for emmeans","text":"mentioned elsewhere, EMMs summarize model, data. model include interactions variables factors want EMMs, definition, effects latter exactly regardless variable settings. course comparisons . think different, saying model include interactions factors interest factors.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"anova","dir":"Articles","previous_headings":"","what":"My ANOVA F is significant, but no pairwise comparisons are","title":"FAQs for emmeans","text":"First , making binary decisions “significant” “nonsignificant.” simplistic view P values assigns unmerited magical quality value 0.05. suggested just report P values actually obtained, let readers decide significant findings context scientific findings. answer question: common misunderstanding ANOVA. F particular P value, implies contrast among means (effects) P value, applying Scheffe adjustment. contrast may much unlike pairwise comparison, especially several means compared. F statistic P value , say, 0.06, imply pairwise comparison P value 0.06 smaller. referring paragraph , just report P value pairwise comparison, don’t try relate F statistic. Another consideration default, P values pairwise comparisons adjusted using Tukey method, adjusted P values can quite bit larger unadjusted ones. (definitely advocate using adjustment “repair” problem.)","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"ratios","dir":"Articles","previous_headings":"","what":"I wanted differences, but instead I got ratios (or odds ratios)","title":"FAQs for emmeans","text":"transformation link involves logs, , unlike transformations, comparisons can back-transformed ratios – default behavior. really want differences ratios, can re-grid means first. Re-gridding starts anew everything response scale, memory transformation. PS – side effect causes tests done using SEs obtained delta method re-gridded scale, rather link scale. Re-gridding can used transformation, just logs, side effect.","code":"EMM <- emmeans(...) pairs(regrid(EMM))   # or contrast(regrid(EMM), ...)"},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"notukey","dir":"Articles","previous_headings":"","what":"I asked for Tukey adjustments, but that’s not what I got","title":"FAQs for emmeans","text":"two reasons happen: one comparison group (see next topic). Tukey adjustment inappropriate. Tukey adjustment appropriate pairwise comparisons means. set contrasts, Tukey method deemed unsuitable Sidak method used instead. suggestion use \"mvt\" adjustment (exact); don’t default can require lot computing time large set contrasts comparisons.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"noadjust","dir":"Articles","previous_headings":"","what":"emmeans() completely ignores my P-value adjustments","title":"FAQs for emmeans","text":"happens two means (two group). Thus one comparison. one thing test, multiplicity issue, hence multiplicity adjustment P values. wish apply P-value adjustment tests across groups, need null-variable summarize, following: Note put = NULL inside call pairs(), causes treat,group combinations compared. Back Contents","code":"EMM <- emmeans(model, ~ treat | group)   # where treat has 2 levels pairs(EMM, adjust = \"sidak\")   # adjustment is ignored - only 1 test per group summary(pairs(EMM), by = NULL, adjust = \"sidak\")   # all are in one group now"},{"path":"https://rvlenth.github.io/emmeans/articles/FAQs.html","id":"nowelch","dir":"Articles","previous_headings":"","what":"emmeans() gives me pooled t tests, but I expected Welch’s t","title":"FAQs for emmeans","text":"important note emmeans() relatives produce results based model object provide – data. sample SDs wildly different, model fitted using lm() aov() good model, R functions use statistical model presumes errors constant variance. , problem isn’t emmeans(), ’s handing inadequate model object. simple illustrative example. Consider simple one-way experiment following model: code estimate means comparisons among treatments. standard errors, confidence intervals, t statistics based pooled residual SD N - k degrees freedom (assuming N observations k treatments). results useful underlying assumptions mod1 correct – including assumption error SD treatments. Alternatively, fit following model using generalized least-squares: model specifies error variance depends levels treat. much better model use wildly different sample SDs. results emmeans() call reflect improvement modeling. standard errors EMMs depend individual sample variances, t tests comparisons essence Welch t statistics Satterthwaite degrees freedom. obtain appropriate post hoc estimates, contrasts, comparisons, one must first find model successfully explains peculiarities data. point emphasized enough. give emmeans() good model, obtain correct results; give bad model, obtain incorrect results. Get model right first. Back Contents Index vignette topics","code":"mod1 <- aov(response ~ treat, data = mydata) emmeans(mod1, pairwise ~ treat) mod2 = nlme::gls(response ~ treat, data = mydata,                  weights = varIdent(form = ~1 | treat)) emmeans(mod2, pairwise ~ treat)"},{"path":"https://rvlenth.github.io/emmeans/articles/interactions.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"Interaction analysis in emmeans","text":"Simple contrasts Interaction contrasts Multivariate contrasts Interactions covariates Summary Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/interactions.html","id":"factors","dir":"Articles","previous_headings":"","what":"Interacting factors","title":"Interaction analysis in emmeans","text":"example topic, consider auto.noise dataset included package. balanced 3x2x2 experiment three replications. response – noise level – evaluated different sizes cars, types anti-pollution filters, side car measured.1 Let’s fit model obtain ANOVA table (scale data, believe response recorded tenths decibels; compensate scaling response): statistically strong 2- 3-way interactions. One mistake lot people seem make proceed hastily estimating marginal means (even face interactions!). go straight analyses like : analyst---hurry thus conclude noise level higher medium-sized cars small large ones. seen message output, emmeans() valiantly tries warn may good idea average factors interact factor interest. isn’t always bad idea , sometimes definitely . time? think good first step always try visualize nature interactions statistical comparisons. following plot helps.  Examining plot, see “medium” mean always higher; marginal means, way compare, represent always case. Moreover, evident plot peak medium-size cars occurs one two filter types. seems useful comparisons size separately filter type. easily done, simply conditioning type: surprisingly, statistical comparisons different standard filters, Octel filters, isn’t much difference small medium size. comparing levels factors, similar judgments must made. may help construct interaction plots factors different roles. opinion, almost meaningful statistical analysis grounded evaluating practical impact estimated effects first, seeing statistical evidence backs . put attention many asterisks (call people “* gazers”) ignoring fact don’t measure sizes effects practical scale.2 effect can practically negligible still small P value – practically important large P value – depending sample size error variance. Failure describe actually going data failure adequate analysis. Use lots plots, think results. , see discussion P values “basics” vignette.","code":"noise.lm <- lm(noise/10 ~ size * type * side, data = auto.noise) anova(noise.lm) ## Analysis of Variance Table ##  ## Response: noise/10 ##                Df  Sum Sq Mean Sq  F value    Pr(>F) ## size            2 260.514 130.257 893.1905 < 2.2e-16 ## type            1  10.563  10.563  72.4286 1.038e-08 ## side            1   0.007   0.007   0.0476 0.8291042 ## size:type       2   8.042   4.021  27.5714 6.048e-07 ## size:side       2  12.931   6.465  44.3333 8.730e-09 ## type:side       1   0.174   0.174   1.1905 0.2860667 ## size:type:side  2   3.014   1.507  10.3333 0.0005791 ## Residuals      24   3.500   0.146 emmeans(noise.lm, pairwise ~ size) ## NOTE: Results may be misleading due to involvement in interactions ## $emmeans ##  size emmean     SE df lower.CL upper.CL ##  S     82.42 0.1102 24    82.19    82.64 ##  M     83.38 0.1102 24    83.15    83.60 ##  L     77.25 0.1102 24    77.02    77.48 ##  ## Results are averaged over the levels of: type, side  ## Confidence level used: 0.95  ##  ## $contrasts ##  contrast estimate    SE df t.ratio p.value ##  S - M      -0.958 0.156 24  -6.147  <.0001 ##  S - L       5.167 0.156 24  33.140  <.0001 ##  M - L       6.125 0.156 24  39.287  <.0001 ##  ## Results are averaged over the levels of: type, side  ## P value adjustment: tukey method for comparing a family of 3 estimates emmip(noise.lm, type ~ size | side) emm_s.t <- emmeans(noise.lm, pairwise ~ size | type) ## NOTE: Results may be misleading due to involvement in interactions emm_s.t ## $emmeans ## type = Std: ##  size emmean     SE df lower.CL upper.CL ##  S     82.58 0.1559 24    82.26    82.91 ##  M     84.58 0.1559 24    84.26    84.91 ##  L     77.50 0.1559 24    77.18    77.82 ##  ## type = Octel: ##  size emmean     SE df lower.CL upper.CL ##  S     82.25 0.1559 24    81.93    82.57 ##  M     82.17 0.1559 24    81.84    82.49 ##  L     77.00 0.1559 24    76.68    77.32 ##  ## Results are averaged over the levels of: side  ## Confidence level used: 0.95  ##  ## $contrasts ## type = Std: ##  contrast estimate   SE df t.ratio p.value ##  S - M     -2.0000 0.22 24  -9.071  <.0001 ##  S - L      5.0833 0.22 24  23.056  <.0001 ##  M - L      7.0833 0.22 24  32.127  <.0001 ##  ## type = Octel: ##  contrast estimate   SE df t.ratio p.value ##  S - M      0.0833 0.22 24   0.378  0.9245 ##  S - L      5.2500 0.22 24  23.812  <.0001 ##  M - L      5.1667 0.22 24  23.434  <.0001 ##  ## Results are averaged over the levels of: side  ## P value adjustment: tukey method for comparing a family of 3 estimates"},{"path":"https://rvlenth.github.io/emmeans/articles/interactions.html","id":"simple","dir":"Articles","previous_headings":"Interacting factors","what":"Simple contrasts","title":"Interaction analysis in emmeans","text":"alternative way specify conditional contrasts comparisons use simple argument contrast() pairs(), amounts specifying factors used variables. example, consider: pairs(noise.emm, simple = \"size\") pairs(noise.emm, = c(\"side\", \"type\")). One may specify list simple, case separate runs made element list. Thus, pairs(noise.emm, simple = list(\"size\", c(\"side\", \"type\")) returns two sets contrasts: comparisons size combination two factors; comparisons side*type combinations size. shortcut generates simple main-effect comparisons use simple = \"\". example, result obtained using simple = list(\"size\", \"side\", \"type\"). Ordinarily, simple list (equal \"\"), list contrast sets returned. However, additional argument combine set TRUE, combined one family: dots (.) result correspond simple effect displayed. re-run call combine = FALSE omitted, twenty comparisons displayed three broad sets contrasts, broken combinations variables, separately multiplicity-adjusted (total 16 different tables). Back Contents","code":"noise.emm <- emmeans(noise.lm, ~ size * side * type) contrast(noise.emm, \"consec\", simple = \"each\", combine = TRUE, adjust = \"mvt\") ##  side type  size contrast    estimate    SE df t.ratio p.value ##  L    Std   .    M - S          1.500 0.312 24   4.811  0.0011 ##  L    Std   .    L - M         -8.667 0.312 24 -27.795  <.0001 ##  R    Std   .    M - S          2.500 0.312 24   8.018  <.0001 ##  R    Std   .    L - M         -5.500 0.312 24 -17.639  <.0001 ##  L    Octel .    M - S         -0.333 0.312 24  -1.069  0.9769 ##  L    Octel .    L - M         -5.667 0.312 24 -18.174  <.0001 ##  R    Octel .    M - S          0.167 0.312 24   0.535  0.9999 ##  R    Octel .    L - M         -4.667 0.312 24 -14.967  <.0001 ##  .    Std   S    R - L         -1.833 0.312 24  -5.880  0.0001 ##  .    Std   M    R - L         -0.833 0.312 24  -2.673  0.1710 ##  .    Std   L    R - L          2.333 0.312 24   7.483  <.0001 ##  .    Octel S    R - L         -0.500 0.312 24  -1.604  0.7740 ##  .    Octel M    R - L          0.000 0.312 24   0.000  1.0000 ##  .    Octel L    R - L          1.000 0.312 24   3.207  0.0566 ##  L    .     S    Octel - Std   -1.000 0.312 24  -3.207  0.0562 ##  L    .     M    Octel - Std   -2.833 0.312 24  -9.087  <.0001 ##  L    .     L    Octel - Std    0.167 0.312 24   0.535  0.9999 ##  R    .     S    Octel - Std    0.333 0.312 24   1.069  0.9769 ##  R    .     M    Octel - Std   -2.000 0.312 24  -6.414  <.0001 ##  R    .     L    Octel - Std   -1.167 0.312 24  -3.742  0.0162 ##  ## P value adjustment: mvt method for 20 tests"},{"path":"https://rvlenth.github.io/emmeans/articles/interactions.html","id":"contrasts","dir":"Articles","previous_headings":"","what":"Interaction contrasts","title":"Interaction analysis in emmeans","text":"interaction contrast contrast contrasts. instance, auto-noise example, may want obtain linear quadratic contrasts size separately type, compare . estimates contrasts: comparison contrasts may done using interaction argument contrast() follows: (Using = NULL restores type primary factor contrasts.) practical meaning isn’t statistical difference linear trends, quadratic trend Octel greater standard filter types. (quadratic trends negative, fact standard filters pronounced downward curvature, seen plot.) case need understand clearly contrasts estimated, coef() method helps: Note 4th 6th contrast coefficients negatives 1st 3rd – thus comparison two contrasts. way, “type III” tests interaction effects can obtained via interaction contrasts: result exactly F test size:type anova output. three-way interaction may explored via interaction contrasts : One interpretation comparison type linear contrasts size different left side right side; comparison comparison quadratic contrasts, much. Refer plot, can discerned comparison interaction left panel versus interaction right panel. Finally, emmeans provides joint_tests() function obtains tests interaction contrasts effects model compiles one Type-III-ANOVA-like table: may even add variable(s) obtain separate ANOVA tables remaining factors: Back Contents","code":"contrast(emm_s.t[[1]], \"poly\")   ## 'by = \"type\"' already in previous result ## type = Std: ##  contrast  estimate    SE df t.ratio p.value ##  linear       -5.08 0.220 24 -23.056  <.0001 ##  quadratic    -9.08 0.382 24 -23.786  <.0001 ##  ## type = Octel: ##  contrast  estimate    SE df t.ratio p.value ##  linear       -5.25 0.220 24 -23.812  <.0001 ##  quadratic    -5.08 0.382 24 -13.311  <.0001 ##  ## Results are averaged over the levels of: side IC_st <- contrast(emm_s.t[[1]], interaction = c(\"poly\", \"consec\"), by = NULL) IC_st ##  size_poly type_consec estimate    SE df t.ratio p.value ##  linear    Octel - Std   -0.167 0.312 24  -0.535  0.5979 ##  quadratic Octel - Std    4.000 0.540 24   7.407  <.0001 ##  ## Results are averaged over the levels of: side coef(IC_st) ##   size  type c.1 c.2 ## 1    S   Std   1  -1 ## 2    M   Std   0   2 ## 3    L   Std  -1  -1 ## 4    S Octel  -1   1 ## 5    M Octel   0  -2 ## 6    L Octel   1   1 test(IC_st, joint = TRUE) ##  df1 df2 F.ratio p.value ##    2  24  27.571  <.0001 emmeans(noise.lm, ~ size*type*side) |>     contrast(interaction = c(\"poly\", \"consec\", \"consec\")) ##  size_poly type_consec side_consec estimate    SE df t.ratio p.value ##  linear    Octel - Std R - L          -2.67 0.624 24  -4.276  0.0003 ##  quadratic Octel - Std R - L          -1.67 1.080 24  -1.543  0.1359 joint_tests(noise.lm) ##  model term     df1 df2 F.ratio p.value ##  size             2  24 893.190  <.0001 ##  type             1  24  72.429  <.0001 ##  side             1  24   0.048  0.8291 ##  size:type        2  24  27.571  <.0001 ##  size:side        2  24  44.333  <.0001 ##  type:side        1  24   1.190  0.2861 ##  size:type:side   2  24  10.333  0.0006 joint_tests(noise.lm, by = \"side\") ## side = L: ##  model term df1 df2 F.ratio p.value ##  size         2  24 651.714  <.0001 ##  type         1  24  46.095  <.0001 ##  size:type    2  24  23.524  <.0001 ##  ## side = R: ##  model term df1 df2 F.ratio p.value ##  size         2  24 285.810  <.0001 ##  type         1  24  27.524  <.0001 ##  size:type    2  24  14.381  0.0001"},{"path":"https://rvlenth.github.io/emmeans/articles/interactions.html","id":"multiv","dir":"Articles","previous_headings":"","what":"Multivariate contrasts","title":"Interaction analysis in emmeans","text":"preceding sections, way addressed interacting factors comparisons contrasts factors()) separately levels factor(s). leads lot estimates associated tests. Another approach compare things multivariate way. auto-noise example, example, four means (corresponding four combinations type size) size car, consider comparing sets means. multivariate comparisons can done via Mahalanobis distance (kind standardized distance measure) one set four means another. facilitated mvcontrast() function: output, T.square values Hotelling’s \\(T^2\\) statistics, squared Mahalanobis distances among sets four means. results thus accomplish similar objective initial comparisons presented vignette, complicated issue factors interact. (Instead, lose directionality comparisons.) comparisons “significant,” T.square values indicate large cars statistically different sizes. may still break things using variables. Suppose, example, wish compare two filter types size car, without regard side: One detail note multivariate comparisons: order make complete sense, factors involved must interact. Suppose repeat initial multivariate comparison removing interactions: Note \\(F\\) ratio now 1 d.f. Also, note T.square = F.ratio, can verify values equal squares t.ratios initial example vignette (\\((-6.147)^2 = 37.786\\), etc.). , ignore interactions, multivariate tests exactly equivalent univariate tests marginal means. Back Contents","code":"mvcontrast(noise.emm, \"pairwise\", mult.name = c(\"type\", \"side\")) ##  contrast T.square df1 df2 F.ratio p.value ##  S - M      88.857   4  21  19.438  <.0001 ##  S - L    1199.429   4  21 262.375  <.0001 ##  M - L    1638.000   4  21 358.312  <.0001 ##  ## P value adjustment: sidak update(mvcontrast(noise.emm, \"consec\", mult.name = \"side\", by = \"size\"),         by = NULL) ##  contrast    size T.square df1 df2 F.ratio p.value ##  Octel - Std S      11.429   2  23   5.476  0.0113 ##  Octel - Std M     123.714   2  23  59.280  <.0001 ##  Octel - Std L      14.286   2  23   6.845  0.0047 ##  ## P value adjustment: sidak mvcontrast(update(noise.emm, submodel = ~ side + size + type),             \"pairwise\", mult.name = c(\"type\", \"side\")) ##  contrast T.square df1 df2  F.ratio p.value ##  S - M      37.786   1  24   37.786  <.0001 ##  S - L    1098.286   1  24 1098.286  <.0001 ##  M - L    1543.500   1  24 1543.500  <.0001 ##  ## P value adjustment: sidak  ## NOTE: Some or all d.f. are reduced due to singularities"},{"path":"https://rvlenth.github.io/emmeans/articles/interactions.html","id":"covariates","dir":"Articles","previous_headings":"","what":"Interactions with covariates","title":"Interaction analysis in emmeans","text":"covariate factor interact, typically don’t want EMMs , rather estimates slopes covariate trend level factor. simple example, consider fiber dataset, fit model including interaction diameter (covariate) machine (factor): model comprises fitting, machine, separate linear trend strength versus diameter. Accordingly, can estimate compare slopes lines via emtrends() function: see three slopes, two test statistically different. visualize lines , may use  cov.reduce = range argument passed ref_grid(); needed default, covariate reduced one value (see “basics” vignette). Instead, call range() function obtain minimum maximum diameter.","code":"fiber.lm <- lm(strength ~ diameter*machine, data = fiber) emtrends(fiber.lm, pairwise ~ machine, var = \"diameter\") ## $emtrends ##  machine diameter.trend    SE df lower.CL upper.CL ##  A                1.104 0.194  9    0.666     1.54 ##  B                0.857 0.224  9    0.351     1.36 ##  C                0.864 0.208  9    0.394     1.33 ##  ## Confidence level used: 0.95  ##  ## $contrasts ##  contrast estimate    SE df t.ratio p.value ##  A - B     0.24714 0.296  9   0.835  0.6919 ##  A - C     0.24008 0.284  9   0.845  0.6863 ##  B - C    -0.00705 0.306  9  -0.023  0.9997 ##  ## P value adjustment: tukey method for comparing a family of 3 estimates emmip(fiber.lm, machine ~ diameter, cov.reduce = range)"},{"path":"https://rvlenth.github.io/emmeans/articles/interactions.html","id":null,"dir":"Articles","previous_headings":"","what":"Interaction analysis in emmeans","title":"Interaction analysis in emmeans","text":"sophisticated example, consider oranges dataset included package. data concern sales two varieties oranges. prices (price1 price2) experimentally varied different stores different days, responses sales1 sales2 observed. Let’s consider three multivariate models data, additive effects days stores, different levels fitting prices: multivariate model, emmeans methods distinguish responses levels factor, name “variety”. Moreover, separate effects estimated multivariate response, implied interaction variety predictors involving price1 price2. (org.int, implied three-way interaction.) interesting way view models look predict sales variety observed values prices:  trends portrayed quite sensible: left panel, increase price variety 1, sales variety tend decrease – decrease faster variety oranges low-priced. right panel, price variety 1 increases, sales variety 2 increase low-priced, decrease also high prices oranges general just expensive. plot like org.int similar curves straight lines; one plot.add lines parallel. models, though, implied price1:variety price2:variety interactions, different regression coefficients two responses. model use? nested models, can compared anova(): seems like full-quadratic model little advantage interaction model. truly nothing magical P value 0.05, enough data -fitting hazard; like org.int. However, follows done models. summarize test results compactly, makes sense obtain estimates representative trend left right panels, perhaps compare . turn, can done obtaining slope curve (line) average value price2. emtrends() function designed exactly kind purpose. uses difference quotient estimate slope line fitted given variable. works just like emmeans() except requiring variable use difference quotient. Using org.int model: , can say , starting price1 price2 average values, expect sales1 decrease .75 per unit increase price1; meanwhile, suggestion slight increase sales2, without much statistical evidence. Marginally, first variety 0.89 disadvantage relative sales second variety. analyses (shown) price2 set higher value reduce effects, setting price2 lower exaggerate effects. analysis done quadratic model, trends curved, results depend somewhat setting price1. graph gives indication nature changes. Similar results hold analyze trends price2: averages, increasing price variety 2 effect decreasing sales variety 2 slightly increasing sales variety 1 – marginal difference .92. Back Contents","code":"org.quad <- lm(cbind(sales1, sales2) ~ poly(price1, price2, degree = 2)                                        + day + store, data = oranges) org.int <- lm(cbind(sales1, sales2) ~ price1 * price2 + day + store, data = oranges) org.add <- lm(cbind(sales1, sales2) ~ price1 + price2 + day + store, data = oranges) emmip(org.quad, price2 ~ price1 | variety, mult.name = \"variety\", cov.reduce = FALSE) ## Warning: The shape palette can deal with a maximum of 6 discrete values because more ## than 6 becomes difficult to discriminate ## ℹ you have requested 9 values. Consider specifying shapes manually if you need ##   that many have them. anova(org.quad, org.int, org.add) ## Analysis of Variance Table ##  ## Model 1: cbind(sales1, sales2) ~ poly(price1, price2, degree = 2) + day +  ##     store ## Model 2: cbind(sales1, sales2) ~ price1 * price2 + day + store ## Model 3: cbind(sales1, sales2) ~ price1 + price2 + day + store ##   Res.Df Df Gen.var.   Pillai approx F num Df den Df Pr(>F) ## 1     20      22.798                                        ## 2     22  2   21.543 0.074438  0.38658      4     40 0.8169 ## 3     23  1   23.133 0.218004  2.64840      2     19 0.0967 emtrends(org.int, pairwise ~ variety, var = \"price1\", mult.name = \"variety\") ## $emtrends ##  variety price1.trend    SE df lower.CL upper.CL ##  sales1        -0.749 0.171 22   -1.104   -0.394 ##  sales2         0.138 0.214 22   -0.306    0.582 ##  ## Results are averaged over the levels of: day, store  ## Confidence level used: 0.95  ##  ## $contrasts ##  contrast        estimate   SE df t.ratio p.value ##  sales1 - sales2   -0.887 0.24 22  -3.690  0.0013 ##  ## Results are averaged over the levels of: day, store emtrends(org.int, pairwise ~ variety, var = \"price2\", mult.name = \"variety\") ## $emtrends ##  variety price2.trend    SE df lower.CL upper.CL ##  sales1         0.172 0.102 22  -0.0404    0.384 ##  sales2        -0.745 0.128 22  -1.0099   -0.480 ##  ## Results are averaged over the levels of: day, store  ## Confidence level used: 0.95  ##  ## $contrasts ##  contrast        estimate    SE df t.ratio p.value ##  sales1 - sales2    0.917 0.143 22   6.387  <.0001 ##  ## Results are averaged over the levels of: day, store"},{"path":"https://rvlenth.github.io/emmeans/articles/interactions.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Interaction analysis in emmeans","text":"Interactions, nature, make things complicated. One must resist pressures inclinations try produce simple bottom-line conclusions. Interactions require work patience; require presenting cases – presented examples vignette – order provide complete picture. Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"Working with messy data","text":"Issues observational data Mediating covariates Mediating factors weights Nuisance factors Counterfactuals G-Computation Sub-models Avoiding mis-identified nesting Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"issues","dir":"Articles","previous_headings":"","what":"Issues with observational data","title":"Working with messy data","text":"experiments, control conditions observations made. Ideally, leads balanced datasets clear inferences effects experimental conditions. observational data, factor levels observed rather controlled, analysis control factors covariates. possible factors covariates lie causal path predictors. Observational studies can designed ways mitigate issues; often left mess. Using EMMs solve inherent problems messy, undesigned studies; give us ways compensate imbalance data, allow us estimate meaningful effects carefully considering ways can confounded.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":null,"dir":"Articles","previous_headings":"","what":"Working with messy data","title":"Working with messy data","text":"illustration, consider nutrition dataset provided package. data used example Milliken Johnson (1992), Analysis Messy Data, contain results observational study nutrition education. Low-income mothers classified race, age category, whether received food stamps (group factor); response variable gain score (post minus pre scores) completing nutrition training program. First, let’s fit model includes main effects 2-way interactions, obtain “type II” ANOVA: definitely group effect hint interaction race. EMMs two factors, along counts:","code":"nutr.lm <- lm(gain ~ (age + group + race)^2, data = nutrition)  car::Anova(nutr.lm) ## Note: model has aliased coefficients ##       sums of squares computed by model comparison ## Anova Table (Type II tests) ##  ## Response: gain ##             Sum Sq Df F value    Pr(>F) ## age          82.37  3  0.9614    0.4145 ## group       658.13  1 23.0441 6.105e-06 ## race         11.17  2  0.1956    0.8227 ## age:group    91.58  3  1.0688    0.3663 ## age:race     87.30  3  1.0189    0.3880 ## group:race  113.70  2  1.9906    0.1424 ## Residuals  2627.47 92 emmeans(nutr.lm, ~ group * race, calc = c(n = \".wgt.\")) ##  group      race     emmean   SE df  n lower.CL upper.CL ##  FoodStamps Black      4.71 2.37 92  7  0.00497     9.41 ##  NoAid      Black     -2.19 2.49 92 14 -7.13690     2.76 ##  FoodStamps Hispanic nonEst   NA NA  1       NA       NA ##  NoAid      Hispanic nonEst   NA NA  2       NA       NA ##  FoodStamps White      3.61 1.16 92 52  1.31252     5.90 ##  NoAid      White      2.26 2.39 92 31 -2.48897     7.00 ##  ## Results are averaged over the levels of: age  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":null,"dir":"Articles","previous_headings":"","what":"Working with messy data","title":"Working with messy data","text":"Hmmmm. EMMs race “Hispanic” given; instead flagged non-estimable. mean? Well, using model make predictions, impossible beyond linear space data used fit model. data three age groups Hispanic population: can’t make predictions cases averaging EMMs, non-estimable. bottom line simply include Hispanics mix comparing factor effects. ’s limitation study overcome without collecting additional data. choices analysis focus Black White populations; focus age group 3. example (latter): (used trickery providing variable, taking away, make output compact.) Evidently, training program beneficial Black White groups age category. conclusion Hispanic group – little data. Back Contents","code":"with(nutrition, table(race, age)) ##           age ## race        1  2  3  4 ##   Black     2  7 10  2 ##   Hispanic  0  0  3  0 ##   White     5 16 51 11 emmeans(nutr.lm, pairwise ~ group | race, at = list(age = \"3\")) |>     summary(by = NULL) ## Note: adjust = \"tukey\" was changed to \"sidak\" ## because \"tukey\" is only appropriate for one set of pairwise comparisons ## $emmeans ##  group      race     emmean   SE df lower.CL upper.CL ##  FoodStamps Black      7.50 2.67 92     2.19   12.807 ##  NoAid      Black     -3.67 2.18 92    -8.00    0.666 ##  FoodStamps Hispanic   0.00 5.34 92   -10.61   10.614 ##  NoAid      Hispanic   2.50 3.78 92    -5.01   10.005 ##  FoodStamps White      5.42 0.96 92     3.51    7.326 ##  NoAid      White     -0.20 1.19 92    -2.57    2.173 ##  ## Confidence level used: 0.95  ##  ## $contrasts ##  contrast           race     estimate   SE df t.ratio p.value ##  FoodStamps - NoAid Black       11.17 3.45 92   3.237  0.0050 ##  FoodStamps - NoAid Hispanic    -2.50 6.55 92  -0.382  0.9739 ##  FoodStamps - NoAid White        5.62 1.53 92   3.666  0.0012 ##  ## P value adjustment: sidak method for 3 tests"},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"mediators","dir":"Articles","previous_headings":"","what":"Mediating covariates","title":"Working with messy data","text":"framing data mediation package results experiment conducted Brader et al. (2008) subjects given opportunity send message Congress regarding immigration. However, offered , subjects (treat = 1) first shown news story portrays Latinos negative way. Besides binary response (whether elected send message), experimenters also measured emo, subjects’ emotional state treatment applied. various demographic variables well. Let’s logistic regression model, changing labels educ shorter strings. conventional way handle covariates like emo set means use means purposes predictions EMMs. adjusted means shown following plot.  plot gives impression effect treat reversed male female subjects; also effect education monotone. counter-intuitive.","code":"framing <- mediation::framing  levels(framing$educ) <- c(\"NA\",\"Ref\",\"< HS\", \"HS\", \"> HS\",\"Coll +\")  framing.glm <- glm(cong_mesg ~ age + income + educ + emo + gender * factor(treat),      family = binomial, data = framing) emmip(framing.glm, treat ~ educ | gender, type = \"response\")"},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"med-covred","dir":"Articles","previous_headings":"","what":"Working with messy data","title":"Working with messy data","text":"However, note covariate emo measured post-treatment. suggests fact treat (perhaps factors) affect value emo; true (fact established mediation analysis techniques), pretend emo can set independently treat done obtain EMMs shown . Instead, let emo depend treat predictors – easily done using cov.reduce – obtain entirely different impression:  reference grid underlying plot different emo values factor combination. plot suggests , taking emotional response account, male (female) subjects exposed negative news story likely send message females seeing negative news story. Also, effect educ now nearly monotone.","code":"emmip(framing.glm, treat ~ educ | gender, type = \"response\",      cov.reduce = emo ~ treat*gender + age + educ + income)"},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"adjcov","dir":"Articles","previous_headings":"","what":"Working with messy data","title":"Working with messy data","text":"way, results plot obtain refitting model adjusted covariate … using ordinary covariate-adjusted means means emo.adj. technique often recommended. one mediating covariate, settings may defined sequence; example, x1, x2, x3 mediating covariates, might use (possibly interactions included well). Back Contents","code":"emo.adj <- resid(lm(emo ~ treat*gender + age + educ + income, data = framing)) emmeans(..., cov.reduce = list(x1 ~ trt, x2 ~ trt + x1, x3 ~ trt + x1 + x2))"},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"weights","dir":"Articles","previous_headings":"","what":"Mediating factors and weights","title":"Working with messy data","text":"mediating covariate one causal path; likewise, possible mediating factor. mediating factors, moral equivalent cov.reduce technique described use weighted averages lieu equally-weighted ones computing EMMs. weights used averages depend frequencies mediating factor(s). Usually, \"cells\" weighting scheme described later section right approach. complex situations, may necessary compute EMMs stages. described “basics” vignette, EMMs usually defined equally-weighted means reference-grid predictions. However, several built-alternative weighting schemes available specifying character value weights call emmeans() related function. options \"equal\" (default), \"proportional\", \"outer\", \"cells\", \"flat\". \"proportional\" (\"prop\" short) method weights proportionally frequencies (model weights) factor combination averaged . \"outer\" method uses outer product marginal frequencies factor averaged . explain distinction, suppose EMMs involve averaging two factors B C. \"prop\", use frequencies combination B C; whereas \"outer\", first obtain marginal frequencies B C weight proportionally product combination B C. latter weights like “expected” counts used chi-square test independence. Put another way, outer weighting proportional weighting applied one factor time; following two yield results: Using \"cells\" weights gives prediction weight occurs model; applied reference grid model interactions, \"cells\"-weighted EMMs ordinary marginal means data. \"flat\" weights, equal weights used, except zero weight applied factor combination data. Usually, \"cells\" \"flat\" weighting produce non-estimable results, exclude empty cells. (said, covariates linearly dependent factors, may still encounter non-estimable cases.) comparison predictions nutr.lm defined , using different weighting schemes: hand, group * race EMMs, one factor (age) averaged ; thus, results \"prop\" \"outer\" weights identical case. Back Contents","code":"emmeans(model, \"A\", weights = \"outer\")  emmeans(model, c(\"A\", \"B\"), weights = \"prop\") |>  emmeans(weights = \"prop\") sapply(c(\"equal\", \"prop\", \"outer\", \"cells\", \"flat\"), \\(w)     emmeans(nutr.lm, ~ race, weights = w) |> predict()) ##         equal     prop    outer     cells      flat ## [1,] 1.258929 1.926554 2.546674 0.3809524 0.6865079 ## [2,]       NA       NA       NA 1.6666667 1.2500000 ## [3,] 2.932008 2.522821 3.142940 2.7951807 1.6103407"},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"nuisance","dir":"Articles","previous_headings":"","what":"Nuisance factors","title":"Working with messy data","text":"Consider situation model 15 factors, 5 levels. Regardless simple complex model , reference grid consists combinations factors – \\(5^{15}\\) , 30 billion. , say, 100 regression coefficients model, just linfct slot reference grid requires \\(100\\times5^{15}\\times8\\) bytes storage, almost 23,000 gigabytes. Suppose addition model multivariate response 5 levels. multiplies rows columns linfct, increasing storage requirements factor 25. Either way, computer can’t store much – definitely qualifies messy situation! ref_grid() function now provides relief, way specifying factors “nuisance” factors. reference grid constructed factors already averaged-. , example scenario, three 15 factors primary interest, specify 12 nuisance factors averaged, leaves us \\(3^5=125\\) rows reference grid, hence \\(125\\times100\\times8=10,000\\) bytes storage required linfct. 5-level multivariate response, ’ll 625 rows reference grid \\(25\\times1000=250,000\\) bytes linfct. Suddenly horribly unmanageable situation becomes quite manageable! course, restriction: nuisance factors must interact factors – even nuisance factors. multivariate response (implied multivariate response, e.g., ordinal model) can never nuisance factor. condition, average effects nuisance factor regardless levels factors, making possible pre-average considering just one case. specify nuisance factors listing names nuisance argument ref_grid() (emmeans(), argument passed ref_grid)). Often, much convenient give factors nuisance factors, via non.nuisance argument. specify nuisance factor interact others, doesn’t exist, quietly excluded nuisance list.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"nuis-example","dir":"Articles","previous_headings":"","what":"Working with messy data","title":"Working with messy data","text":"Time example. Consider mtcars dataset standard R, model let’s construct two different reference grids: Notice left non.nuisance hence included nuisance. However, interacts cyl, allowed nuisance factor. rg.nuis requires 1/36 much storage. ’s really nothing else show, demonstrate get EMMs either way, slightly different annotations: default, pre-averaging done equal weights. specify wt.nuis anything \"equal\", averaged proportionally. described , really amounts \"outer\" weights since averaged separately. Let’s try see estimates differ: , different equally-weighted EMMs obtained . way, help make things consistent, weights character, emmeans() passes wt.nuis = weights ref_grid (called), unless wt.nuis also specified. trick get emmeans use smallest possible reference grid: Pass specs argument ref_grid() non.nuisance. quote delay evaluation, also use .vars() () specs formula: Observe cyl passed nuisance factor interacts another factor.","code":"mtcars.lm <- lm(mpg ~ factor(cyl)*am + disp + hp + drat + log(wt) + vs +                    factor(gear) + factor(carb), data = mtcars) rg.usual <- ref_grid(mtcars.lm) rg.usual ## 'emmGrid' object with variables: ##     cyl = 4, 6, 8 ##     am = 0, 1 ##     disp = 230.72 ##     hp = 146.69 ##     drat = 3.5966 ##     wt = 3.2172 ##     vs = 0, 1 ##     gear = 3, 4, 5 ##     carb = 1, 2, 3, 4, 6, 8 nrow(rg.usual@linfct) ## [1] 216 rg.nuis = ref_grid(mtcars.lm, non.nuisance = \"cyl\") ## NOTE: A nesting structure was detected in the fitted model: ##     cyl %in% am rg.nuis ## 'emmGrid' object with variables: ##     cyl = 4, 6, 8 ##     am = 0, 1 ##     disp = (predicted by other variables) ##     hp = (predicted by other variables) ##     drat = (predicted by other variables) ##     wt = (predicted by other variables) ##     vs = (predicted by other variables) ##     gear = (predicted by other variables) ##     carb = (predicted by other variables) ## Nuisance factors that have been collapsed by averaging: ##     disp(1), hp(1), drat(1), wt(1), vs(2), gear(3), carb(6) ## Nesting structure:  cyl %in% am nrow(rg.nuis@linfct) ## [1] 6 emmeans(rg.usual, ~ cyl * am) ##  cyl am emmean   SE df lower.CL upper.CL ##    4  0   19.0 4.29 14    9.823     28.2 ##    6  0   19.7 3.32 14   12.556     26.8 ##    8  0   29.0 5.98 14   16.130     41.8 ##    4  1   15.4 4.29 14    6.206     24.6 ##    6  1   27.3 4.90 14   16.741     37.8 ##    8  1   11.2 5.56 14   -0.718     23.1 ##  ## Results are averaged over the levels of: vs, gear, carb  ## Confidence level used: 0.95 emmeans(rg.nuis, ~ cyl * am) ##  cyl am emmean   SE df lower.CL upper.CL ##    4  0   19.0 4.29 14     9.82     28.2 ##    6  0   19.7 3.32 14    12.56     26.8 ##  ## Results are averaged over the levels of: 7 nuisance factors  ## Confidence level used: 0.95 predict(emmeans(mtcars.lm, ~ cyl * am, non.nuis = c(\"cyl\", \"am\"),                  wt.nuis = \"prop\")) ## NOTE: A nesting structure was detected in the fitted model: ##     cyl %in% am ## [1] 16.51254 17.17869 predict(emmeans(mtcars.lm, ~ cyl * am, weights = \"outer\")) ## [1] 16.51254 17.17869 26.45709 12.90600 24.75053  8.70546 emmeans(mtcars.lm, ~ gear | am, non.nuis = quote(all.vars(specs))) ## NOTE: A nesting structure was detected in the fitted model: ##     am %in% gear ## gear = 3, am = 0: ##  emmean   SE df lower.CL upper.CL ##    15.2 2.65 14     9.56     20.9 ##  ## gear = 4, am = 1: ##  emmean   SE df lower.CL upper.CL ##    17.8 2.62 14    12.19     23.4 ##  ## Results are averaged over the levels of: 6 nuisance factors, cyl  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"rg-limit","dir":"Articles","previous_headings":"Nuisance factors","what":"Limiting the size of the reference grid","title":"Working with messy data","text":"just seen easily size reference grid can get hand. rg.limit option (set via emm_options() optional argument ref_grid() emmeans()) serves guard excessive memory demands. specifies number allowed rows reference grid. way ref_grid() works, check made multivariate-response levels taken account. limit exceeded, error thrown: default rg.limit 10,000. limit, 1,000 columns model matrix, size linfct limited 80MB. addition, 5-level multivariate response, limit 2GB – darn big, perhaps manageable. Even , suspect 10000-row default may loose guard users getting tight situation. Back Contents","code":"ref_grid(mtcars.lm, rg.limit = 200) ## Error: The rows of your requested reference grid would be 216, which exceeds ## the limit of 200 (not including any multivariate responses). ## Your options are: ##   1. Specify some (or more) nuisance factors using the 'nuisance' argument ##      (see ?ref_grid). These must be factors that do not interact with others. ##   2. Add the argument 'rg.limit = <new limit>' to the call. Be careful, ##      because this could cause excessive memory use and performance issues. ##      Or, change the default via 'emm_options(rg.limit = <new limit>)'."},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"counterfact","dir":"Articles","previous_headings":"","what":"Counterfactuals and G-Computation","title":"Working with messy data","text":"G-computation method model-based causal inference originated JM Robins (Mathematical Modelling, 1986), want remove confounding treatment effects due time-varying covariates . idea , certain assumptions, can use model predict every subject’s response treatment – just treatment received. , make several copies whole dataset, substituting actual treatment(s) possible treatment levels; provide us counterfactual predictions. average predictions copy dataset. Typically, averaging done response scale; interesting case link scale, everything linear can obtain basically results using ordinary emmeans() computations proportional weights. additional consideration average counterfactual datasets, trying represent entire covariate distribution, rather conditioning cases dataset. good idea broaden covariance estimate using, say, sandwich estimate. kind computation just little bit common nuisance variables, net result can sweep several predictors reference grid just averaging away. make sense, predictors averaged-away observed treatment effects separate treatment effects. implementation emmeans via counterfactuals argument ref_grid() (usually passed emmeans()). simply specify factor(s) want keep. creates index variable .obs.. keep track observations dataset, reference grid (averaging) consists every observation dataset combination counterfactuals combinations.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"neuralgia","dir":"Articles","previous_headings":"","what":"Working with messy data","title":"Working with messy data","text":"example, consider neuralgia data, binary response, pain, treatment interest (two active treatments placebo), pre-treatment predictors sex, age, duration condition. include vcovHC() covariance estimate sandwich package. Note results already response (probability) scale, default. Let’s compare get without using counterfactuals (.e., predicting covariate average): results markedly different; counterfactual method produces smaller differences active treatments placebo. Back Contents","code":"neuralgia.glm <- glm(Pain ~ Sex + Age + Duration + Treatment,                      data = neuralgia, family = binomial) emmeans(neuralgia.glm, \"Treatment\", counterfactuals = \"Treatment\",         vcov. = sandwich::vcovHC) ##  Treatment  prob     SE  df asymp.LCL asymp.UCL ##  A         0.283 0.0792 Inf    0.1280     0.439 ##  B         0.221 0.0669 Inf    0.0894     0.352 ##  P         0.754 0.1041 Inf    0.5500     0.958 ##  ## Results are averaged over the levels of: .obs.no.  ## Confidence level used: 0.95 emmeans(neuralgia.glm, \"Treatment\", weights = \"prop\", type = \"response\") ##  Treatment  prob     SE  df asymp.LCL asymp.UCL ##  A         0.196 0.1055 Inf    0.0617     0.475 ##  B         0.126 0.0822 Inf    0.0323     0.384 ##  P         0.855 0.0852 Inf    0.6053     0.958 ##  ## Results are averaged over the levels of: Sex  ## Confidence level used: 0.95  ## Intervals are back-transformed from the logit scale"},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"submodels","dir":"Articles","previous_headings":"","what":"Sub-models","title":"Working with messy data","text":"just seen can assign different weights levels containing factors. Another option constrain effects containing factors zero. essence, means fitting different model without containing effects; however, certain models (), emmGrid may updated submodel specification impose constraint. illustration, return nutrition example, consider analysis group race , removing interactions involving age: like, may confirm obtain exactly estimates fitted sub-model data, except continue use residual variance full model tests confidence intervals. Without interactions age, marginal means become estimable. results somewhat different obtained earlier narrowed scope just age 3. new estimates include ages, averaging equally, constraints interaction effects involving age zero.","code":"emmeans(nutr.lm, pairwise ~ group | race, submodel = ~ age + group*race) |>          summary(by = NULL) ## Note: adjust = \"tukey\" was changed to \"sidak\" ## because \"tukey\" is only appropriate for one set of pairwise comparisons ## $emmeans ##  group      race     emmean    SE df lower.CL upper.CL ##  FoodStamps Black      4.91 2.061 92    0.817    9.003 ##  NoAid      Black     -3.01 1.581 92   -6.148    0.133 ##  FoodStamps Hispanic  -1.18 5.413 92  -11.935    9.567 ##  NoAid      Hispanic   1.32 3.876 92   -6.382    9.014 ##  FoodStamps White      4.10 0.901 92    2.308    5.886 ##  NoAid      White     -1.44 1.114 92   -3.654    0.771 ##  ## Results are averaged over the levels of: age  ## submodel: ~ age + group + race + group:race  ## Confidence level used: 0.95  ##  ## $contrasts ##  contrast           race     estimate   SE df t.ratio p.value ##  FoodStamps - NoAid Black        7.92 2.62 92   3.021  0.0098 ##  FoodStamps - NoAid Hispanic    -2.50 6.55 92  -0.382  0.9739 ##  FoodStamps - NoAid White        5.54 1.27 92   4.364  0.0001 ##  ## Results are averaged over the levels of: age  ## P value adjustment: sidak method for 3 tests"},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"type2submodel","dir":"Articles","previous_headings":"","what":"Working with messy data","title":"Working with messy data","text":"two special character values may used submodel. Specifying \"minimal\" creates submodel active factors: submodel constrains effects involving age zero. Another interesting option \"type2\", whereby essence analyze residuals model contained overlapping effects, constrain containing effects zero. left interaction effects factors involved. useful joint_tests(): results identical type II anova obtained beginning example. details submodel works may found vignette(\"xplanations\") Back Contents","code":"emmeans(nutr.lm, ~ group * race, submodel = \"minimal\") ##  group      race     emmean    SE df lower.CL upper.CL ##  FoodStamps Black     5.000 2.020 92    0.988    9.012 ##  NoAid      Black    -1.929 1.428 92   -4.765    0.908 ##  FoodStamps Hispanic  0.000 5.344 92  -10.614   10.614 ##  NoAid      Hispanic  2.500 3.779 92   -5.005   10.005 ##  FoodStamps White     4.769 0.741 92    3.297    6.241 ##  NoAid      White    -0.516 0.960 92   -2.422    1.390 ##  ## Results are averaged over the levels of: age  ## submodel: ~ group + race + group:race  ## Confidence level used: 0.95 joint_tests(nutr.lm, submodel = \"type2\") ##  model term df1 df2 F.ratio p.value note ##  age          3  92   0.961  0.4145      ##  group        1  92  23.044  <.0001      ##  race         2  92   0.196  0.8227      ##  age:group    3  92   1.069  0.3663      ##  age:race     3  92   1.019  0.3880  d e ##  group:race   2  92   1.991  0.1424      ##  ## d: df1 reduced due to linear dependence  ## e: df1 reduced due to non-estimability"},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"nesting","dir":"Articles","previous_headings":"","what":"Nested fixed effects","title":"Working with messy data","text":"factor nested another factor B levels different meaning one level B another. Often, nested factors random effects—example, subjects experiment may randomly assigned treatments, case subjects nested treatments—model random effects, random nested effects among fixed effects issue emmeans. sometimes fixed nested factors.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"cows","dir":"Articles","previous_headings":"","what":"Working with messy data","title":"Working with messy data","text":"example fictional study five fictional treatments disease cows. Two treatments administered injection, three administered orally. varying numbers observations drug. data model follow: ref_grid function finds nested structure model: nesting, emmeans computes averages separately group … insists carrying along grouping factors factor nested : associated pairwise comparisons: latter result, contrast becomes nested factor returned emmGrid object. case variable.","code":"cows <- data.frame (     route = factor(rep(c(\"injection\", \"oral\"), c(5, 9))),     drug = factor(rep(c(\"Bovineumab\", \"Charloisazepam\",                \"Angustatin\", \"Herefordmycin\", \"Mollycoddle\"), c(3,2,  4,2,3))),     resp = c(34, 35, 34,   44, 43,      36, 33, 36, 32,   26, 25,   25, 24, 24) ) cows.lm <- lm(resp ~ route + drug, data = cows) cows.rg <- ref_grid(cows.lm) cows.rg ## 'emmGrid' object with variables: ##     route = injection, oral ##     drug = Angustatin, Bovineumab, Charloisazepam, Herefordmycin, Mollycoddle ## Nesting structure:  drug %in% route ## Some things are non-estimable (null space dim = 1) route.emm <- emmeans(cows.rg, \"route\") route.emm ##  route     emmean    SE df lower.CL upper.CL ##  injection   38.9 0.591  9     37.6     40.3 ##  oral        28.0 0.449  9     27.0     29.0 ##  ## Results are averaged over the levels of: drug  ## Confidence level used: 0.95 drug.emm <- emmeans(cows.rg, \"drug\") drug.emm ##  drug           route     emmean    SE df lower.CL upper.CL ##  Bovineumab     injection   34.3 0.747  9     32.6     36.0 ##  Charloisazepam injection   43.5 0.915  9     41.4     45.6 ##  Angustatin     oral        34.2 0.647  9     32.8     35.7 ##  Herefordmycin  oral        25.5 0.915  9     23.4     27.6 ##  Mollycoddle    oral        24.3 0.747  9     22.6     26.0 ##  ## Confidence level used: 0.95 pairs(route.emm, reverse = TRUE) ##  contrast         estimate    SE df t.ratio p.value ##  oral - injection    -10.9 0.742  9 -14.671  <.0001 ##  ## Results are averaged over the levels of: drug pairs(drug.emm, by = \"route\", reverse = TRUE) ## route = injection: ##  contrast                    estimate    SE df t.ratio p.value ##  Charloisazepam - Bovineumab     9.17 1.182  9   7.757  <.0001 ##  ## route = oral: ##  contrast                    estimate    SE df t.ratio p.value ##  Herefordmycin - Angustatin     -8.75 1.121  9  -7.805  0.0001 ##  Mollycoddle - Angustatin       -9.92 0.989  9 -10.030  <.0001 ##  Mollycoddle - Herefordmycin    -1.17 1.182  9  -0.987  0.6026 ##  ## P value adjustment: tukey method for comparing a family of 3 estimates"},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"graphs-with-nesting","dir":"Articles","previous_headings":"Nested fixed effects","what":"Graphs with nesting","title":"Working with messy data","text":"can helpful take advantage special features ggplot2 graphing results nested factors. example, default plot cows example ideal:  can instead remove route call instead handle ggplot2 code use separate x scales:  Similarly plot.emmGrid():","code":"emmip(cows.rg, ~ drug | route) require(ggplot2) emmip(cows.rg, ~ drug) + facet_wrap(~ route, scales = \"free_x\") plot(drug.emm, PIs = TRUE) +      facet_wrap(~ route, nrow = 2, scales = \"free_y\")"},{"path":"https://rvlenth.github.io/emmeans/articles/messy-data.html","id":"nest-trap","dir":"Articles","previous_headings":"Nested fixed effects","what":"Auto-identification of nested factors – avoid being trapped!","title":"Working with messy data","text":"ref_grid() emmeans() tries discover accommodate nested structures fixed effects. two ways: first, identifying factors whose levels appear combination one level another factor; second, examining terms attribute fixed effects. latter approach, interaction :B appears model present main effect, deemed nested B. Note can create trap: users take shortcuts omitting fixed effects, knowing won’t affect fitted values. shortcuts affect interpretation model parameters, ANOVA tables, etc., advise ever taking shortcuts. ways may notice mistakenly-identified nesting: message displayed nesting detected str() listing emmGrid object shows nesting component emmeans() summary unexpectedly includes one factors didn’t specify EMMs obtained using factors don’t seem behave right, give results different specifications override auto-detection nested effects, use nesting argument ref_grid() emmeans(). Specifying nesting = NULL ignore nesting. Incorrectly-discovered nesting can overcome specifying something akin nesting = \"%% B, C %% (* B)\" , equivalently, nesting = list(= \"B\",  C = c(\"\", \"B\")). Back Contents Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"quickref","dir":"Articles","previous_headings":"","what":"Quick reference for supported objects and options","title":"Models supported by emmeans","text":"alphabetical list model classes supported, arguments apply. Detailed documentation follows, objects grouped code “Group” column. Scroll follow links groups information.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"A","dir":"Articles","previous_headings":"","what":"Group A – “Standard” or minimally supported models","title":"Models supported by emmeans","text":"Models group, lm, unusual features need special support; hence extra arguments needed. may require data call.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"B","dir":"Articles","previous_headings":"","what":"B – Beta regression","title":"Models supported by emmeans","text":"additional mode argument betareg objects possible values \"response\", \"link\", \"precision\", \"phi.link\", \"variance\", \"quantile\", meaning type argument predict.betareg – addition \"phi.link\" like \"link\", precision portion model. mode = \"quantile\" specified, additional argument quantile (numeric scalar vector) specifies quantile(s) compute; default 0.5 (median). Also \"quantile\" mode, additional variable quantile added reference grid, levels values supplied. Back quick reference","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"C","dir":"Articles","previous_headings":"","what":"Group C – Count models","title":"Models supported by emmeans","text":"Two optional arguments – mode lin.pred – provided. mode argument possible values \"response\" (default), \"count\", \"zero\", \"prob0\". lin.pred logical defaults FALSE. lin.pred = FALSE, results comparable returned predict(..., type = \"response\"), predict(..., type = \"count\"), predict(..., type = \"zero\"), predict(..., type = \"prob\")[, 1]. See documentation predict.hurdle predict.zeroinfl. option lin.pred = TRUE applies mode = \"count\" mode = \"zero\". results returned linear-predictor scale, transformation link function part model. predictions reference grid mode = \"count\", lin.pred = TRUE, type = \"response\" obtained lin.pred = FALSE mode = \"count\"; however, EMMs derived grids different, averaging done log-count scale actual count scale, respectively – thereby producing geometric means versus arithmetic means predictions. vcov. argument used (see details documentation ref_grid), must yield matrix size obtained using vcov.hurdle vcov.zeroinfl model argument set (\"full\", \"count\", \"zero\") respective correspondence mode (\"mean\", \"count\", \"zero\"). vcov. function, must support model argument. Back quick reference","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"E","dir":"Articles","previous_headings":"","what":"Group E – GEE models","title":"Models supported by emmeans","text":"models one covariance estimate available, may selected supplying string vcov.method argument. partially matched available choices shown quick reference. geese geeglm, aliases \"robust\" (\"vbeta\") \"naive\" (\"vbeta.naiv\" also accepted. matrix function supplied vcov.method, interpreted vcov. specification described ... documentation ref_grid.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"G","dir":"Articles","previous_headings":"","what":"Group G – Generalized linear models and relatives","title":"Models supported by emmeans","text":"models group receive standard support Group , typically tests confidence intervals asymptotic. Thus df column tabular results Inf. objects group may require original reference dataset provided calling ref_grid() emmeans(). case mgcv::gam objects, optional freq unconditional arguments detailed documentation mgcv::vcov.gam(). default FALSE. value unconditional matters freq = FALSE object$Vc non-null. mgcv::gamm objects, emmeans() results based object$gam part. Unfortunately, missing call component, user must supply call argument (e.g., call = quote(gamm(y ~ s(x), data = dat))) give dataset data argument. Alternatively (recommended), may first set object$gam$call quoted call ahead time. arguments used select model formula use: \"location\", \"scale\" apply gaulss gevlss families, \"shape\" applies gevlss, \"rate\", \"prob.gt.0\" apply ziplss. gam::Gam objects, standard errors estimated using bootstrap method smoothers involved. Accordingly, optional nboot argument sets number bootstrap replications used estimate variances covariances smoothing portions model. Generally, better use models fitted via mgcv::gam() rather gam::gam(). Back quick reference","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"H","dir":"Articles","previous_headings":"","what":"Group H – gamlss models","title":"Models supported by emmeans","text":"argument possible values \"mu\" (default), \"sigma\", \"nu\", \"tau\" depending part model want results . Currently, support selected part model contains smoothing method like pb().","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"I","dir":"Articles","previous_headings":"","what":"Group I – Multiple models (via imputation or averaging)","title":"Models supported by emmeans","text":"objects results fitting several models different predictor subsets imputed values. bhat V slots obtained via averaging , case multiple imputation, adding multiple -imputation covariance per Rubin’s rules. case mira models model classes supported emmeans, GitHub issue #446 includes function pool_estimates_for_qdrg() may useful obtaining results via qdrg(). Support MuMIn::averaging objects may somewhat dodgy, clear supported model classes work. object must \"modelList\" attribute (obtained constructing object explicitly model list including fit = TRUE call). model fitted data named argument call; else provide data argument call emmeans() ref_grid(). ``full’’ averaging supported; conditional averaging can result non-positive-definite covariance matrices, considered. estimability checking done present (clear even mean ). Also, aware support averaging objects pay attention class models averaged (emmeans options associated class, alternative modes d.f. methods), can obtain direct results linear predictions back-transformations thereof (type = \"response\"). take apart multivariate models, multiple-intercept models (e.g. ordinal ones). (keep reading…) Finally, note special care needed models multiple components (e.g. hurdle models), essentially one set coefficients. can handle one time. subset argument must provided specify coefficients use; can named vector integers (names names actual model terms), special character values \"prefix:pfx\", \"pfx\", wrap:wrp picks coefficients whose names prefixed pfx (e.g., pfxtrtB) wrapped wrp (e.g., wrp(trtB)). formula option also available specifying appropriate formula object$formula suitable. many cases (especially multivariate ordinal models), better making copy one averaged models required terms, hacking object replacing coefficients coef(object, full = TRUE) covariance matrix vcov(object, full = TRUE). need careful match names coefficients correctly, use indexes permute rows columns covariance matrix. use emmeans support, including options available, class model object, rather class averaging. example given towards end Issue 442.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"K","dir":"Articles","previous_headings":"","what":"Group K – gls and lme models","title":"Models supported by emmeans","text":"sigmaAdjust argument logical value defaults TRUE. comparable adjustSigma option nlme::summary.lme (name-mangling avoid conflicts often-used adjust argument), determines whether degrees--freedom adjustment performed models fitted using ML method. optional mode argument affects degrees freedom. mode = \"satterthwaite\" option determines degrees freedom via Satterthwaite method: s^2 estimate variance, Satterthwaite d.f. 2*s^4 / Var(s^2). case numerical methods fail, also offer mode = \"appx-satterthwaite\" backup, quantities related Var(s^2) obtained randomly perturbing response values. Currently, \"appx-satterthwaite\" available lme objects, used \"satterthwaite\" requested. appx-satterthwaite simulation-based, results may vary analysis repeated. extra.iter argument may added request additional simulation runs ([possibly considerable] cost repeating model-fitting many times). (Note: Previously, \"appx-satterthwaite\" termed \"boot-satterthwaite\"; still supported backward compatibility. “boot” abandoned really approximation method, bootstrap method sense many statistical methods.) alternative method \"df.error\" (gls) \"containment\" (lme). df.error just error degrees freedom model, minus number extra random effects estimated; generally -estimates degrees freedom. asymptotic mode simply sets degrees freedom infinity. \"containment\" mode (lme models) determines degrees freedom coarsest grouping involved contrast linear function involved, tends -estimate degrees freedom. default mode = \"auto\", uses Satterthwaite estimated random effects non-Satterthwaite option otherwise. User reports indicate models special terms like poly() adequately supported gls needed basis recoverable terms component. problem lme. extra.iter argument ignored unless d.f. method (defaults ) appx-satterthwaite. Back quick reference","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"L","dir":"Articles","previous_headings":"","what":"Group L – lmerMod models","title":"Models supported by emmeans","text":"optional lmer.df argument defaults get_EMM_option(\"lmer.df\") (turn defaults \"kenward-roger\"). possible values \"kenward-roger\", \"satterthwaite\", \"asymptotic\" (partially matched case-insensitive). \"kenward-roger\", d.f. obtained using code pbkrtest package, installed. \"satterthwaite\", d.f. obtained using code lmerTest package, installed. \"asymptotic\", needed package installed, d.f. set Inf. (backward compatibility, user may specify mode lieu lmer.df.) -product Kenward-Roger method covariance matrix adjusted using pbkrtest::vcovAdj(). can require considerable computation; avoid overhead, user opt Satterthwaite asymptotic method; , backward compatibility, may disable use pbkrtest via emm_options(disable.pbkrtest = TRUE) (disable pbkrtest package entirely, just use emmeans). computation time required depends roughly number observations, N, design matrix (major part computation involves inverting N x N matrix). Thus, pbkrtest automatically disabled N exceeds value get_emm_option(\"pbkrtest.limit\"), factory default 3000. (user may also specify pbkrtest.limit disable.pbkrtest argument call emmeans() ref_grid()) Similarly , disable.lmerTest lmerTest.limit options arguments affect whether Satterthwaite methods can implemented. df argument may used specify degrees freedom. Note df method = \"kenward-roger\" specified, covariance matrix adjusted K-R degrees freedom used. Finally, note user-specified covariance matrix (via vcov. argument) also disable Kenward-Roger method; case, Satterthwaite method used place Kenward-Roger. Back quick reference","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"M","dir":"Articles","previous_headings":"","what":"Group M – Multivariate models","title":"Models supported by emmeans","text":"multivariate response, different responses treated levels factor – named rep.meas default. mult.name argument may used change name. mult.levs argument may specify named list one sets levels. one element, multivariate levels expressed combinations named factor levels via function base::expand.grid.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"N","dir":"Articles","previous_headings":"","what":"N - Multinomial responses","title":"Models supported by emmeans","text":"reference grid includes pseudo-factor name levels multinomial response. (response expression, name pseudo-factor first name expression; e.g., model formula cbind(col1, col2) ~ trt, grid factors cbind trt levels cbind 1 2.) (can change assigned name multinomial response via mult.resp argument.) optional mode argument match \"prob\" \"latent\". mode = \"prob\", reference-grid predictions consist estimated multinomial probabilities. \"latent\" mode returns linear predictor, recentered averages zero levels response variable (similar sum--zero contrasts). Thus latent variable can regarded log probability level minus average log probability levels. two optional arguments: mode rescale (defaults c(0, 1)). Please note , probabilities sum 1 (latent values sum 0) multivariate-response levels, sensible results emmeans() must involve response one factors. example, resp response k levels, emmeans(model, ~ resp | trt) yield estimated multinomial distribution trt; emmeans(model, ~ trt) just yield average probability 1/k trt. Back quick reference","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"O","dir":"Articles","previous_headings":"","what":"Group O - Ordinal responses","title":"Models supported by emmeans","text":"reference grid ordinal models include variables appear main model well scale nominal models (provided). two optional arguments: mode (character string) rescale (defaults c(0, 1)). mode match one \"latent\" (default), \"linear.predictor\", \"cum.prob\", \"exc.prob\", \"prob\", \"mean.class\", \"scale\" – see quick reference note supported. mode = \"latent\", reference-grid predictions made scale latent variable implied model. scale location latent variable arbitrary, may altered via rescale. predictions multiplied rescale[2], added rescale[1]. Keep mind scaling related link function used model; example, changing probit link logistic link inflate latent values around \\(\\pi/\\sqrt{3}\\), things equal. rescale effect values mode. mode = \"linear.predictor\", mode = \"cum.prob\", mode = \"exc.prob\", boundaries categories (.e., thresholds) ordinal response included reference grid pseudo-factor named cut. reference-grid predictions cumulative probabilities threshold (mode = \"cum.prob\"), exceedance probabilities (one minus cumulative probabilities, mode = \"exc.prob\"), link function thereof (mode = \"linear.predictor\"). mode = \"prob\", pseudo-factor name model’s response variable created, grid predictions probabilities class ordinal response. \"mean.class\", returned results means ordinal response, interpreted numeric value 1 number classes, using \"prob\" results estimated probability distribution case. mode = \"scale\", fitted object incorporates scale model, EMMs obtained factors scale model (log response) instead response model. grid constructed using factors scale model. grid point non-estimable either location scale model (present) set NA, EMMs involving grid point also non-estimable. consequence rank-deficient scale model, latent responses become non-estimable predictions made using average log-scale estimate. rms models additional mode. mode = \"middle\" (default), middle intercept used, comparable default rms::Predict(). quite similar concept mode = \"latent\", intercepts averaged together. Back quick reference","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"P","dir":"Articles","previous_headings":"","what":"P – Other packages","title":"Models supported by emmeans","text":"Models group emmeans support provided package implements model-fitting procedure. Users refer package documentation details emmeans support. cases, package’s models may supported emmeans; , package’s support overrides .","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"Q","dir":"Articles","previous_headings":"","what":"Q – Quantile regression","title":"Models supported by emmeans","text":"elements tau included reference grid pseudo-factor named tau. models, covariance matrix obtained via model’s summary() method covariance = TRUE. user may specify one arguments summary (e.g., se = \"boot\") passed ... argument. caveat one tau value, estimates covariances regression coefficients associated different taus. Thus, contrast involving different taus can estimated SE NA. Also, due NAs covariance matrix, \"mvt\" adjustment unavailable. Note: Older versions rq rqs support required tau; now optional. tau values included object$tau allowed; others silently ignored. efficient (less memory-greedy) specify tau subset using argument ref_grid.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"S","dir":"Articles","previous_headings":"","what":"S – Sampling (MCMC) methods","title":"Models supported by emmeans","text":"Models fitted using MCMC methods contain sample posterior distribution fixed-effect coefficients. cases (e.g., results MCMCpack::MCMCregress() MCMCpack::MCMCpoisson()), object may include \"call\" attribute emmeans() can use reconstruct data obtain basis EMMs. , formula data argument provided may help produce right results. addition, contrasts specifications necessarily recoverable object, system default must match actually used fitting model. summary.emmGrid() method provides credibility intervals (HPD intervals) results, ignores frequentist-oriented arguments (infer, adjust, etc.) .mcmc() method provided creates mcmc object can summarized plotted using coda package (others support objects). provides posterior sample EMMs, contrasts thereof, given reference grid, based posterior sample fixed effects model object. MCMCglmm objects, data argument required; however, save member model object (e.g., object$data = quote(mydata)), removes necessity specifying call. special keyword trait used models. response multivariate numeric, trait generated automatically factor reference grid, arguments mult.levels can used name levels. models multinomial model, use mode argument specify type model, trait = <factor name> specify name data column contains levels factor response. brms package version 2.13 later, emmeans support. Refer documentation package. Back quick reference","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/models.html","id":"V","dir":"Articles","previous_headings":"","what":"Group V – aovList objects (also used with afex_aov objects)","title":"Models supported by emmeans","text":"Support objects limited. avoid strong biases predictions, strongly recommended fitting model, contrasts attribute factors type sums zero – example, \"contr.sum\", \"contr.poly\", \"contr.helmert\" \"contr.treatment\". found case, model re-fitted using sum--zero contrasts (thus requiring additional computation). remove bias EMMs unless design perfectly balanced, annotation added warn . bias cancels comparisons contrasts. intra-block estimates covariances used. , factor appears one error stratum, covariance structure lowest stratum used estimating standard errors. Degrees freedom obtained using Satterthwaite method. general, aovList support best balanced designs, due caution use contrasts. vcov. argument supplied, must yield single covariance matrix unique fixed effects (set error stratum). case, degrees freedom set NA. Back quick reference Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/predictions.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"Prediction in **emmeans**","text":"Focus reference grids Need SD estimate Feedlot example Predictions particular strata Predictions Bayesian models Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/predictions.html","id":"ref-grid","dir":"Articles","previous_headings":"","what":"Focus on reference grids","title":"Prediction in **emmeans**","text":"Prediction central purpose emmeans package. Even name refers idea obtaining marginal averages fitted values; rare situation one want make prediction average several observations. can certainly truly desired, almost always, predictions based reference grid (.e., result emmeans() call), inasmuch reference grid comprises combinations model predictors.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/predictions.html","id":"sd-estimate","dir":"Articles","previous_headings":"","what":"Need for an SD estimate","title":"Prediction in **emmeans**","text":"prediction interval requires estimate error standard deviation, need account uncertainty point predictions uncertainty outcomes centered estimates. current design, save value () returned stats::sigma(object) reference grid constructed model object. models provide sigma() method, case error thrown error SD manually specified. Also, many cases, may sigma() method, return appropriate value(s) context needed predictions. (object returned lme4::glmer(), example,sigma()` seems always returns 1.0.) Indeed, seen example follows, one usually needs construct manual SD estimate model mixed-effects model. essentially always important think specifically whether using appropriate value. may check value assumed looking misc slot reference grid: Finally, sigma may vector, long conformable estimates reference grid. appropriate, example, model fitted nlme::gls() kind non-homogeneous error structure. may take effort, well clear understanding model structure, obtain suitable SD estimates. suggested function insight::get_variance() may helpful – especially working unfamiliar model class. Personally, prefer make sure understand structure model object /summary ensure going astray. Back Contents","code":"rg <- ref_grid(model) rg@misc$sigma"},{"path":"https://rvlenth.github.io/emmeans/articles/predictions.html","id":"feedlot","dir":"Articles","previous_headings":"","what":"Feedlot example","title":"Prediction in **emmeans**","text":"illustrate, consider feedlot dataset provided package. several herds feeder cattle sent feed lots given one three diets. weights cattle measured time entry (ewt) time slaughter (swt). Different herds possibly different entry weights, based breed ranching practices, center herd’s ewt measurements, use covariate mixed model: Now, advised, let’s look SDs involved model: residual SD assumed prediction intervals don’t specify something else. want something else, order predict slaughter weight arbitrary animal, without regard herd, need account variation among herds , seen considerable. two SDs reported VarCorr() assumed represent independent sources variation, may combined total SD using Pythagorean Theorem. update reference grid new value: now ready form prediction intervals. , simply call predict() function interval argument: results may also displayed graphically:  inner intervals confidence intervals, outer ones prediction intervals. Note SEs prediction considerably greater SEs estimation original summary feedlot.rg. Also, sanity check, observe prediction intervals cover ground original data: way, specified desired sigma value additional sigma argument predict() call, rather updating feedlot.rg object. Back Contents","code":"feedlot = transform(feedlot, adj.ewt = ewt - predict(lm(ewt ~ herd))) require(lme4) feedlot.lmer <- lmer(swt ~ adj.ewt + diet + (1|herd), data = feedlot) feedlot.rg <- ref_grid(feedlot.lmer, at = list(adj.ewt = 0)) summary(feedlot.rg)  ## point predictions ##  adj.ewt diet   prediction   SE   df ##        0 Low          1029 25.5 12.0 ##        0 Medium        998 26.4 13.7 ##        0 High         1031 29.4 19.9 ##  ## Degrees-of-freedom method: kenward-roger lme4::VarCorr(feedlot.lmer)  ## for the model ##  Groups   Name        Std.Dev. ##  herd     (Intercept) 77.087   ##  Residual             57.832 feedlot.rg@misc$sigma  ## default in the ref. grid ## [1] 57.83221 feedlot.rg <- update(feedlot.rg, sigma = sqrt(77.087^2 + 57.832^2)) predict(feedlot.rg, interval = \"prediction\") ##  adj.ewt diet   prediction    SE   df lower.PL upper.PL ##        0 Low          1029  99.7 12.0      812     1247 ##        0 Medium        998  99.9 13.7      783     1213 ##        0 High         1031 100.7 19.9      821     1241 ##  ## Degrees-of-freedom method: kenward-roger  ## Prediction intervals and SEs are based on an error SD of 96.369  ## Confidence level used: 0.95 plot(feedlot.rg, PIs = TRUE) range(feedlot$swt) ## [1]  816 1248"},{"path":"https://rvlenth.github.io/emmeans/articles/predictions.html","id":"strata","dir":"Articles","previous_headings":"","what":"Predictions on particular strata","title":"Prediction in **emmeans**","text":"Suppose, example, want predict swt one particular herds. total SD computed appropriate purpose, includes variation among herds. point, talking particular herds, really regarding herd fixed effect interest; expedient thing fit different model herd fixed effect: predict slaughter weight herds 9 19: instance default sigma already correct (error SD available). SD value comparable residual SD previous model, prediction SEs smaller predicting herds. Back Contents","code":"feedlot.lm <- lm(swt ~ adj.ewt + diet + herd, data = feedlot) newrg <- ref_grid(feedlot.lm, at = list(adj.ewt = 0, herd = c(\"9\", \"19\"))) predict(newrg, interval = \"prediction\", by = \"herd\") ## herd = 9: ##  adj.ewt diet   prediction   SE df lower.PL upper.PL ##        0 Low           867 63.6 53      740      995 ##        0 Medium        835 64.1 53      707      964 ##        0 High          866 66.3 53      733      999 ##  ## herd = 19: ##  adj.ewt diet   prediction   SE df lower.PL upper.PL ##        0 Low          1069 62.1 53      945     1194 ##        0 Medium       1037 62.8 53      911     1163 ##        0 High         1068 64.0 53      940     1197 ##  ## Prediction intervals and SEs are based on an error SD of 57.782  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/predictions.html","id":"bayes","dir":"Articles","previous_headings":"","what":"Predictions with Bayesian models","title":"Prediction in **emmeans**","text":"models fitted using Bayesian methods, kinds prediction intervals available forcing frequentist analysis (frequentist = TRUE). However, better flexible approach Bayesian models simulate observations posterior predictive distribution. done via .mcmc() specifying likelihood argument. example given “sophisticated models” vignette. Back Contents Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/re-engineering-clds.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"Re-engineering CLDs","text":"Introduction Grouping underlining Grouping using letters symbols Simulated example Equivalence sets Significance sets Conclusions References Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/re-engineering-clds.html","id":"intro","dir":"Articles","previous_headings":"Contents","what":"Introduction","title":"Re-engineering CLDs","text":"Compact letter displays (CLDs) popular way display multiple comparisons, especially means compare. problematic, however, prone misinterpretation (details later). present background CLDs, show adaptations alternatives may less prone misinterpretation.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/re-engineering-clds.html","id":"underlining","dir":"Articles","previous_headings":"Contents","what":"Grouping by underlining","title":"Re-engineering CLDs","text":"CLDs generalize “underlining” technique shown old experimental design analysis textbooks, results may displayed something like : observed means sorted increasing order, illustration, trt1 lowest mean, ctrl next lowest, trt4 highest. underlines group means extremes group significantly different according statistical test conducted specified alpha level. illustration, trt1 significantly less trt3, trt2, trt4, ctrl; fact trt4 significantly greater others. grouping also illustrates dangers created careless interpretations. observers chart might say “trt1 ctrl equal” “ctrl, trt3, trt2 equal” – fact merely failed show different. confusion results mathematical equality transitive – , two statements equality imply trt1 trt2 must equal, seemingly contradicting finding significantly different. Statistical nonsignificance transitivity property!","code":"trt1  ctrl   trt3   trt2   trt4     ----------           ------------------"},{"path":"https://rvlenth.github.io/emmeans/articles/re-engineering-clds.html","id":"CLDs","dir":"Articles","previous_headings":"Contents","what":"Grouping using letters or symbols","title":"Re-engineering CLDs","text":"underlining method becomes problematic case standard errors (SEs) comparisons unequal – example unequal sample sizes, model non-homogeneous variances. SEs unequal, possible, example, two adjacent means significantly different, two distant ones differ significantly. happens, can’t use underlines group means. problem lines continuous, continuousness forces continuum groupings. However, Piepho (2004) solved problem using symbols instead lines, creating display two means associated symbol deemed statistically different. Using symbols, possible non-contiguous groupings, e.g., possible two means share symbol intervening one share symbol. display called compact letter display. absolutely require actual letters, just symbols can distinguished one another. case differences equal SEs, CLD “” result grouping lines, distinct symbol span contiguous range means can interpreted grouping line. R package multcompView (Graves et al., 2019) provides implementation Piepho algorithm. multcomp package (Hothorn et al. 2008) provides generic cld() function, emmeans package provides cld() method emmGrid objects. Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/re-engineering-clds.html","id":"CLD-example","dir":"Articles","previous_headings":"Contents","what":"Simulated example","title":"Re-engineering CLDs","text":"moving example, simulate data unbalanced design 7 treatments labeled , B, …, G; fit model four distinct true means underlying seven treatments: Treatments B, D, E mean 15, treatments G mean 16, treatments F C solo players means 17 19 respectively.","code":"set.seed(22.10) mu = c(16, 15, 19, 15, 15, 17, 16)  # true means n =  c(19, 15, 16, 18, 29,  2, 14)  # sample sizes foo = data.frame(trt = factor(rep(LETTERS[1:7], n))) foo$y = rnorm(sum(n), mean = mu[as.numeric(foo$trt)], sd = 1.0)  foo.lm = lm(y ~ trt, data = foo)"},{"path":"https://rvlenth.github.io/emmeans/articles/re-engineering-clds.html","id":"default-cld","dir":"Articles","previous_headings":"Contents > Simulated example","what":"Default CLD","title":"Re-engineering CLDs","text":"Let’s see compact letter display marginal means. (Call CLD #1) default “letters” emmeans implementation actually numbers, three groupings indicated symbols 1, 2, 3. illustrates case grouping lines worked, see fact group 1 contiguous. (among results) treatment differs significantly treatments B, E, D, G, C (default 0.05 significance level, Tukey adjustment multiple testing). C significantly greater means since mean group 3. annotation warns two means group necessarily ; yet CLDs present strong visual message . careless reader makes mistake trouble gap group 1, asking can differ G yet G F, “.” explanation SE F huge, owing small sample size, hard statistically different means. almost gift obtain non-contiguous grouping like , forces user think carefully grouping imply. Back Contents","code":"foo.emm = emmeans(foo.lm, \"trt\")  library(multcomp) cld(foo.emm) ##  trt emmean    SE  df lower.CL upper.CL .group ##  B     14.6 0.246 106     14.1     15.1  1     ##  E     15.0 0.177 106     14.6     15.3  1     ##  D     15.3 0.224 106     14.8     15.7  1     ##  G     15.3 0.254 106     14.8     15.9  1     ##  A     16.4 0.218 106     15.9     16.8   2    ##  F     16.6 0.673 106     15.2     17.9  12    ##  C     19.3 0.238 106     18.9     19.8    3   ##  ## Confidence level used: 0.95  ## P value adjustment: tukey method for comparing a family of 7 estimates  ## significance level used: alpha = 0.05  ## NOTE: If two or more means share the same grouping symbol, ##       then we cannot show them to be different. ##       But we also did not show them to be the same."},{"path":"https://rvlenth.github.io/emmeans/articles/re-engineering-clds.html","id":"alt-CLDs","dir":"Articles","previous_headings":"Contents","what":"Alternative CLDs","title":"Re-engineering CLDs","text":"Given discussion , one might wonder possible construct CLD way means sharing symbol actually shown ? answer yes (otherwise wouldn’t asked question!) – quite easy , thanks two things: algorithm making grouping letters based matrix Boolean values associated pair means, set value TRUE pair statistically different (means must receive different grouping letters), FALSE otherwise; algorithm works Boolean matrix thing equivalence testing, can establish specified confidence two means differ specified threshold \\(\\delta\\). One simple way conduct two one-sided tests (TOST) whereby can conclude two means equivalent show difference exceeds \\(-\\delta\\) less \\(+\\delta\\). can use TOST method set Boolean pair FALSE shown equivalent TRUE shown equivalent.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/re-engineering-clds.html","id":"equiv-CLDs","dir":"Articles","previous_headings":"Contents > Alternative CLDs","what":"Equivalence sets","title":"Re-engineering CLDs","text":"example, suppose, based subject-matter considerations, two means differ less 1.0 can considered equivalent. emmeans setup, specify want equivalence testing simply providing nonzero threshold value delta argument. addition, typically make multiplicity adjustments equivalence tests. result obtain (call CLD #2) obtain five groupings – two ignore apply one mean. treatments B E can considered equivalent, treatments E, D, G considered equivalent. also important know say means different groups significantly different. Unlike CLD #1, showing groupings means can show . first four means, grouped together earlier, now assigned two equivalence groupings. treatment F grouped mean – makes sense little data treatment can hardly say anything.","code":"cld(foo.emm, delta = 1, adjust = \"none\") ##  trt emmean    SE  df lower.CL upper.CL .equiv.set ##  B     14.6 0.246 106     14.1     15.1  1         ##  E     15.0 0.177 106     14.6     15.3  12        ##  D     15.3 0.224 106     14.8     15.7   2        ##  G     15.3 0.254 106     14.8     15.9   2        ##  A     16.4 0.218 106     15.9     16.8    3       ##  F     16.6 0.673 106     15.2     17.9     4      ##  C     19.3 0.238 106     18.9     19.8      5     ##  ## Confidence level used: 0.95  ## Statistics are tests of equivalence with a threshold of 1  ## P values are left-tailed  ## significance level used: alpha = 0.05  ## Estimates sharing the same symbol test as equivalent"},{"path":"https://rvlenth.github.io/emmeans/articles/re-engineering-clds.html","id":"signif-CLDs","dir":"Articles","previous_headings":"Contents > Alternative CLDs","what":"Significance sets","title":"Re-engineering CLDs","text":"Another variation simply reverse Boolean flags used constructing CLD #1. two means receive letter significantly different. Thus, really obtain ungrouping letters. label groupings “significance sets.” resulting display distinctively different appearance, common symbols tend far apart rather contiguous. (Call CLD #3) five significance sets. comparing CLD #1, can confirm significant difference shown explicitly corresponds one shown implicitly (sharing group) CLD #1. Back Contents","code":"cld(foo.emm, signif = TRUE) ##  trt emmean    SE  df lower.CL upper.CL .signif.set ##  B     14.6 0.246 106     14.1     15.1  1          ##  E     15.0 0.177 106     14.6     15.3   2         ##  D     15.3 0.224 106     14.8     15.7    3        ##  G     15.3 0.254 106     14.8     15.9     4       ##  A     16.4 0.218 106     15.9     16.8  1234       ##  F     16.6 0.673 106     15.2     17.9      5      ##  C     19.3 0.238 106     18.9     19.8  12345      ##  ## Confidence level used: 0.95  ## P value adjustment: tukey method for comparing a family of 7 estimates  ## significance level used: alpha = 0.05  ## Estimates sharing the same symbol are significantly different"},{"path":"https://rvlenth.github.io/emmeans/articles/re-engineering-clds.html","id":"concl","dir":"Articles","previous_headings":"Contents","what":"Conclusions","title":"Re-engineering CLDs","text":"Compact letter displays show symbols based statistical testing results. tests, strong conclusions findings – small P values, weak conclusions non-findings – P value less \\(\\alpha\\). create visual flags grouping lines symbols, come across visually findings, problem standard CLDs non-findings. show two simple ways use software creates CLDs actual findings flagged symbols. hoped people find modifications useful visually displaying comparisons among means.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/re-engineering-clds.html","id":"refs","dir":"Articles","previous_headings":"Contents","what":"References","title":"Re-engineering CLDs","text":"Graves, Spencer, Piepho Hans-Pieter, Selzer, Luciano, Dorai-Raj, Sundar (2019). multcompView: Visualizations Paired Comparisons. R package version 0.1-8, https://CRAN.R-project.org/package=multcompView Hothorn, Torsten, Bretz, Frank, Westfall, Peter (2008). Simultaneous Inference General Parametric Models. Biometrical Journal 50(3), 346–363. Piepho, Hans-Peter (2004). algorithm letter-based representation pairwise comparisons, Journal Computational Graphical Statistics 13(2) 456–466. Back Contents Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"Sophisticated models in emmeans","text":"System options lmerMod models Bias adjustment random slopes Models offsets Ordinal models Models fitted using MCMC methods Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"lmer","dir":"Articles","previous_headings":"","what":"Linear mixed models (lmer)","title":"Sophisticated models in emmeans","text":"Linear mixed models really important statistics. Emphasis placed fitted using lme4::lmer(), emmeans also supports mixed-model packages nlme. illustrate, consider Oats dataset nlme package. results balanced split-plot experiment: experimental blocks divided plots randomly assigned oat varieties, plots subdivided subplots randomly assigned amounts nitrogen within plot. consider linear mixed model data, excluding interaction (justified case). sake illustration, exclude observations. Let’s look EMMs nitro: notice degrees freedom fractional: due fact whole-plot subplot variations combined standard errors estimated. Different degrees--freedom methods available. default, Kenward-Roger method used, ’s see message pbkrtest package loaded, implements method. may specify different degrees--freedom method via optional argument lmer.df:","code":"library(lme4) Oats.lmer <- lmer(yield ~ Variety + factor(nitro) + (1|Block/Variety),                         data = nlme::Oats, subset = -c(1,2,3,5,8,13,21,34,55)) Oats.emm.n <- emmeans(Oats.lmer, \"nitro\") Oats.emm.n ##  nitro emmean   SE   df lower.CL upper.CL ##    0.0   78.9 7.29 7.78     62.0     95.8 ##    0.2   97.0 7.14 7.19     80.3    113.8 ##    0.4  114.2 7.14 7.19     97.4    131.0 ##    0.6  124.1 7.07 6.95    107.3    140.8 ##  ## Results are averaged over the levels of: Variety  ## Degrees-of-freedom method: kenward-roger  ## Confidence level used: 0.95 emmeans(Oats.lmer, \"nitro\", lmer.df = \"satterthwaite\") ##  nitro emmean   SE   df lower.CL upper.CL ##    0.0   78.9 7.28 7.28     61.8       96 ##    0.2   97.0 7.13 6.72     80.0      114 ##    0.4  114.2 7.13 6.72     97.2      131 ##    0.6  124.1 7.07 6.49    107.1      141 ##  ## Results are averaged over the levels of: Variety  ## Degrees-of-freedom method: satterthwaite  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"dfoptions","dir":"Articles","previous_headings":"","what":"Sophisticated models in emmeans","title":"Sophisticated models in emmeans","text":"latest result uses Satterthwaite method, implemented lmerTest package. Note , method, degrees freedom slightly different, standard errors. Kenward-Roger method also entails making bias adjustment covariance matrix fixed effects; principal difference methods. third possibility \"asymptotic\": just sets degrees freedom Inf – ’s emmeans’s way using z statistics rather t statistics. asymptotic methods tend make confidence intervals bit narrow P values bit low; involve much, much less computation. Note SEs obtained using Satterthwaite method. Comparisons contrasts pretty much models. nitro quantitative levels, might want test polynomial contrasts: interesting thing degrees freedom much larger EMMs. reason nitro within-plot factor, inter-plot variations little role estimating contrasts among nitro levels. hand, Variety whole-plot factor, much bump degrees freedom comparisons:","code":"emmeans(Oats.lmer, \"nitro\", lmer.df = \"asymptotic\") ##  nitro emmean   SE  df asymp.LCL asymp.UCL ##    0.0   78.9 7.28 Inf      64.6      93.2 ##    0.2   97.0 7.13 Inf      83.1     111.0 ##    0.4  114.2 7.13 Inf     100.2     128.2 ##    0.6  124.1 7.07 Inf     110.2     137.9 ##  ## Results are averaged over the levels of: Variety  ## Degrees-of-freedom method: asymptotic  ## Confidence level used: 0.95 contrast(Oats.emm.n, \"poly\") ##  contrast  estimate    SE   df t.ratio p.value ##  linear      152.69 15.58 43.2   9.802  <.0001 ##  quadratic    -8.27  6.95 44.2  -1.190  0.2402 ##  cubic        -6.32 15.21 42.8  -0.415  0.6800 ##  ## Results are averaged over the levels of: Variety  ## Degrees-of-freedom method: kenward-roger emmeans(Oats.lmer, pairwise ~ Variety) ## $emmeans ##  Variety     emmean   SE   df lower.CL upper.CL ##  Golden Rain  105.2 7.53 8.46     88.0      122 ##  Marvellous   108.5 7.48 8.28     91.3      126 ##  Victory       96.9 7.64 8.81     79.6      114 ##  ## Results are averaged over the levels of: nitro  ## Degrees-of-freedom method: kenward-roger  ## Confidence level used: 0.95  ##  ## $contrasts ##  contrast                 estimate   SE   df t.ratio p.value ##  Golden Rain - Marvellous    -3.23 6.55 9.56  -0.493  0.8764 ##  Golden Rain - Victory        8.31 6.71 9.80   1.238  0.4595 ##  Marvellous - Victory        11.54 6.67 9.80   1.729  0.2431 ##  ## Results are averaged over the levels of: nitro  ## Degrees-of-freedom method: kenward-roger  ## P value adjustment: tukey method for comparing a family of 3 estimates"},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"lmerOpts","dir":"Articles","previous_headings":"Linear mixed models (lmer)","what":"System options for lmerMod models","title":"Sophisticated models in emmeans","text":"computation required compute adjusted covariance matrix degrees freedom may become cumbersome. user options (.e., emm_options() calls) make possible streamline computations default methods limitations . First, option lmer.df, may values \"kenward-roger\", \"satterthwaite\", \"asymptotic\" (partial matches OK!) specifies default degrees--freedom method. options disable.pbkrtest disable.lmerTest may TRUE FALSE, comprise another way controlling method used (e.g., Kenward-Roger method used get_emm_option(\"disable.pbkrtest\") == TRUE). Finally, options pbkrtest.limit lmerTest.limit, set numeric values, enable given package conditionally whether number data rows exceed given limit. factory default 3000 limits.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"random-slopes","dir":"Articles","previous_headings":"Linear mixed models (lmer)","what":"Bias adjustment with random slopes","title":"Sophisticated models in emmeans","text":"cbpp example, saw example applied bias adjustment inverse transformation. adjustment, required estimate total SD response. computation (relatively) simple model random intercepts. random slopes well? short answer “gets complicated;” example can muddle . illustration model fitted ChickWeight data R datasets package. data comprise weight determinations, time (days since birth), chicks randomized different diets. model fits trend square root weight diet, random intercepts slopes chick (likely best model, ’s totally stupid serves illustration). goal use model estimate mean weight times 5, 10, 15, 20, diet. Accordingly, let’s get estimates needed: just summarize `type = “response”, -estimate mean weights. need apply bias adjustment; involves providing estimate SD transformed response. problem since random slopes involved, SD depends time. particular, model states time \\(t\\), \\[ \\sqrt Y_t = \\mu_t + E + C + S\\times t \\] \\(\\mu_t\\) mean time \\(t\\), \\(E\\) residual error, \\(C\\) random intercept chicks, \\(S\\) random slope chicks. purposes bias correction, need estimate \\(SD(E + C + S\\times t)\\) \\(t\\). first step obtain estimated covariance matrix \\((E, C, S)\\): Now, using matrix expression \\(Var('X) = 'Va\\) \\(X=c(E,C,S)\\) given vector \\(\\), can obtain needed SDs: expected, values increase \\(t\\). Finally, obtain bias-adjusted estimated weights. can use sigma = sig -since values follow ordering cw.emm@grid. example illustrates possible deal random slopes bias corrections. However require fairly careful attention technical details familiarity matrix calculations; don’t comfort level , best get outside help.","code":"cw.lmer <- lmer(sqrt(weight) ~ Time*Diet + (1+Time|Chick), data = ChickWeight) cw.emm <- emmeans(cw.lmer, ~ Time|Diet, at = list(Time = c(5, 10, 15, 20))) V <- matrix(0, nrow = 3, ncol = 3, dimnames = list(c(\"E\",\"C\",\"S\"), c(\"E\",\"C\",\"S\"))) V[1, 1] <- sigma(cw.lmer)^2              # Var(E) V[2:3, 2:3] <- VarCorr(cw.lmer)$Chick    # Cov(C, S) V ##           E           C           S ## E 0.1867732  0.00000000  0.00000000 ## C 0.0000000  0.15918129 -0.03977984 ## S 0.0000000 -0.03977984  0.01513793 sig <- sapply(c(5, 10, 15, 20), function(t) {     a <- c(1, 1, t)     sqrt(sum(a * V %*% a)) }) sig ## [1] 0.5714931 1.0315769 1.5995606 2.1931561 confint(cw.emm, type = \"response\", bias.adj = TRUE, sigma = sig) ## Diet = 1: ##  Time response    SE   df lower.CL upper.CL ##     5     63.2  1.49 45.5     60.2     66.2 ##    10     91.1  4.11 45.8     83.0     99.5 ##    15    124.5  7.81 46.1    109.3    140.8 ##    20    163.6 12.45 46.2    139.6    189.7 ##  ## Diet = 2: ##  Time response    SE   df lower.CL upper.CL ##     5     69.3  2.15 45.0     65.1     73.7 ##    10    106.6  6.14 44.9     94.6    119.3 ##    15    152.3 11.97 44.9    129.1    177.4 ##    20    206.5 19.40 44.9    169.3    247.5 ##  ## Diet = 3: ##  Time response    SE   df lower.CL upper.CL ##     5     72.8  2.20 45.0     68.4     77.3 ##    10    121.3  6.56 44.9    108.5    134.9 ##    15    182.7 13.13 44.9    157.2    210.1 ##    20    256.9 21.69 44.9    215.1    302.4 ##  ## Diet = 4: ##  Time response    SE   df lower.CL upper.CL ##     5     76.4  2.26 45.0     71.9     81.0 ##    10    119.4  6.50 45.0    106.6    132.8 ##    15    172.4 12.75 45.0    147.7    199.1 ##    20    235.5 20.76 45.0    195.5    279.2 ##  ## Degrees-of-freedom method: kenward-roger  ## Confidence level used: 0.95  ## Intervals are back-transformed from the sqrt scale  ## Bias adjustment applied based on sigma = (various values)"},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"adding-variables-not-in-fixed-model-addl-vars","dir":"Articles","previous_headings":"Linear mixed models (lmer) > Bias adjustment with random slopes","what":"Adding variables not in fixed model {addl.vars}","title":"Sophisticated models in emmeans","text":"Consider model like Ordinarily, reference grid include variable x part fixed-effects formula. However, can include via addl.vars argument: obtain EMMs combinations treatment x. (given treatment, means equal every x.) bias adjustments depend x. Back Contents","code":"mod <- lmer(log(response) ~ treatment + (1 + x | subject), data = mydata) EMM <- emmeans(mod, ~ x|treatment, addl.vars = \"x\", at = list(x = -1:1))"},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"offsets","dir":"Articles","previous_headings":"","what":"Models with offsets","title":"Sophisticated models in emmeans","text":"model fitted formula includes offset() term, default, offset computed included reference grid. illustrate, consider hypothetical dataset insurance claims (used example SAS’s documentation). classes cars varying counts (n), sizes (size), age (age), record number insurance claims (claims). fit Poisson model claims function size age. offset log(n) included n functions “exposure” variable. First, let’s look reference grid obtained default: Note n included reference grid average value 500 displayed. let’s look EMMs: can see explicitly happening examining internal structure EMM: note \\(\\log(500) \\approx 6.215\\) used offset value calculating estimates. said, many users like ignore average offset kind model, instead use one corresponding n = 1, estimates obtain estimated rates per unit n. may accomplished specifying offset parameter call: alternative way achieve results set n equal 1 reference grid (output shown, identical): way, may set reference value rates. example, want estimates claims per 100 cars, simply use (results shown): details offsets handled, offset() model term treated differently offset argument model fitting, see “xplanations” vignette. additional complication may come models zero-inflated hurdle models. cases, somewhat ambiguous one might mean “rate”, one interpretation just go techniques estimates just Poisson component model. Another approach estimate response mean zero-inflation included, divide appropriate offset. can done, messy. example given Cross-Validated site. Back Contents","code":"ins <- data.frame(     n = c(500, 1200, 100, 400, 500, 300),     size = factor(rep(1:3,2), labels = c(\"S\",\"M\",\"L\")),     age = factor(rep(1:2, each = 3)),     claims = c(42, 37, 1, 101, 73, 14)) ins.glm <- glm(claims ~ size + age + offset(log(n)),                 data = ins, family = \"poisson\") ref_grid(ins.glm) ## 'emmGrid' object with variables: ##     size = S, M, L ##     age = 1, 2 ##     n = 500 ## Transformation: \"log\" (EMM <- emmeans(ins.glm, \"size\", type = \"response\")) ##  size rate   SE  df asymp.LCL asymp.UCL ##  S    69.3 6.25 Inf     58.03      82.7 ##  M    34.6 3.34 Inf     28.67      41.9 ##  L    11.9 3.14 Inf      7.07      19.9 ##  ## Results are averaged over the levels of: age  ## Confidence level used: 0.95  ## Intervals are back-transformed from the log scale EMM@grid ##   size .offset. .wgt. ## 1    S 6.214608     2 ## 2    M 6.214608     2 ## 3    L 6.214608     2 emmeans(ins.glm, \"size\", type = \"response\", offset = log(1)) ##  size   rate      SE  df asymp.LCL asymp.UCL ##  S    0.1385 0.01250 Inf    0.1161    0.1653 ##  M    0.0693 0.00669 Inf    0.0573    0.0837 ##  L    0.0237 0.00627 Inf    0.0141    0.0398 ##  ## Results are averaged over the levels of: age  ## Confidence level used: 0.95  ## Intervals are back-transformed from the log scale emmeans(ins.glm, \"size\", type = \"response\", at = list(n = 1)) emmeans(ins.glm, \"size\", type = \"response\", offset = log(100))"},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"ordinal","dir":"Articles","previous_headings":"","what":"Ordinal models","title":"Sophisticated models in emmeans","text":"Ordinal-response models comprise example several options available obtaining EMMs. illustrate, consider wine data ordinal package. response rating bitterness five-point scale. consider probit model two factors fermentation: temp (temperature) contact (contact grape skins), judge making rating scale predictor: (earlier modeling, found little interaction factors.) EMMs factor using default options: results “latent” scale; idea continuous random variable (case normal, due probit link) mean depends predictors; ratings discretization latent variable based fixed set cut points (estimated). particular example, also scale model says variance latent variable depends judges. latent results quite bit like measurement data, making easy interpret. catch uniquely defined: apply linear transformation , linear transformation cut points, results .","code":"require(\"ordinal\") ## Loading required package: ordinal wine.clm <- clm(rating ~ temp + contact, scale = ~ judge,                 data = wine, link = \"probit\") emmeans(wine.clm, list(pairwise ~ temp, pairwise ~ contact)) ## $`emmeans of temp` ##  temp emmean    SE  df asymp.LCL asymp.UCL ##  cold -0.884 0.290 Inf    -1.452    -0.316 ##  warm  0.601 0.225 Inf     0.161     1.041 ##  ## Results are averaged over the levels of: contact, judge  ## Confidence level used: 0.95  ##  ## $`pairwise differences of temp` ##  1           estimate    SE  df z.ratio p.value ##  cold - warm    -1.07 0.422 Inf  -2.547  0.0109 ##  ## Results are averaged over the levels of: contact, judge  ##  ## $`emmeans of contact` ##  contact emmean    SE  df asymp.LCL asymp.UCL ##  no      -0.614 0.298 Inf   -1.1990   -0.0297 ##  yes      0.332 0.201 Inf   -0.0632    0.7264 ##  ## Results are averaged over the levels of: temp, judge  ## Confidence level used: 0.95  ##  ## $`pairwise differences of contact` ##  1        estimate    SE  df z.ratio p.value ##  no - yes   -0.684 0.304 Inf  -2.251  0.0244 ##  ## Results are averaged over the levels of: temp, judge"},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"ordlp","dir":"Articles","previous_headings":"","what":"Sophisticated models in emmeans","title":"Sophisticated models in emmeans","text":"clm function actually fits model using ordinary probit model different intercepts cut point. can get detailed information model specifying mode = \"linear.predictor\": Note reference grid involves additional constructed predictor named cut accounts different intercepts model. Let’s obtain EMMs temp linear-predictor scale: just negatives latent results obtained earlier (sign changed make comparisons go right direction). Closely related mode = \"cum.prob\" mode = \"exc.prob\", simply transform linear predictor cumulative probabilities exceedance (1 - cumulative) probabilities. modes give us access details fitted model cumbersome use describing results. can become useful want work terms particular cut point. Let’s look temp terms probability rating least 4:","code":"tmp <- ref_grid(wine.clm, mode = \"lin\") tmp ## 'emmGrid' object with variables: ##     temp = cold, warm ##     contact = no, yes ##     judge = 1, 2, 3, 4, 5, 6, 7, 8, 9 ##     cut = multivariate response levels: 1|2, 2|3, 3|4, 4|5 ## Transformation: \"probit\" emmeans(tmp, \"temp\") ##  temp emmean    SE  df asymp.LCL asymp.UCL ##  cold  0.884 0.290 Inf     0.316     1.452 ##  warm -0.601 0.225 Inf    -1.041    -0.161 ##  ## Results are averaged over the levels of: contact, judge, cut  ## Results are given on the probit (not the response) scale.  ## Confidence level used: 0.95 emmeans(wine.clm, ~ temp, mode = \"exc.prob\", at = list(cut = \"3|4\")) ##  temp exc.prob     SE  df asymp.LCL asymp.UCL ##  cold   0.0748 0.0318 Inf    0.0124     0.137 ##  warm   0.4069 0.0706 Inf    0.2686     0.545 ##  ## Results are averaged over the levels of: contact, judge  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"ordprob","dir":"Articles","previous_headings":"","what":"Sophisticated models in emmeans","title":"Sophisticated models in emmeans","text":"yet modes! mode = \"prob\", obtain estimates probability distribution rating. reference grid includes factor name model response – case rating. usually want use primary factor, factors interest variables: Using mode = \"mean.class\" obtains average probability distributions probabilities integers 1–5: mode scale model . example, scale model involves judges, factor grid: Judge 8’s ratings don’t vary much, relative others. scale model terms log(SD). , uniquely identifiable, first level’s estimate set log(1) = 0. , actually, estimate shown comparison judge 1. Back Contents","code":"emmeans(wine.clm, ~ rating | temp, mode = \"prob\") ## temp = cold: ##  rating   prob     SE  df asymp.LCL asymp.UCL ##  1      0.1292 0.0625 Inf   0.00667    0.2518 ##  2      0.4877 0.0705 Inf   0.34948    0.6259 ##  3      0.3083 0.0594 Inf   0.19186    0.4248 ##  4      0.0577 0.0238 Inf   0.01104    0.1043 ##  5      0.0171 0.0127 Inf  -0.00768    0.0419 ##  ## temp = warm: ##  rating   prob     SE  df asymp.LCL asymp.UCL ##  1      0.0156 0.0129 Inf  -0.00961    0.0408 ##  2      0.1473 0.0448 Inf   0.05959    0.2350 ##  3      0.4302 0.0627 Inf   0.30723    0.5532 ##  4      0.2685 0.0625 Inf   0.14593    0.3910 ##  5      0.1384 0.0506 Inf   0.03923    0.2376 ##  ## Results are averaged over the levels of: contact, judge  ## Confidence level used: 0.95 emmeans(wine.clm, \"temp\", mode = \"mean.class\") ##  temp mean.class    SE  df asymp.LCL asymp.UCL ##  cold       2.35 0.144 Inf      2.06      2.63 ##  warm       3.37 0.146 Inf      3.08      3.65 ##  ## Results are averaged over the levels of: contact, judge  ## Confidence level used: 0.95 summary(ref_grid(wine.clm, mode = \"scale\"), type = \"response\") ##  judge response    SE  df ##  1        1.000 0.000 Inf ##  2        1.043 0.570 Inf ##  3        1.053 0.481 Inf ##  4        0.710 0.336 Inf ##  5        0.663 0.301 Inf ##  6        0.758 0.341 Inf ##  7        1.071 0.586 Inf ##  8        0.241 0.179 Inf ##  9        0.533 0.311 Inf"},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"mcmc","dir":"Articles","previous_headings":"","what":"Models fitted using MCMC methods","title":"Sophisticated models in emmeans","text":"illustrate emmeans’s support models fitted using MCMC methods, consider example_model available rstanarm package. example concerns CBPP, serious disease cattle Ethiopia. generalized linear mixed model fitted data using code . (Bayesian equivalent frequentist model considered “Transformations” vignette.) fitting model, first set contrast coding bayestestR::contr.bayes equalizes priors across different treatment levels (correction earlier version vignette.) subsequently obtain reference grids models usual way. later use, also fit model just prior information. structure reference grid: EMMs (averaging needed simple model): summary EMMs Bayesian models shows median posterior distribution estimate, along highest posterior density (HPD) intervals. hood, posterior sample parameter estimates used compute corresponding sample posterior EMMs, summarized. (Technical note: summary actually rerouted hpd.summary() function.","code":"cbpp <- transform(lme4::cbpp, unit = 1:56) require(\"bayestestR\") options(contrasts = c(\"contr.bayes\", \"contr.poly\")) cbpp.rstan <- rstanarm::stan_glmer(     cbind(incidence, size - incidence) ~ period + (1|herd) + (1|unit),     data = cbpp, family = binomial,     prior = student_t(df = 5, location = 0, scale = 2, autoscale = FALSE),     chains = 2, cores = 1, seed = 2021.0120, iter = 1000) cbpp_prior.rstan <- update(cbpp.rstan, prior_PD = TRUE) cbpp.rg <- ref_grid(cbpp.rstan) cbpp_prior.rg <- ref_grid(cbpp_prior.rstan) cbpp.rg ## 'emmGrid' object with variables: ##     period = 1, 2, 3, 4 ## Transformation: \"logit\" summary(cbpp.rg) ##  period prediction lower.HPD upper.HPD ##  1           -1.60     -2.26    -0.987 ##  2           -2.77     -3.65    -1.974 ##  3           -2.90     -3.77    -2.040 ##  4           -3.32     -4.43    -2.385 ##  ## Point estimate displayed: median  ## Results are given on the logit (not the response) scale.  ## HPD interval probability: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"bayesxtra","dir":"Articles","previous_headings":"","what":"Sophisticated models in emmeans","title":"Sophisticated models in emmeans","text":"can access posterior EMMs via .mcmc method emmGrid objects. gives us object class mcmc (defined coda package), can summarized explored please. Note .mcmc actually produce mcmc.list one chain present, example. 2.5th 97.5th quantiles similar, identical, 95% confidence intervals frequentist summary. bayestestR package provides emmGrid methods description testing functions. example: sets results suggest period 1 different others. information methods, refer CRAN page bayestestR vignettes, e.g., one Bayes factors.","code":"require(\"coda\") ## Loading required package: coda summary(as.mcmc(cbpp.rg)) ##  ## Iterations = 1:500 ## Thinning interval = 1  ## Number of chains = 2  ## Sample size per chain = 500  ##  ## 1. Empirical mean and standard deviation for each variable, ##    plus standard error of the mean: ##  ##            Mean     SD Naive SE Time-series SE ## period 1 -1.595 0.3333  0.01054        0.01279 ## period 2 -2.790 0.4327  0.01368        0.01367 ## period 3 -2.916 0.4491  0.01420        0.01706 ## period 4 -3.379 0.5384  0.01703        0.01845 ##  ## 2. Quantiles for each variable: ##  ##            2.5%    25%    50%    75%   97.5% ## period 1 -2.283 -1.823 -1.597 -1.357 -0.9929 ## period 2 -3.707 -3.038 -2.766 -2.511 -2.0197 ## period 3 -3.834 -3.196 -2.899 -2.610 -2.0915 ## period 4 -4.502 -3.725 -3.318 -3.022 -2.4079 bayestestR::bayesfactor_parameters(pairs(cbpp.rg), prior = pairs(cbpp_prior.rg)) ## Warning: Bayes factors might not be precise. ##   For precise Bayes factors, sampling at least 40,000 posterior samples is recommended. ## Bayes Factor (Savage-Dickey density ratio) ##  ## Parameter         |    BF ## ------------------------- ## period1 - period2 |  3.01 ## period1 - period3 |  5.13 ## period1 - period4 | 14.26 ## period2 - period3 | 0.173 ## period2 - period4 | 0.268 ## period3 - period4 | 0.221 ##  ## * Evidence Against The Null: 0 bayestestR::p_rope(pairs(cbpp.rg), range = c(-0.25, 0.25)) ## Proportion of samples inside the ROPE [-0.25, 0.25] ##  ## Parameter         | p (ROPE) ## ---------------------------- ## period1 - period2 |    0.021 ## period1 - period3 |    0.015 ## period1 - period4 |    0.004 ## period2 - period3 |    0.367 ## period2 - period4 |    0.184 ## period3 - period4 |    0.290"},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"bias-adj-mcmc","dir":"Articles","previous_headings":"Models fitted using MCMC methods","what":"Bias-adjusted incidence probabilities","title":"Sophisticated models in emmeans","text":"Next, let us consider back-transformed results. discussed frequentist model, random effects present, wee want think terms marginal probabilities across herds units, correct bias; , need standard deviations random effects. model object MCMC results random effects herd unit, , also summary results posterior SDs two random effects. (used colnames function find 78th 79th columns.) first : obtain bias-adjusted marginal probabilities, obtain resultant SD regrid bias correction: plot posterior incidence probabilities, back-transformed:  … intervals period compared neighbor: interval excludes zero one compares periods 1 2.","code":"cbpp.sigma = as.matrix(cbpp.rstan$stanfit)[, 78:79] head(cbpp.sigma) ##           parameters ## iterations Sigma[unit:(Intercept),(Intercept)] Sigma[herd:(Intercept),(Intercept)] ##       [1,]                            1.154694                         0.167807505 ##       [2,]                            1.459379                         0.040318460 ##       [3,]                            1.482619                         0.006198847 ##       [4,]                            1.236694                         0.206057981 ##       [5,]                            1.460472                         0.088491844 ##       [6,]                            1.412277                         0.070334431 totSD <- sqrt(apply(cbpp.sigma^2, 1, sum)) cbpp.rgrd <- regrid(cbpp.rg, bias.adjust = TRUE, sigma = totSD) summary(cbpp.rgrd) ##  period   prob lower.HPD upper.HPD ##  1      0.2199    0.1324     0.322 ##  2      0.0864    0.0329     0.156 ##  3      0.0767    0.0241     0.137 ##  4      0.0524    0.0120     0.106 ##  ## Point estimate displayed: median  ## HPD interval probability: 0.95 bayesplot::mcmc_areas(as.mcmc(cbpp.rgrd)) contrast(cbpp.rgrd, \"consec\", reverse = TRUE) ##  contrast          estimate lower.HPD upper.HPD ##  period1 - period2  0.13283    0.0280     0.235 ##  period2 - period3  0.00918   -0.0635     0.097 ##  period3 - period4  0.02331   -0.0427     0.103 ##  ## Point estimate displayed: median  ## HPD interval probability: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/sophisticated.html","id":"predict-mcmc","dir":"Articles","previous_headings":"Models fitted using MCMC methods","what":"Bayesian prediction","title":"Sophisticated models in emmeans","text":"predict MCMC model, just specify likelihood argument .mcmc. causes function simulate data posterior predictive distribution. example, want predict CBPP incidence future herds 25 cattle, can :  Back Contents Index vignette topics","code":"set.seed(2019.0605) cbpp.preds <- as.mcmc(cbpp.rgrd, likelihood = \"binomial\", trials = 25) bayesplot::mcmc_hist(cbpp.preds, binwidth = 1)"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"Transformations and link functions in emmeans","text":"vignette covers intricacies transformations link functions emmeans. Overview Re-gridding Link functions Graphing transformations links response transformation link Special transformations Specifying transformation fact Auto-detected transformations Standardized response Faking transformations Alternative scale Bias adjustment Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Transformations and link functions in emmeans","text":"Consider example pigs dataset used many vignettes; time, use log transformation response: model two factors, source percent (coerced factor), predictors; log-transformed conc response. obtain EMMs source, examine structure, finally produce summary, including test null value log(35): Now suppose want EMMs expressed scale conc. can done adding type = \"response\" summary() call: Note: Looking ahead, output compared later vignette bias-adjusted version.","code":"pigs.lm <- lm(log(conc) ~ source + factor(percent), data = pigs) emm.src <- emmeans(pigs.lm, \"source\") str(emm.src) ## 'emmGrid' object with variables: ##     source = fish, soy, skim ## Transformation: \"log\" summary(emm.src, infer = TRUE, null = log(35)) ##  source emmean     SE df lower.CL upper.CL null t.ratio p.value ##  fish     3.39 0.0367 23     3.32     3.47 3.56  -4.385  0.0002 ##  soy      3.67 0.0374 23     3.59     3.74 3.56   2.988  0.0066 ##  skim     3.80 0.0394 23     3.72     3.88 3.56   6.130  <.0001 ##  ## Results are averaged over the levels of: percent  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95 summary(emm.src, infer = TRUE, null = log(35), type = \"response\") ##  source response   SE df lower.CL upper.CL null t.ratio p.value ##  fish       29.8 1.09 23     27.6     32.1   35  -4.385  0.0002 ##  soy        39.1 1.47 23     36.2     42.3   35   2.988  0.0066 ##  skim       44.6 1.75 23     41.1     48.3   35   6.130  <.0001 ##  ## Results are averaged over the levels of: percent  ## Confidence level used: 0.95  ## Intervals are back-transformed from the log scale  ## Tests are performed on the log scale"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"timing","dir":"Articles","previous_headings":"Overview","what":"Timing is everything","title":"Transformations and link functions in emmeans","text":"Dealing transformations emmeans somewhat complex, due large number possibilities. key understanding happens, . results come sequence steps. happens (doesn’t happen) step: reference grid constructed log(conc) model. fact log transformation used recorded, nothing else done information. predictions reference grid averaged four percent levels, source, obtain EMMs source – still log(conc) scale. standard errors confidence intervals EMMs computed – still log(conc) scale. EMMs back-transformed conc scale. endpoints confidence intervals back-transformed. t tests P values left -. standard errors converted conc scale using delta method. SEs used constructing tests confidence intervals.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"the-model-is-our-best-guide","dir":"Articles","previous_headings":"Overview","what":"The model is our best guide","title":"Transformations and link functions in emmeans","text":"choice timing based idea model right. particular, fact response transformed suggests transformed scale best scale working . addition, model specifies effects source percent linear transformed scale; inasmuch marginal averaging obtain EMMs linear operation, averaging best done transformed scale. two good reasons, back-transforming response scale delayed end default. Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"regrid","dir":"Articles","previous_headings":"","what":"Re-gridding","title":"Transformations and link functions in emmeans","text":"well-advised , users may want default timing things. tool changing back-transformation performed regrid() function – , default settings arguments, back-transforms emmGrid object adjusts everything appropriately. example: Notice structure longer includes transformation. ’s longer relevant; reference grid conc scale, got now forgotten. Compare summary() result preceding one, note following: longer annotations concerning transformations. estimates SEs identical. confidence intervals, t ratios, P values identical. , time, SEs shown table ones actually used construct tests intervals. Understood, right? think carefully EMMs obtained. back-transformed emm.src, marginal averaging done log scale. want back-transform averaging, need call regrid() reference grid constructed averaging takes place: results differ either previous two summaries – , averaging done conc scale rather log(conc) scale.","code":"str(regrid(emm.src)) ## 'emmGrid' object with variables: ##     source = fish, soy, skim summary(regrid(emm.src), infer = TRUE, null = 35) ##  source response   SE df lower.CL upper.CL null t.ratio p.value ##  fish       29.8 1.09 23     27.5     32.1   35  -4.758  0.0001 ##  soy        39.1 1.47 23     36.1     42.2   35   2.827  0.0096 ##  skim       44.6 1.75 23     40.9     48.2   35   5.446  <.0001 ##  ## Results are averaged over the levels of: percent  ## Confidence level used: 0.95 pigs.rg <- ref_grid(pigs.lm) remm.src <- emmeans(regrid(pigs.rg), \"source\") summary(remm.src, infer = TRUE, null = 35) ##  source response   SE df lower.CL upper.CL null t.ratio p.value ##  fish       30.0 1.10 23     27.7     32.2   35  -4.585  0.0001 ##  soy        39.4 1.49 23     36.3     42.5   35   2.927  0.0076 ##  skim       44.8 1.79 23     41.1     48.5   35   5.486  <.0001 ##  ## Results are averaged over the levels of: percent  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"regrid2","dir":"Articles","previous_headings":"","what":"Transformations and link functions in emmeans","title":"Transformations and link functions in emmeans","text":"Note: want routinely back-transform averaging, regrid argument ref_grid() simplifies . first two steps done easily follows: don’t get regrid type confused. regrid argument passed regrid() (transform argument) reference grid constructed, whereas type argument simply remembered used summary(). similar-looking call: compute results seen emm.src – back-transformed averaging log scale. Remember : comes transformations, timing everything. Back Contents","code":"remm.src <- emmeans(pigs.lm, \"source\", regrid = \"response\") emmeans(pigs.lm, \"source\", type = \"response\")"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"links","dir":"Articles","previous_headings":"","what":"Link functions","title":"Transformations and link functions in emmeans","text":"Exactly ideas presented response transformations apply generalized linear models non-identity link functions. far emmeans concerned, difference . illustrate, consider neuralgia dataset provided package. data come experiment reported SAS technical report different treatments neuralgia compared. patient’s sex additional factor, age covariate. response Pain, binary variable whether patient reports neuralgia pain treatment. model suggested SAS report equivalent following. use obtain estimated probabilities experiencing pain:","code":"neuralgia.glm <- glm(Pain ~ Treatment * Sex + Age, family = binomial(), data = neuralgia) neuralgia.emm <- emmeans(neuralgia.glm, \"Treatment\", type = \"response\") ## NOTE: Results may be misleading due to involvement in interactions neuralgia.emm ##  Treatment  prob     SE  df asymp.LCL asymp.UCL ##  A         0.211 0.1109 Inf    0.0675     0.497 ##  B         0.121 0.0835 Inf    0.0285     0.391 ##  P         0.866 0.0883 Inf    0.5927     0.966 ##  ## Results are averaged over the levels of: Sex  ## Confidence level used: 0.95  ## Intervals are back-transformed from the logit scale"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"oddsrats","dir":"Articles","previous_headings":"","what":"Transformations and link functions in emmeans","title":"Transformations and link functions in emmeans","text":"(note interaction discussed shortly.) Note averaging Sex done logit scale, results back-transformed summary. may use pairs() compare estimates; note logits logs odds; another instance log-differences back-transformed – case odds ratios: evidence considerably pain reported placebo (treatment P) either two treatments. estimated odds pain B half , finding statistically significant. (odds made-dataset seem quite high, finding strictly author’s impression.) Observe note output neuralgia.emm results may misleading. important take seriously, two factors interact, may case marginal averages predictions don’t reflect happening level factors averaged . find , look interaction plot fitted model: practical difference females males patterns response Treatment; think people quite comfortable marginal results reported . users prefer risk ratios (ratios probabilities) rather odds ratios. revisit example discussed tools. Back Contents","code":"pairs(neuralgia.emm, reverse = TRUE) ##  contrast odds.ratio     SE  df null z.ratio p.value ##  B / A         0.513  0.515 Inf    1  -0.665  0.7837 ##  P / A        24.234 25.142 Inf    1   3.073  0.0060 ##  P / B        47.213 57.242 Inf    1   3.179  0.0042 ##  ## Results are averaged over the levels of: Sex  ## P value adjustment: tukey method for comparing a family of 3 estimates  ## Tests are performed on the log odds ratio scale emmip(neuralgia.glm, Sex ~ Treatment)"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"trangraph","dir":"Articles","previous_headings":"","what":"Graphing transformations and links","title":"Transformations and link functions in emmeans","text":"options displaying transformed results graphically. First, type argument works just displaying tabular summary. Following neuralgia example, let us display marginal Treatment EMMs link scale response scale (opting averaging link scale):   Besides whether see response values, dramatic difference symmetry intervals. emmip() plot() (currently “ggplot” engine), also option specifying type = \"scale\", causes response values calculated plotted nonlinear scale corresponding transformation link:  Notice interior part plot identical plot link scale. horizontal axis different. response values transformed using link function determine plotting positions graphical elements – putting back started. case , nonlinear scales can confusing read, often true want display scale divisions, even add minor ones. done via adding arguments function ggplot2::scale_x_continuous() (see documentation):  using \"ggplot\" engine, always option using ggplot2 incorporate transformed scale – doesn’t even transformation used model. example, display results arcsin-square-root scale.  comes across compromise: severe logit scaling, distorted linear scaling response values. , techniques can used emmip(), except vertical scale affected. Back Contents","code":"neur.Trt.emm <- suppressMessages(emmeans(neuralgia.glm, \"Treatment\")) plot(neur.Trt.emm)   # Link scale by default plot(neur.Trt.emm, type = \"response\") plot(neur.Trt.emm, type = \"scale\") plot(neur.Trt.emm, type = \"scale\", breaks = seq(0.10, 0.90, by = 0.10),      minor_breaks = seq(0.05, 0.95, by = 0.05)) plot(neur.Trt.emm, type = \"response\") +   ggplot2::scale_x_continuous(trans = scales::asn_trans(),                               breaks = seq(0.10, 0.90, by = 0.10))"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"tranlink","dir":"Articles","previous_headings":"","what":"Models having both a response transformation and a link function","title":"Transformations and link functions in emmeans","text":"possible generalized linear model non-identity link response transformation. example, built-wapbreaks dataset: canonical link gamma model reciprocal (inverse); square-root response transformation besides. choose type = \"response\" summarizing, undo transformations: happened first linear predictor back-transformed link scale (inverse); squares obtained back-transform rest way. possible undo link, response transformation: possible undo response transformation leave link place, response transform first, link model applied; undo reverse order make sense. One may also use \"unlink\" transform argument regrid() ref_grid(). Back Contents","code":"warp.glm <- glm(sqrt(breaks) ~ wool*tension, family = Gamma, data = warpbreaks) ref_grid(warp.glm) ## 'emmGrid' object with variables: ##     wool = A, B ##     tension = L, M, H ## Transformation: \"inverse\"  ## Additional response transformation: \"sqrt\" emmeans(warp.glm, ~ tension | wool, type = \"response\") ## wool = A: ##  tension response   SE df lower.CL upper.CL ##  L           42.9 5.24 48     34.0     55.7 ##  M           23.3 2.85 48     18.5     30.3 ##  H           23.6 2.88 48     18.7     30.7 ##  ## wool = B: ##  tension response   SE df lower.CL upper.CL ##  L           27.4 3.35 48     21.8     35.7 ##  M           28.1 3.43 48     22.3     36.5 ##  H           18.5 2.26 48     14.7     24.1 ##  ## Confidence level used: 0.95  ## Intervals are back-transformed from the sqrt[inverse] scale emmeans(warp.glm, ~ tension | wool, type = \"unlink\") ## wool = A: ##  tension response    SE df lower.CL upper.CL ##  L           6.55 0.400 48     5.83     7.46 ##  M           4.83 0.295 48     4.30     5.50 ##  H           4.86 0.297 48     4.33     5.54 ##  ## wool = B: ##  tension response    SE df lower.CL upper.CL ##  L           5.24 0.320 48     4.67     5.97 ##  M           5.30 0.324 48     4.72     6.04 ##  H           4.30 0.263 48     3.83     4.90 ##  ## Confidence level used: 0.95  ## Intervals are back-transformed from the inverse scale"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"special","dir":"Articles","previous_headings":"","what":"Special transformations","title":"Transformations and link functions in emmeans","text":"make.tran() function provides several special transformations sets things can handled emmeans relative ease. (See help(\"make.tran\", \"emmeans\") descriptions available.) make.tran() works much like stats::make.link() returns list functions linkfun(), linkinv(), etc. serve managing results transformed scale. difference transformations make.tran() require additional arguments. use capability emmeans(), fortuitous first obtain make.tran() result, use enclosing environment fitting model, linkfun transformation. example, suppose response variable percentage want use response transformation \\(\\sin^{-1}\\sqrt{y/100}\\). proceed like : Subsequent calls ref_grid(), emmeans(), regrid(), etc. able access transformation information correctly. help page make.tran() example like using Box-Cox transformation. Back Contents","code":"tran <- make.tran(\"asin.sqrt\", 100) my.model <- with(tran,      lmer(linkfun(percent) ~ treatment + (1|Block), data = mydata))"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"after","dir":"Articles","previous_headings":"","what":"Specifying a transformation after the fact","title":"Transformations and link functions in emmeans","text":"uncommon fit model using statements like following: case, way ref_grid() figure response transformation used. can done update reference grid required information: Subsequently, use .rg place .model emmeans() analyses, transformation information . standard transformations (stats::make.link()), just give name transformation; e.g.,","code":"mydata <- transform(mydata, logy.5 = log(yield + 0.5)) my.model <- lmer(logy.5 ~ treatment + (1|Block), data = mydata) my.rg <- update(ref_grid(my.model), tran = make.tran(\"genlog\", .5)) model.rg <- update(ref_grid(model), tran = \"sqrt\")"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"auto","dir":"Articles","previous_headings":"","what":"Auto-detected response transformations","title":"Transformations and link functions in emmeans","text":"can seen initial pigs.lm example vignette, certain straightforward response transformations log, sqrt, etc. automatically detected emmeans() (really, ref_grid()) called model object. fact, scaling shifting supported ; preceding example .model done easily specifying transformation directly model formula: transformation auto-detected, saving trouble adding later. Similarly, response transformation 2 * sqrt(y + 1) correctly auto-detected. model linearly transformed response, e.g. 4*(y - 1), auto-detected, 4*(y + -1) interpreted 4*identity(y + -1). Parsing response expression must form mult * fcn(resp + const); operators - / recognized. Back Contents","code":"my.better.model <- lmer(log(yield + 0.5) ~ treatment + (1|Block), data = mydata)"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"logs","dir":"Articles","previous_headings":"","what":"Faking a log transformation","title":"Transformations and link functions in emmeans","text":"regrid() function makes possible fake log transformation response. want ? can make comparisons using ratios instead differences. Consider pigs example , suppose fitted model square-root transformation instead log: results identical, similar back-transformed confidence intervals EMMs pairwise ratios “comparisons” vignette, fitted model actually used log response.","code":"pigroot.lm <- lm(sqrt(conc) ~ source + factor(percent), data = pigs) logemm.src <- regrid(emmeans(pigroot.lm, \"source\"), transform = \"log\") confint(logemm.src, type = \"response\") ##  source response   SE df lower.CL upper.CL ##  fish       29.8 1.32 23     27.2     32.7 ##  soy        39.2 1.54 23     36.2     42.6 ##  skim       45.0 1.74 23     41.5     48.7 ##  ## Results are averaged over the levels of: percent  ## Confidence level used: 0.95  ## Intervals are back-transformed from the log scale pairs(logemm.src, type = \"response\") ##  contrast    ratio     SE df null t.ratio p.value ##  fish / soy  0.760 0.0454 23    1  -4.591  0.0004 ##  fish / skim 0.663 0.0391 23    1  -6.965  <.0001 ##  soy / skim  0.872 0.0469 23    1  -2.548  0.0457 ##  ## Results are averaged over the levels of: percent  ## P value adjustment: tukey method for comparing a family of 3 estimates  ## Tests are performed on the log scale"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"faking","dir":"Articles","previous_headings":"Faking a log transformation","what":"Faking other transformations","title":"Transformations and link functions in emmeans","text":"possible fake transformations log. Just use method, e.g. (results displayed) re-grid existing emm probit scale. Note estimates emm outside interval \\((0,1)\\) flagged non-estimable. section standardized responses gives example reverse-engineering standardized response transformation way.","code":"regrid(emm, transform = \"probit\")"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"riskrats","dir":"Articles","previous_headings":"Faking a log transformation","what":"Revisiting the neuralgia example","title":"Transformations and link functions in emmeans","text":"mentioned neuralgia example, users prefer ratios probabilities (risk ratios) rather odds ratios. additional machinery regrid() makes possible. First, node neuralgia.emm estimate logit probability, corresponding nodes log.emm estimates log probability. Thus, pairwise comparisons differences logs, logs ratios. risk ratios thus obtainable test statistics P values differ somewhat odds ratios computed log scale rather original logit scale.","code":"log.emm <- regrid(neuralgia.emm, \"log\") pairs(log.emm, reverse = TRUE, type = \"response\") ##  contrast ratio    SE  df null z.ratio p.value ##  B / A    0.572 0.484 Inf    1  -0.661  0.7863 ##  P / A    4.107 2.221 Inf    1   2.613  0.0244 ##  P / B    7.181 5.185 Inf    1   2.730  0.0174 ##  ## Results are averaged over the levels of: Sex  ## P value adjustment: tukey method for comparing a family of 3 estimates  ## Tests are performed on the log scale"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"not-logit","dir":"Articles","previous_headings":"","what":"Transformations and link functions in emmeans","title":"Transformations and link functions in emmeans","text":"able obtain odds ratios risk ratios neuralgia.glm. used logit link? odds ratios just fall naturally. However, can regrid() \"logit\" scale want odds ratios, \"log\" scale want risk ratios. example, vaguely comparable odds ratios obtained neuralgia.glm, Similar re-gridding log give us risk ratios.","code":"neuralgia.prb <- glm(Pain ~ Treatment * Sex + Age, family = binomial(link = \"probit\"),                       data = neuralgia) prb.emm <- suppressMessages(emmeans(neuralgia.prb, \"Treatment\")) pairs(regrid(prb.emm, \"logit\"), type = \"response\", reverse = TRUE) ##  contrast odds.ratio     SE  df null z.ratio p.value ##  B / A         0.517  0.509 Inf    1  -0.670  0.7809 ##  P / A        15.561 14.358 Inf    1   2.975  0.0082 ##  P / B        30.077 33.225 Inf    1   3.081  0.0058 ##  ## Results are averaged over the levels of: Sex  ## P value adjustment: tukey method for comparing a family of 3 estimates  ## Tests are performed on the log odds ratio scale"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"altscale","dir":"Articles","previous_headings":"Faking a log transformation","what":"Alternative scale","title":"Transformations and link functions in emmeans","text":"possible create report alternative scale updating tran component. example, suppose want percent differences instead ratios preceding example pigs dataset. possible modifying reverse transformation: since usual reverse transformation ratio form \\(r = /b\\), percentage difference \\(\\) \\(b\\) \\(100(-b)/b = 100(r-1)\\). Thus, Another way obtain estimates directly transform estimated ratios \\(100r - 100\\): estimates , tests confidence intervals different computed re-gridded scale using standard errors shown, rather link scale first results.","code":"pct.diff.tran <- list(     linkfun = function(mu) log(mu/100 + 1),     linkinv = function(eta) 100 * (exp(eta) - 1),     mu.eta = function(eta) 100 * exp(eta),     name = \"log(pct.diff)\" )  update(pairs(logemm.src, type = \"response\"),         tran = pct.diff.tran, inv.lbl = \"pct.diff\", adjust = \"none\",        infer = c(TRUE, TRUE)) ##  contrast    pct.diff   SE df lower.CL upper.CL t.ratio p.value ##  fish / soy     -24.0 4.54 23    -32.8   -13.97  -4.591  0.0001 ##  fish / skim    -33.7 3.91 23    -41.3   -25.08  -6.965  <.0001 ##  soy / skim     -12.8 4.69 23    -22.0    -2.54  -2.548  0.0180 ##  ## Results are averaged over the levels of: percent  ## Confidence level used: 0.95  ## Intervals are back-transformed from the log(pct.diff) scale  ## Tests are performed on the log(pct.diff) scale contrast(regrid(pairs(logemm.src)), \"identity\", scale = 100, offset = -100,          infer = c(TRUE, TRUE)) ##  contrast    estimate   SE df lower.CL upper.CL t.ratio p.value ##  (fish/soy)     -24.0 4.54 23    -33.3    -14.6  -5.281  <.0001 ##  (fish/skim)    -33.7 3.91 23    -41.8    -25.6  -8.613  <.0001 ##  (soy/skim)     -12.8 4.69 23    -22.5     -3.1  -2.730  0.0119 ##  ## Results are averaged over the levels of: percent  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"stdize","dir":"Articles","previous_headings":"","what":"Standardized response","title":"Transformations and link functions in emmeans","text":"disciplines, common fit model standardized response variable. R’s base function scale() makes easy ; important notice scale(y) complicated , say, sqrt(y), scale(y) requires values y order determine centering scaling parameters. ref_grid() function (called `emmeans() others) tries detect scaling parameters. illustrate: interesting (complex) happens emtrends(). Without anything fancy added, slopes (change scale(strength)) / (change diameter); , didn’t anything undo response transformation, trend based exactly variable specified, diameter. get (change strength) / (change diameter), need undo response transformation, done via regrid (invokes regrid() reference grid constructed): want slopes (change scale(strength)) / (change scale(diameter))? can done, necessary manually specify scaling parameters diameter. result one directly related regression coefficients: fourth possibility, (change strength) / (change scale(diameter)), leave reader.","code":"fiber.lm <- lm(scale(strength) ~ machine * scale(diameter), data = fiber) emmeans(fiber.lm, \"machine\")   # on the standardized scale ##  machine   emmean    SE df lower.CL upper.CL ##  A        0.00444 0.156  9   -0.349    0.358 ##  B        0.28145 0.172  9   -0.109    0.672 ##  C       -0.33473 0.194  9   -0.774    0.105 ##  ## Results are given on the scale(40.2, 4.97) (not the response) scale.  ## Confidence level used: 0.95 emmeans(fiber.lm, \"machine\", type = \"response\")   # strength scale ##  machine response    SE df lower.CL upper.CL ##  A           40.2 0.777  9     38.5     42.0 ##  B           41.6 0.858  9     39.7     43.5 ##  C           38.5 0.966  9     36.3     40.7 ##  ## Confidence level used: 0.95  ## Intervals are back-transformed from the scale(40.2, 4.97) scale emtrends(fiber.lm, \"machine\", var = \"diameter\") ##  machine diameter.trend     SE df lower.CL upper.CL ##  A                0.222 0.0389  9   0.1339    0.310 ##  B                0.172 0.0450  9   0.0705    0.274 ##  C                0.174 0.0418  9   0.0791    0.268 ##  ## Confidence level used: 0.95 emtrends(fiber.lm, \"machine\", var = \"diameter\", regrid = \"response\") ##  machine diameter.trend    SE df lower.CL upper.CL ##  A                1.104 0.194  9    0.666     1.54 ##  B                0.857 0.224  9    0.351     1.36 ##  C                0.864 0.208  9    0.394     1.33 ##  ## Confidence level used: 0.95 with(fiber, c(mean = mean(diameter), sd = sd(diameter))) ##      mean        sd  ## 24.133333  4.323799 emtrends(fiber.lm, \"machine\", var = \"scale(diameter, 24.133, 4.324)\") ##  machine scale(diameter, 24.133, 4.324).trend    SE df lower.CL upper.CL ##  A                                      0.960 0.168  9    0.579     1.34 ##  B                                      0.745 0.195  9    0.305     1.19 ##  C                                      0.751 0.181  9    0.342     1.16 ##  ## Confidence level used: 0.95 coef(fiber.lm)[4:6] ##          scale(diameter) machineB:scale(diameter) machineC:scale(diameter)  ##                0.9598846               -0.2148202               -0.2086880"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"what-to-do-if-auto-detection-fails","dir":"Articles","previous_headings":"Standardized response","what":"What to do if auto-detection fails","title":"Transformations and link functions in emmeans","text":"Auto-detection standardized responses bit tricky, doesn’t always succeed. fails, message displayed transformation ignored. cases doesn’t work, need explicitly specify transformation using make.tran(). methods exactly shown earlier vignette, show code results hypothetical example. One method fit model add transformation information later. example, .fcn model-fitting function reason doesn’t allow scaling information detected. , equivalent, method create transformation object first use fitting model:","code":"mod <- some.fcn(scale(RT) ~ group + (1|subject), data = mydata) emmeans(mod, \"group\", type = \"response\",         tran = make.tran(\"scale\", y = mydata$RT)) mod <- with(make.tran(\"scale\", y = mydata$RT),             some.fcn(linkfun(RT) ~ group + (1|subject), data = mydata)) emmeans(mod, \"group\", type = \"response\")"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"reverse-engineering-a-standardized-response","dir":"Articles","previous_headings":"Standardized response","what":"Reverse-engineering a standardized response","title":"Transformations and link functions in emmeans","text":"interesting twist reverse situation: Suppose fitted model without standardized response, want know results standardized. reverse-engineer fiber.lm example : latter call, regrid argument causes regrid() called reference grid constructed. Back Contents","code":"fib.lm <- lm(strength ~ machine * diameter, data = fiber)  # On raw scale: emmeans(fib.lm, \"machine\") ##  machine emmean    SE df lower.CL upper.CL ##  A         40.2 0.777  9     38.5     42.0 ##  B         41.6 0.858  9     39.7     43.5 ##  C         38.5 0.966  9     36.3     40.7 ##  ## Confidence level used: 0.95 # On standardized scale: tran <- make.tran(\"scale\", y = fiber$strength) emmeans(fib.lm, \"machine\", regrid = tran) ##  machine   emmean    SE df lower.CL upper.CL ##  A        0.00444 0.156  9   -0.349    0.358 ##  B        0.28145 0.172  9   -0.109    0.672 ##  C       -0.33473 0.194  9   -0.774    0.105 ##  ## Results are given on the scale(40.2, 4.97) (not the response) scale.  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"bias-adj","dir":"Articles","previous_headings":"","what":"Bias adjustment","title":"Transformations and link functions in emmeans","text":"far, discussed ideas related back-transforming results simple way expressing results scale response. particular, means obtained way known generalized means; example, log transformation response associated geometric means. goal simply make inferences means less means, response transformation used, often acceptable present estimates comparisons generalized means. However, sometimes important report results actually reflect expected values untransformed response. example financial study, response monetary unit. may convenient use response transformation modeling purposes, ultimately may want make financial projections units. settings, need make bias adjustment back-transform, nonlinear transformation biases expected values statistical quantities. specifically, suppose response \\(Y\\) transformed response \\(U\\). back-transform, use \\(Y = h(U)\\); using Taylor approximation, \\(Y \\approx h(\\eta) + h'(\\eta)(U-\\eta) + \\frac12h''(\\eta)(U-\\eta)^2\\), \\(E(Y) \\approx h(\\eta) + \\frac12h''(\\eta)Var(U)\\). shows amount needed bias adjustment approximately \\(\\frac12h''(\\eta)\\sigma^2\\) \\(\\sigma\\) error SD model \\(U\\). depends \\(\\sigma\\), larger , greater bias adjustment needed. second-order bias adjustment currently used emmeans package bias-adjustment requested. better exact adjustments certain cases, future updates may incorporate .","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"pigs-biasadj","dir":"Articles","previous_headings":"Bias adjustment","what":"Pigs example revisited","title":"Transformations and link functions in emmeans","text":"Let us compare estimates overview apply bias adjustment. First, note estimate residual SD available via sigma() function: estimate used default. bias-adjusted EMMs sources : estimates (also SEs) slightly larger without bias adjustment. estimates arithmetic mean responses, rather geometric means shown overview. value sigma larger, adjustment greater. can experiment adding sigma = argument call.","code":"sigma(pigs.lm) ## [1] 0.115128 summary(emm.src, type = \"response\", bias.adj = TRUE) ##  source response   SE df lower.CL upper.CL ##  fish       30.0 1.10 23     27.8     32.4 ##  soy        39.4 1.48 23     36.5     42.6 ##  skim       44.9 1.77 23     41.3     48.7 ##  ## Results are averaged over the levels of: percent  ## Confidence level used: 0.95  ## Intervals are back-transformed from the log scale  ## Bias adjustment applied based on sigma = 0.11513"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"link-bias","dir":"Articles","previous_headings":"Bias adjustment","what":"Response transformations vs. link functions","title":"Transformations and link functions in emmeans","text":"point, important point discussion focuses response transformations, opposed link functions used generalized linear models (GLMs). ordinary GLM, bias adjustment needed, appropriate, link function just used define nonlinear relationship actual response mean \\(\\eta\\) linear predictor. , back-transformed parameter already mean.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"insects","dir":"Articles","previous_headings":"Bias adjustment > Response transformations vs. link functions","what":"InsectSprays example","title":"Transformations and link functions in emmeans","text":"illustrate , consider InsectSprays data datasets package. response variable count, one treatment, spray used. Let us model count Poisson variable (default) log link; obtain EMMs, without bias adjustment results computed bias adjustment, default. try get exactly results, plus warning message says bias adjustment disabled. ? ordinary GLM like , already modeling mean counts, link function response transformation , just part relationship specifying linear predictor mean. Given simple structure dataset, can verify noting estimates correspond examply simple observed mean counts: point GLM additive error term, model already formulated terms mean, generalized mean. (can enable bias-adjustment computations specifying valid sigma value; .) Note , generalized linear mixed model, including generalized estimating equations , additive random components involved, bias adjustment becomes appropriate.","code":"ismod <- glm(count ~ spray, data = InsectSprays, family = poisson()) emmeans(ismod, \"spray\", type = \"response\") ##  spray  rate    SE  df asymp.LCL asymp.UCL ##  A     14.50 1.099 Inf     12.50     16.82 ##  B     15.33 1.130 Inf     13.27     17.72 ##  C      2.08 0.417 Inf      1.41      3.08 ##  D      4.92 0.640 Inf      3.81      6.35 ##  E      3.50 0.540 Inf      2.59      4.74 ##  F     16.67 1.179 Inf     14.51     19.14 ##  ## Confidence level used: 0.95  ## Intervals are back-transformed from the log scale emmeans(ismod, \"spray\", type = \"response\", bias.adj = TRUE) with(InsectSprays, tapply(count, spray, mean)) ##         A         B         C         D         E         F  ## 14.500000 15.333333  2.083333  4.916667  3.500000 16.666667"},{"path":"https://rvlenth.github.io/emmeans/articles/transformations.html","id":"cbpp","dir":"Articles","previous_headings":"Bias adjustment > Response transformations vs. link functions","what":"CBPP example","title":"Transformations and link functions in emmeans","text":"Consider example adapted help page lme4::cbpp. Contagious bovine pleuropneumonia (CBPP) disease African cattle, dataset contains data incidence CBPP several herds cattle four time periods. fit mixed model accounts herd variations well overdispersion (variations larger expected simple binomial model): summary reflects back-transformed estimates, bias adjustment. However, model estimates two independent sources random variation probably taken account: Notably, -dispersion SD considerably greater herd SD. Suppose want estimate marginal probabilities CBPP incidence, averaged herds -dispersion variations. purpose, need combined effect variations; compute overall SD via Pythagorean theorem: Accordingly, bias-adjusted estimates marginal probabilities: estimates somewhat larger unadjusted estimates (actually, estimates greater 0.5 adjusted downward). adjusted estimates appropriate describing marginal incidence CBPP herds. fact, estimates fairly close obtained directly incidences data: Left exercise: Revisit InsectSprays example, (using similar methods ) create unit variable fit -dispersion model. Compare results without bias adjustment, evaluate results earlier results. simpler CBPP example one random effect. Back Contents Index vignette topics","code":"require(lme4) cbpp <- transform(cbpp, unit = 1:nrow(cbpp)) cbpp.glmer <- glmer(cbind(incidence, size - incidence) ~ period +                            (1 | herd) +  (1 | unit),                     family = binomial, data = cbpp)  emm <- emmeans(cbpp.glmer, \"period\") summary(emm, type = \"response\") ##  period   prob     SE  df asymp.LCL asymp.UCL ##  1      0.1824 0.0442 Inf    0.1109    0.2852 ##  2      0.0614 0.0230 Inf    0.0290    0.1252 ##  3      0.0558 0.0220 Inf    0.0254    0.1182 ##  4      0.0334 0.0172 Inf    0.0120    0.0894 ##  ## Confidence level used: 0.95  ## Intervals are back-transformed from the logit scale lme4::VarCorr(cbpp.glmer) ##  Groups Name        Std.Dev. ##  unit   (Intercept) 0.89107  ##  herd   (Intercept) 0.18396 total.SD = sqrt(0.89107^2 + 0.18396^2) summary(emm, type = \"response\", bias.adjust = TRUE, sigma = total.SD) ##  period   prob     SE  df asymp.LCL asymp.UCL ##  1      0.2216 0.0462 Inf    0.1426     0.321 ##  2      0.0823 0.0292 Inf    0.0400     0.159 ##  3      0.0751 0.0282 Inf    0.0351     0.151 ##  4      0.0458 0.0230 Inf    0.0168     0.117 ##  ## Confidence level used: 0.95  ## Intervals are back-transformed from the logit scale  ## Bias adjustment applied based on sigma = 0.90986 cases <- with(cbpp, tapply(incidence, period, sum)) trials <- with(cbpp, tapply(size, period, sum)) cases / trials ##          1          2          3          4  ## 0.21942446 0.08018868 0.07106599 0.04516129"},{"path":"https://rvlenth.github.io/emmeans/articles/utilities.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"Utilities and options for emmeans","text":"Updating emmGrid object Setting viewing defaults Optimal digits display Startup options Combining subsetting emmGrid objects Accessing results use elsewhere Adding grouping factors Re-labeling re-leveling emmGrid Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/utilities.html","id":"update","dir":"Articles","previous_headings":"","what":"Updating an emmGrid object","title":"Utilities and options for emmeans","text":"Several internal settings saved functions like ref_grid(), emmeans(), contrast(), etc. run. settings can manipulated via update() method emmGrids. illustrate, consider pigs dataset model yet : see confidence intervals tests, default. happens result internal settings pigs.emm.s passed summary() object displayed. going work object lot, might want change internal settings rather rely explicitly calling summary() several arguments. , just update internal settings desired; example: Note adding calc, set default calculate display sample size object summarized. See help(\"update.emmGrid\") details keywords can changed. Mostly, names arguments functions construct objects. course, can always get want via calls test(), confint() summary() appropriate arguments. update() function useful sophisticated manipulations objects, called implicitly via ... options argument emmeans() functions. options passed update() just object returned. example, done update within emmeans() call follows (results shown ): Back contents","code":"pigs.lm <- lm(log(conc) ~ source + factor(percent), data = pigs) pigs.emm <- emmeans(pigs.lm, \"source\") pigs.emm ##  source emmean     SE df lower.CL upper.CL ##  fish     3.39 0.0367 23     3.32     3.47 ##  soy      3.67 0.0374 23     3.59     3.74 ##  skim     3.80 0.0394 23     3.72     3.88 ##  ## Results are averaged over the levels of: percent  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95 pigs.emm.s <- update(pigs.emm, infer = c(TRUE, TRUE), null = log(35),                      calc = c(n = \".wgt.\")) pigs.emm.s ##  source emmean     SE df  n lower.CL upper.CL null t.ratio p.value ##  fish     3.39 0.0367 23 10     3.32     3.47 3.56  -4.385  0.0002 ##  soy      3.67 0.0374 23 10     3.59     3.74 3.56   2.988  0.0066 ##  skim     3.80 0.0394 23  9     3.72     3.88 3.56   6.130  <.0001 ##  ## Results are averaged over the levels of: percent  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95 emmeans(pigs.lm, \"source\", infer = c(TRUE, TRUE), null = log(35),         calc = c(n = \".wgt.\"))"},{"path":"https://rvlenth.github.io/emmeans/articles/utilities.html","id":"options","dir":"Articles","previous_headings":"","what":"Setting options","title":"Utilities and options for emmeans","text":"Speaking options argument, note default emmeans() options = get_emm_option(\"emmeans\"). Let’s see : , default, confidence intervals, tests, displayed result summarized. reverse true results contrast() (also default pairs() calls contrast()): also defaults newly constructed reference grid: default display neither intervals tests summarizing. addition, flag .new.rg set TRUE, one sees str() listing rather summary default object simply shown typing name console.","code":"get_emm_option(\"emmeans\") ## $infer ## [1]  TRUE FALSE get_emm_option(\"contrast\") ## $infer ## [1] FALSE  TRUE get_emm_option(\"ref_grid\") ## $is.new.rg ## [1] TRUE ##  ## $infer ## [1] FALSE FALSE"},{"path":"https://rvlenth.github.io/emmeans/articles/utilities.html","id":"defaults","dir":"Articles","previous_headings":"Setting options","what":"Setting and viewing defaults","title":"Utilities and options for emmeans","text":"user may preferences. may want see intervals tests whenever contrasts produced; perhaps also wants always default response scale transformations links present. can change defaults setting corresponding options; done via emm_options() function: Now, new emmeans() results contrasts follow new defaults: Observe contrasts “inherited” type = \"response\" default EMMs. NOTE: Setting options change existing emmGrid objects displayed; affects ones constructed future. one option – summary – overrides display defaults existing future objects. example, specifying emm_options(summary = list(infer = c(TRUE, TRUE))) result intervals tests displayed, regardless internal defaults, unless infer explicitly specified call summary(). temporarily revert factory defaults single call emmeans() contrast() pairs(), specify options = NULL call. reset everything factory defaults (presently), null-emmeans package options:","code":"emm_options(emmeans = list(type = \"response\"),             contrast = list(infer = c(TRUE, TRUE))) pigs.anal.p <- emmeans(pigs.lm, consec ~ percent) pigs.anal.p ## $emmeans ##  percent response   SE df lower.CL upper.CL ##        9     31.4 1.28 23     28.8     34.1 ##       12     37.5 1.44 23     34.7     40.6 ##       15     39.0 1.70 23     35.6     42.7 ##       18     42.3 2.24 23     37.9     47.2 ##  ## Results are averaged over the levels of: source  ## Confidence level used: 0.95  ## Intervals are back-transformed from the log scale  ##  ## $contrasts ##  contrast              ratio     SE df lower.CL upper.CL null t.ratio p.value ##  percent12 / percent9   1.20 0.0671 23    1.038     1.38    1   3.202  0.0110 ##  percent15 / percent12  1.04 0.0604 23    0.896     1.20    1   0.650  0.8613 ##  percent18 / percent15  1.09 0.0750 23    0.911     1.29    1   1.194  0.5201 ##  ## Results are averaged over the levels of: source  ## Confidence level used: 0.95  ## Conf-level adjustment: mvt method for 3 estimates  ## Intervals are back-transformed from the log scale  ## P value adjustment: mvt method for 3 tests  ## Tests are performed on the log scale options(emmeans = NULL)"},{"path":"https://rvlenth.github.io/emmeans/articles/utilities.html","id":"digits","dir":"Articles","previous_headings":"Setting options","what":"Optimal digits to display","title":"Utilities and options for emmeans","text":"emmGrid object summarized displayed, factory default display just enough digits justified standard errors HPD intervals estimates displayed. may use \"opt.digits\" option change . TRUE (default), display enough digits justified (least 3). set FALSE, number digits set using R system’s default, getOption(\"digits\"); often much precision justified. illustrate, summary pigs.emm displayed without optimizing digits. Compare first summary vignette. way, setting option round calculated values computed summary.emmGrid() saved summary)emm object; simply controls precision displayed print.summary_emm().","code":"emm_options(opt.digits = FALSE) pigs.emm ##  source   emmean         SE df lower.CL upper.CL ##  fish   3.394492 0.03668122 23 3.318612 3.470373 ##  soy    3.667260 0.03744798 23 3.589793 3.744727 ##  skim   3.796770 0.03938283 23 3.715300 3.878240 ##  ## Results are averaged over the levels of: percent  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95 emm_options(opt.digits = TRUE)  # revert to optimal digits"},{"path":"https://rvlenth.github.io/emmeans/articles/utilities.html","id":"startup","dir":"Articles","previous_headings":"Setting options","what":"Startup options","title":"Utilities and options for emmeans","text":"options accessed emm_options() get_emm_option() stored list named emmeans within R’s options environment. Therefore, desire options defaults provided regular basis, can easily arranged specifying startup script R. example, want default Satterthwaite degrees freedom lmer models, display confidence intervals rather tests contrasts, .Rprofile file contain line Back contents","code":"options(emmeans = list(lmer.df = \"satterthwaite\",                         contrast = list(infer = c(TRUE, FALSE))))"},{"path":"https://rvlenth.github.io/emmeans/articles/utilities.html","id":"rbind","dir":"Articles","previous_headings":"","what":"Combining and subsetting emmGrid objects","title":"Utilities and options for emmeans","text":"Two emmGrid objects may combined using rbind() + methods. common reason (perhaps good reason) combine EMMs contrasts one family purposes applying multiplicity adjustment tests intervals. user may want combine three pairwise comparisons sources three comparisons consecutive percents single family six tests suitable multiplicity adjustment. done quite simply: default adjustment \"bonferroni\"; specified something different via adjust argument. equivalent way combine emmGrids via addition operator. options may provided update(). , combine results family ask “exact” multiplicity adjustment. Also evident comparing results settings obtained first object combined. second output, combined reverse order, get confidence intervals tests, transformation response scale.","code":"rbind(pairs(pigs.emm.s), pigs.anal.p[[2]]) ##  contrast              estimate     SE df t.ratio p.value ##  fish - soy             -0.2728 0.0529 23  -5.153  0.0002 ##  fish - skim            -0.4023 0.0542 23  -7.428  <.0001 ##  soy - skim             -0.1295 0.0530 23  -2.442  0.1364 ##  percent12 - percent9    0.1796 0.0561 23   3.202  0.0238 ##  percent15 - percent12   0.0378 0.0582 23   0.650  1.0000 ##  percent18 - percent15   0.0825 0.0691 23   1.194  1.0000 ##  ## Results are averaged over some or all of the levels of: percent, source  ## Results are given on the log (not the response) scale.  ## P value adjustment: bonferroni method for 6 tests update(pigs.anal.p[[2]] + pairs(pigs.emm.s), adjust = \"mvt\") ##  contrast              ratio     SE df lower.CL upper.CL null t.ratio p.value ##  percent12 / percent9  1.197 0.0671 23    1.022    1.402    1   3.202  0.0213 ##  percent15 / percent12 1.039 0.0604 23    0.881    1.224    1   0.650  0.9680 ##  percent18 / percent15 1.086 0.0750 23    0.894    1.320    1   1.194  0.7306 ##  fish / soy            0.761 0.0403 23    0.656    0.884    1  -5.153  0.0002 ##  fish / skim           0.669 0.0362 23    0.574    0.779    1  -7.428  <.0001 ##  soy / skim            0.879 0.0466 23    0.756    1.020    1  -2.442  0.1111 ##  ## Results are averaged over some or all of the levels of: source, percent  ## Confidence level used: 0.95  ## Conf-level adjustment: mvt method for 6 estimates  ## Intervals are back-transformed from the log scale  ## P value adjustment: mvt method for 6 tests  ## Tests are performed on the log scale"},{"path":"https://rvlenth.github.io/emmeans/articles/utilities.html","id":"brackets","dir":"Articles","previous_headings":"","what":"Utilities and options for emmeans","title":"Utilities and options for emmeans","text":"subset emmGrid object, just use subscripting operator []. instance,","code":"pigs.emm[2:3] ##  source emmean     SE df lower.CL upper.CL ##  soy      3.67 0.0374 23     3.59     3.74 ##  skim     3.80 0.0394 23     3.72     3.88 ##  ## Results are averaged over the levels of: percent  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/utilities.html","id":"data","dir":"Articles","previous_headings":"","what":"Accessing results to use elsewhere","title":"Utilities and options for emmeans","text":"Sometimes, users want use results analysis (say, emmeans() call) computations. summary() method creates summary_emm object inherits data.frame class; one may use variables therein just data frame. emmGrid object internal structure can’t directly access values see displayed. follow-computations needed, use summary() (confint() test()), creates summary_emm object inherits data.frame – making possible access values. illustration, let’s add widths confidence intervals example. way, values stored internally kept full precision, typically displayed: want display digits, specify using print method: Back contents","code":"CIs <- confint(pigs.emm) CIs$CI.width <- with(CIs, upper.CL - lower.CL) CIs ##  source emmean     SE df lower.CL upper.CL CI.width ##  fish     3.39 0.0367 23     3.32     3.47    0.152 ##  soy      3.67 0.0374 23     3.59     3.74    0.155 ##  skim     3.80 0.0394 23     3.72     3.88    0.163 ##  ## Results are averaged over the levels of: percent  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95 CIs$emmean ## [1] 3.394492 3.667260 3.796770 print(CIs, digits = 5) ##  source emmean       SE df lower.CL upper.CL CI.width ##  fish   3.3945 0.036681 23   3.3186   3.4704  0.15176 ##  soy    3.6673 0.037448 23   3.5898   3.7447  0.15493 ##  skim   3.7968 0.039383 23   3.7153   3.8782  0.16294 ##  ## Results are averaged over the levels of: percent  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/utilities.html","id":"groups","dir":"Articles","previous_headings":"","what":"Adding grouping factors","title":"Utilities and options for emmeans","text":"Sometimes, users want group levels factor smaller number groups. groups may , say, averaged separately compared, used factor. add_grouping() function serves purpose. function takes four arguments: object, name grouping factor created, name reference factor grouped, vector level names grouping factor corresponding levels reference factor. Suppose example want distinguish animal non-animal sources protein pigs example: Note new object nesting structure (see “messy-data” vignette), reference factor nested new grouping factor. Now can obtain means comparisons group Back contents","code":"pigs.emm.ss <- add_grouping(pigs.emm.s, \"type\", \"source\",                             c(\"animal\", \"vegetable\", \"animal\")) str(pigs.emm.ss) ## 'emmGrid' object with variables: ##     source = fish, soy, skim ##     type = animal, vegetable ## Nesting structure:  source %in% type ## Transformation: \"log\" emmeans(pigs.emm.ss, pairwise ~ type) ## $emmeans ##  type      emmean     SE df  n lower.CL upper.CL ##  animal      3.60 0.0267 23 19     3.54     3.65 ##  vegetable   3.67 0.0374 23 10     3.59     3.74 ##  ## Results are averaged over the levels of: percent, source  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95  ##  ## $contrasts ##  contrast           estimate     SE df t.ratio p.value ##  animal - vegetable  -0.0716 0.0455 23  -1.573  0.1295 ##  ## Results are averaged over the levels of: percent, source  ## Results are given on the log (not the response) scale."},{"path":"https://rvlenth.github.io/emmeans/articles/utilities.html","id":"relevel","dir":"Articles","previous_headings":"","what":"Re-labeling or re-leveling an emmGrid","title":"Utilities and options for emmeans","text":"Sometimes desirable re-label rows emmGrid, cast terms factor(s). can done via levels argument update(). example, sometimes fitted model treatment factor comprises combinations factors. subsequent analysis, may well want break individual factors’ contributions. Consider, example, warpbreaks data provided R. define single factor fit non homogeneous-variance model: now want re-cast emmGrid one separate factors wool tension. can follows: now can various contrasts involving separate factors: Note: re-leveling one factor, careful anticipate levels expanded using expand.grid(): first factor list varies fastest last varies slowest. case example, others, may . levels treat ordered .L, .M, .H, B.L, B.M, B.H, specify levels tension first levels wool second. Back contents Index vignette topics","code":"warp <- transform(warpbreaks, treat = interaction(wool, tension)) library(nlme) warp.gls <- gls(breaks ~ treat, weights = varIdent(form = ~ 1|treat), data = warp) ( warp.emm <- emmeans(warp.gls, \"treat\") ) ##  treat emmean   SE   df lower.CL upper.CL ##  A.L     44.6 6.03 8.02     30.7     58.5 ##  B.L     28.2 3.29 8.00     20.6     35.8 ##  A.M     24.0 2.89 8.00     17.3     30.7 ##  B.M     28.8 3.14 8.00     21.5     36.0 ##  A.H     24.6 3.42 8.00     16.7     32.5 ##  B.H     18.8 1.63 8.00     15.0     22.5 ##  ## Degrees-of-freedom method: satterthwaite  ## Confidence level used: 0.95 warp.fac <- update(warp.emm, levels = list(                 wool = c(\"A\", \"B\"), tension = c(\"L\", \"M\", \"H\"))) str(warp.fac) ## 'emmGrid' object with variables: ##     wool = A, B ##     tension = L, M, H contrast(warp.fac, \"consec\", by = \"wool\") ## wool = A: ##  contrast estimate   SE   df t.ratio p.value ##  M - L     -20.556 6.69 11.5  -3.074  0.0203 ##  H - M       0.556 4.48 15.6   0.124  0.9899 ##  ## wool = B: ##  contrast estimate   SE   df t.ratio p.value ##  M - L       0.556 4.55 16.0   0.122  0.9881 ##  H - M     -10.000 3.54 12.0  -2.824  0.0269 ##  ## Degrees-of-freedom method: satterthwaite  ## P value adjustment: mvt method for 2 tests"},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"a","dir":"Articles","previous_headings":"","what":"A","title":"Index of vignette topics","text":"add_grouping() addl.vars comparisons: pairwise confidence-intervals: adjust vs. cross.adjust Adjusted means Adjusted R-squared afex_aov objects Alias matrix Analysis subsets data versus post hoc comparisons Type III aovList objects appx-satterthwaite method ... Passed ref_grid() models: S sophisticated: bayesxtra ASA Statement P values Asymptotic tests ATOM averaging models Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"b","dir":"Articles","previous_headings":"","what":"B","title":"Index of vignette topics","text":"Back-transforming Balanced allocation Bayes factor models: S sophisticated: mcmc bayesplot package bayestestR package Beta regression betareg models link functions vs. response transformations Bayesian models GLMMs GEE models back-transforming use random slopes Bonferroni adjustment boot-satterthwaite method Brackets ([ ] [[ ]] operators) brmsfit objects Adjusting across groups Identical comparisons Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"c","dir":"Articles","previous_headings":"","what":"C","title":"Index of vignette topics","text":"Causal inference cld() clm models coda package coef() Cohen’s d Compact letter displays Derivation Back-transforming Displaying groups Displaying P values arrows determined logs Obtaining differences rather ratios overlapping CIs Comparisons result (nothing) Overlapping confint() Confounded effects Confounding consec contrasts Constrained marginal means Consultants Containment d.f. adjust Changing defaults combine interaction Linear functions confidence-intervals: simple interactions: simple contrasts Custom Formula Multivariate Pairwise Polynomial transformations Controlled experiments Count regression Counterfactuals cov.reduce Adjusted cov.keep cov.reduce Derived emmeans() doesn’t work Interacting factors Mediating cross-group comparisons cross.adjust Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"d","dir":"Articles","previous_headings":"","what":"D","title":"Index of vignette topics","text":"Infinite Displaying digits Digits, optimizing Dunnett method Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"e","dir":"Articles","previous_headings":"","what":"E","title":"Index of vignette topics","text":"eff contrasts eff_size() Effect size Arguments returned value Communicating recover_data() Dispatching Hook functions lqs objects rsm objects emm_list object emm_options() .emmc functions Exporting extensions Quick-start guide underlying model Arguments passed ref_grid() Changing defaults Fastest way get wrong answers Surprising results basics: weights messy-data: weights transformations Accessing data Combining subsetting Modifying Setting defaults basics: emmip basics: plots interactions: factors nested factors Projecting submodel ? interactions: covariates interactions: oranges estHook Estimability Estimability issues Estimable functions Definition Demonstrated Manually computed Reference grid vs. ordinary marginal means auto.noise Bayesian model sophisticated: mcmc transformations: cbpp ChickWeight cows feedlot interactions: covariates transformations: stdize framing Gamma regression InsectSprays Insurance Insurance claims (SAS) Logistic regression lqs objects MOats basics: depcovs messy-data: nuis.example Multivariate Nested fixed effects counterfactuals transformations: links transformations: trangraph submodel weights Oats comparisons: formulas interactions: oranges Ordinal model basics: pigs confidence-intervals: summary transformations: altscale transformations: overview transformations: pigs-biasadj rlm objects Robust regression Split-plot experiment Unbalanced data confidence-intervals: cross-adjust transformations: tranlink utilities: relevel Welch’s t comparisons wine Foundations Reliance model Experimental versus observational data Exporting output Exports useful developers Restrictions Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"f","dir":"Articles","previous_headings":"","what":"F","title":"Index of vignette topics","text":"vs. pairwise comparisons Role post hoc tests Mediating Formatting results Foundations EMMs Frequently asked questions Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"g","dir":"Articles","previous_headings":"","what":"G","title":"Index of vignette topics","text":"G-Computation gam models gamlss models GEE models Generalized additive models Generalized linear models Geometric means Get model right first get_emm_option() basics: ggplot messy-data: cows GIGO (garbage , garbage ) glmxxx models gls models Graphical displays Grouping factors Grouping separate sets Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"h","dir":"Articles","previous_headings":"","what":"H","title":"Index of vignette topics","text":"Hook functions Hotelling’s \\(T^2\\) hpd.summary() hurdle models Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"i","dir":"Articles","previous_headings":"","what":"I","title":"Index of vignette topics","text":"Indicator variables Infinite degrees freedom Interaction-style plots Analysis Contrasts Covariate factors Implied Plotting Possible inappropriateness marginal means inverse() Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"j","dir":"Articles","previous_headings":"","what":"J","title":"Index of vignette topics","text":"joint confidence-intervals: joint_tests Confounded effects interactions: contrasts submodel = \"type2\" Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"k","dir":"Articles","previous_headings":"","what":"K","title":"Index of vignette topics","text":"kable Kenward-Roger d.f. Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"l","dir":"Articles","previous_headings":"","what":"L","title":"Index of vignette topics","text":"Changing Large models Latin squares Least-squares means Changing Linear functions Link functions lme models models: L sophisticated: lmer System options Non-logit links Odds ratios Risk ratios Surprising results protected Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"m","dir":"Articles","previous_headings":"","what":"M","title":"Index of vignette topics","text":"make.tran() mcmc objects Generalized Weighted Mediating covariates Limiting mira models misc attribute argument Missing cells mlm models mmer models Get right first basics: models FAQs: fastest Importance getting right Model averaging pigs example Response transformation Modelling Constrained Large Quick reference Unsupported Multi-factor studies Multinomial models Multiple imputation Multiplicity adjustments Multivariate contrasts basics: multiv interactions: oranges models: M submodel Multivariate t (\"mvt\") adjustment mvcontrast() mvtnorm package Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"n","dir":"Articles","previous_headings":"","what":"N","title":"Index of vignette topics","text":"NAs output Auto-detection Creating Non-estimability non.nuisance NonEst values (nothing) output nuisance Nuisance factors Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"o","dir":"Articles","previous_headings":"","what":"O","title":"Index of vignette topics","text":"basics: weights messy-data: issues Observational versus experimental data wanted differences Models offsets offset() term vs. offset argument model one mean opt.digits option Startup Latent scale Linear-predictor scale models: O prob mean.class sophisticated: ordinal Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"p","dir":"Articles","previous_headings":"","what":"P","title":"Index of vignette topics","text":"Adjusted Adjustment ignored Interpreting pairs() avoid Matrix displays pairwise contrasts Pairwise P-value plots params Percentage differences nested factors plot.emmGrid() confidence intervals EMMs Enhancing ggplot2 functions Interaction-style + operator Surprising results polreg models Polynomial regression Instead Welch’s t postGridHook Practices, recommended Displaying results digits predictions: bayes sophisticated: predict-mcmc Error SD graphics Particular strata Posterior predictive distribution Reference grid Total SD print.summary_emm() Odds risk ratios pwpm() pwpp() Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"q","dir":"Articles","previous_headings":"","what":"Q","title":"Index of vignette topics","text":"qdrg() Quadratic terms Quick-start guide Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"r","dir":"Articles","previous_headings":"","what":"R","title":"Index of vignette topics","text":"R-squared Accessing levels Bias adjustment Rank deficiency wanted differences rbind() Re-labeling Recommended practices Communicating emm_basis() data params arguments Dispatching Error handling lqs objects rsm objects frame argument basics: plot.emmGrid basics: RG mult.name nesting offset regrid argument Covariates Defined Indicator variables Predictions Prediction Region practical equivalence Registering recover_data emm_basis methods regrid argument probit lon-logit models regrid vs. type obtain risk ratios transform = \"log\" Residual plots Response scale Response transformations revpairwise contrasts rg.limit option Risk ratios RMarkdown ROPE rsm package rstanarm Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"s","dir":"Articles","previous_headings":"","what":"S","title":"Index of vignette topics","text":"Sample size, displaying Sandwich estimators models: K models: L \"scale\" type scale() Selecting results Sidak adjustment Assessing simple = \"\" confidence-intervals: simple FAQs: interactions interactions: simple Simpson’s paradox Formula Standardized response stanreg objects * gazing (star gazing) Startup options Statistical consultants Statistics hard str() \"minimal\" \"type2\" multivariate model messy-data: submodels xplanations: submodels Subsets data adjust basics: emmobj confidence-intervals: summary models: S Calculated columns confidence-intervals: summary HPD intervals hpd.summary() comparisons: pairwise confidence-intervals: summary Show sample size type = \"unlink\" data frame Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"t","dir":"Articles","previous_headings":"","what":"T","title":"Index of vignette topics","text":"t tests vs. z tests delta joint = TRUE Equivalence Noninferiority Nonzero null One- two-sided means Adding fact Auto-detected Back-transforming Bias adjustment Custom faking Faking log transformation Graphical display link function Log Overview Percent difference Re-gridding Response versus link functions scale() Standardizing Timing everything Estimating comparing trt.vs.ctrl contrasts Ignored changed type type = \"response\" type = \"scale\" Type II analysis confidence-intervals: joint confidence-intervals: joint_tests Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"u","dir":"Articles","previous_headings":"","what":"U","title":"Index of vignette topics","text":"Unadjusted tests tran Using results Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"v","dir":"Articles","previous_headings":"","what":"V","title":"Index of vignette topics","text":"Variables predictors vcov. vcovHook Comparisons Confidence intervals tests Explanations supplement Extending emmeans FAQS Interactions Messy data Models Predictions Sophisticated models Transformations link functions Utilities options Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"w","dir":"Articles","previous_headings":"","what":"W","title":"Index of vignette topics","text":"Equal weights weights Example wt.nuis Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"x","dir":"Articles","previous_headings":"","what":"X","title":"Index of vignette topics","text":"xtable method Back top","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/vignette-topics.html","id":"z","dir":"Articles","previous_headings":"","what":"Z","title":"Index of vignette topics","text":"vs. t tests zeroinfl models Back top Index generated vigindex package.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xplanations.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"Explanations supplement","text":"Sub-models Comparison arrows Confounded effects joint tests Intricacies offsets","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xplanations.html","id":"submodels","dir":"Articles","previous_headings":"","what":"Sub-models","title":"Explanations supplement","text":"Estimated marginal means (EMMs) statistics computed emmeans package model-based: depend model fitted data. section discuss provision whereby different underlying model may considered. submodel option update() can project EMMs statistics alternative universe simpler version model fitted data. Another way looking constrains certain external effects zero – opposed averaging otherwise done marginal means. Two things know getting details: submodel option uses information fixed-effects portion model matrix model classes supported submodel option. Now details. Suppose fixed-effects model matrix \\(X\\), let \\(X_1\\) denote sub-matrix \\(X\\) whose columns correspond specified sub-model. (Note: weights, use \\(X = W^{1/2}X^*\\), \\(X^*\\) model matrix without weights incorporated.) trick use called alias matrix: \\(= (X_1'X_1)^-X_1'X\\) \\(Z^-\\) denotes generalized inverse \\(Z\\). can shown \\((X_1'X_1)^-X_1' = (X'X)^-X'\\); thus, ordinary fixed-effects regression model, \\(b_1 = Ab\\) \\(b_1\\) \\(b\\) denote regression coefficients sub-model full model, respectively. Thus, given matrix \\(L\\) \\(Lb\\) provides estimates interest full model, corresponding estimates sub-model \\(L_1b_1\\), \\(L_1\\) sub-matrix \\(L\\) consisting columns corresponding columns \\(X_1\\). Moreover, \\(L_1b_1 = L_1(Ab) = (L_1A)b\\); , can replace \\(L\\) \\(L_1A\\) obtain estimates sub-model. ’s update(..., submodel = ...) . intuitive observations: Consider excluded effects, \\(X_2\\), consisting columns \\(X\\) \\(X_1\\). corresponding columns alias matrix regression coefficients treating \\(X_2\\) response \\(X_1\\) predictors. Thus, obtain predictions via aliases, predicting effects \\(X_2\\) based \\(X_1\\). columns new linear predictor \\(\\tilde L = L_1A\\) depend columns \\(L_1\\), hence columns \\(L\\). three points provide three ways saying nearly thing, namely excluding effects \\(X_2\\). Note rank-deficient situation, different possible generalized inverses, (1), \\(\\) unique. However, predictions (2) unique. ordinary regression models, (1), (2), (3) apply predictions re-fitting model model matrix \\(X_1\\); however, generalized linear models, mixed models, etc., re-fitting likely produce somewhat different results. fitting models involves iterative weighting, re-fitted models probably weights. However, point (3) still hold: predictions obtained submodel involve columns \\(L_1\\) hence constrain effects outside sub-model zero. Therefore, really matters get correct estimates stated sub-model, user actually fit sub-model unless full model ordinary linear regression. technicality: writers define alias matrix \\((X_1'X_1)^-X_1'X_2\\), \\(X_2\\) denotes part \\(X\\) excludes columns \\(X_1\\). including columns \\(X\\) just makes notation simple; \\(X_1\\) portion \\(X\\) just reduces identity (least case \\(X_1\\) full-rank). word computation: Like many matrix expressions, compute \\(\\) directly shown. Instead, use QR decomposition \\(X_1\\), obtainable via R call Z <- qr(X1). alias matrix computed via <- qr.coef(Z, X). fact, nothing changes use just \\(R\\) portion \\(X = QR\\), saving us memory computational effort. exported function .cmpMM() extracts \\(R\\) matrix, taking care pivoting might occurred. lm object, QR decomposition \\(X\\) already saved slot. qr.coef() function works just fine full-rank rank-deficient cases, latter situation, elements NA; correspond “excluded” predictors, another way saying constraining regression coefficients zero. Thus, can easily clean via [.na()] <- 0. specify submodel = \"minimal\", software figures sub-model extracting terms involving factors already averaged . user specifies submodel = \"type2\", additional step performed: Let \\(X_1\\) highest-order effect minimal model, \\(X_0\\) denote matrix columns \\(X\\) whose columns contain effect \\(X_1\\). replace \\(Z\\) QR decomposition \\([- X_0(X_0'X_0)^-X_0']X_1^*\\). projects \\(X_1^*\\) onto null space \\(X_0\\). net result obtain estimates just \\(X_1^*\\) effects, adjusting effects don’t contain (including intercept present). estimates limited use data description, provide kind “Type II” analysis used conjunction joint_tests(). \"type2\" calculations parallel documented SAS obtaining type II estimable functions SAS PROC GLM. However, (well car::Anova()) define “contained” effects differently SAS, treating covariates differently factors.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xplanations.html","id":"mult-submodel","dir":"Articles","previous_headings":"Sub-models","what":"A note on multivariate models","title":"Explanations supplement","text":"Recall emmeans generates constructed factor levels multivariate response. factor (factors) completely ignored sub-model calculations. \\(X\\) \\(X_1\\) matrices described involve predictors right-hand side model equation . multivariate response “factor” implicitly interacts everything right-hand-side model; true sub-model. possible consider sub-models terms omitted among multivariate interactions (note also impossible fit multivariate sub-model excludes interactions). way remove consideration multivariate effects average via call emmeans(). Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xplanations.html","id":"arrows","dir":"Articles","previous_headings":"","what":"Comparison arrows","title":"Explanations supplement","text":"plot() method emmGrid objects offers option comparisons = TRUE. used, software attempts construct “comparison arrows” whereby two estimated marginal means (EMMs) differ significantly , , respective comparison arrows overlap. section, explain arrows obtained. First, please understand comparison arrows decidedly confidence intervals. Confidence intervals EMMs based statistical properties individual EMMs, whereas comparison arrows based statistical properties differences EMMs. Let EMMs denoted \\(m_1, m_2, ..., m_k\\). simplicity, let us assume ordered: \\(m_1 \\le m_2 \\le \\cdots \\le m_k\\). Let \\(d_{ij} = m_j - m_i\\) denote difference \\(\\)th \\(j\\)th EMM. \\((1 - \\alpha)\\) confidence interval true difference \\(\\delta_{ij} = \\mu_j - \\mu_i\\) \\[  d_{ij} - e_{ij}\\quad\\mbox{}\\quad d_{ij} + e_{ij} \\] \\(e_{ij}\\) “margin error” difference; .e., \\(e_{ij} = t\\cdot SE(d_{ij})\\) critical value \\(t\\) (equal \\(t_{\\alpha/2}\\) multiplicity adjustment used). Note \\(d_{ij}\\) statistically significant , , \\(d_{ij} > e_{ij}\\). Now, get comparison arrows? arrows plotted origins \\(m_i\\); arrow length \\(L_i\\) pointing left, arrow length \\(R_i\\) pointing right. compare EMMs \\(m_i\\) \\(m_j\\) (remembering supposing \\(m_i \\le m_j\\)), propose look see arrows extending right \\(m_i\\) left \\(m_j\\) overlap . , ideally, want overlap identified statistical non-significance, want \\[    R_i + L_j = e_{ij}   \\quad\\mbox{} < j \\] can , two arrows overlap , , \\(d_{ij} < e_{ij}\\). easy accomplish \\(e_{ij}\\) equal: just set \\(L_i = R_j = \\frac12e_{12}\\). differing \\(e_{ij}\\) values, may may even possible obtain suitable arrow lengths. code emmeans uses ad hoc weighted regression method solve equations. give greater weights cases \\(d_{ij}\\) close \\(e_{ij}\\), cases critical get lengths arrows right. regression equations solved, test make sure \\(R_i + L_j < d_{ij}\\) difference significant, \\(\\ge d_{ij}\\) . one checks fails, warning issued. ’s essence algorithm. Note, however, complications need handled: lowest EMM \\(m_1\\), \\(L_1\\) completely arbitrary right-pointing arrows compare ; fact, don’t even need display arrow. true \\(R_k\\) largest EMM \\(m_k\\). Moreover, additional unneeded arrows \\(m_i\\) equal \\(m_1\\) \\(m_k\\). Depending number \\(k\\) EMMs number tied minima maxima, system equations -determined, -determined, just right. possible solution result \\(L_i\\) \\(R_j\\) negative. result error. summary, algorithm always work (fact possible construct cases solution possible). try best can. main reason trying encourage people ever use confidence intervals \\(m_i\\) means testing comparisons \\(d_{ij}\\). almost always incorrect. better yet simply avoid using comparison arrows altogether use pwpp() pwpm() display P values directly.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xplanations.html","id":"examples-and-tests","dir":"Articles","previous_headings":"Comparison arrows","what":"Examples and tests","title":"Explanations supplement","text":"constructed example specified means somewhat unequal SEs  came pretty well. now let’s keep means SEs make correlated. correlations happen, example, designs subject effects. function used set specified intra-class correlation, treating within-subjects (split-plot) factor B -subjects (whole-plot) factor. ’ll start correlation 0.3.  intraclass correlation 0.6:  Now warning arrows don’t overlap, . can make even worse upping correlation 0.8: Now solution actually leads negative arrow lengths. happening continually reducing SE within-B comparisons keeping others . work use B variable:  Note lengths comparison arrows relatively equal within levels B. , can use pwpp() pwpm() show P values comparisons among six means:","code":"m = c(6.1, 4.5, 5.4,    6.3, 5.5, 6.7) se2 = c(.3, .4, .37,  .41, .23, .48)^2 lev = list(A = c(\"a1\",\"a2\",\"a3\"), B = c(\"b1\", \"b2\")) foo = emmobj(m, diag(se2), levels = lev, linfct = diag(6)) plot(foo, CIs = FALSE, comparisons = TRUE) mkmat <- function(V, rho = 0, indexes = list(1:3, 4:6)) {     sd = sqrt(diag(V))     for (i in indexes)         V[i,i] = (1 - rho)*diag(sd[i]^2) + rho*outer(sd[i], sd[i])     V } # Intraclass correlation = 0.3 foo3 = foo foo3@V <- mkmat(foo3@V, 0.3) plot(foo3, CIs = FALSE, comparisons = TRUE) foo6 = foo foo6@V <- mkmat(foo6@V, 0.6) plot(foo6, CIs = FALSE, comparisons = TRUE) ## Warning: Comparison discrepancy in group \"1\", a1 b1 - a2 b2: ##     Target overlap = 0.443, overlap on graph = -0.2131 foo8 = foo foo8@V <- mkmat(foo8@V, 0.8) plot(foo8, CIs = FALSE, comparisons = TRUE) ## Error: Aborted -- Some comparison arrows have negative length! ## (in group \"1\") plot(foo8, CIs = FALSE, comparisons = TRUE, by = \"B\") pwpp(foo6, sort = FALSE) pwpm(foo6) ##       a1 b1  a2 b1  a3 b1  a1 b2  a2 b2  a3 b2 ## a1 b1 [6.1] <.0001 0.1993 0.9988 0.6070 0.8972 ## a2 b1   1.6  [4.5] 0.0958 0.0208 0.2532 0.0057 ## a3 b1   0.7   -0.9  [5.4] 0.5788 0.9999 0.2641 ## a1 b2  -0.2   -1.8   -0.9  [6.3] 0.1439 0.9204 ## a2 b2   0.6   -1.0   -0.1    0.8  [5.5] 0.0245 ## a3 b2  -0.6   -2.2   -1.3   -0.4   -1.2  [6.7] ##  ## Row and column labels: A:B ## Upper triangle: P values   adjust = \"tukey\" ## Diagonal: [Estimates] (estimate)  ## Lower triangle: Comparisons (estimate)   earlier vs. later"},{"path":"https://rvlenth.github.io/emmeans/articles/xplanations.html","id":"related-reading-on-comparisons","dir":"Articles","previous_headings":"Comparison arrows","what":"Related reading on comparisons","title":"Explanations supplement","text":"following reference (well articles referenced therein) suggested relating similar issues: Franz, V.H., Loftus, G.R. (2012) Standard errors confidence intervals within-subjects designs: Generalizing Loftus Masson (1994) avoiding biases alternative accounts. Psychonomic Bulletin Review 19, 395-–404. https://doi.org/10.3758/s13423-012-0230-1 Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xplanations.html","id":"joint_tests","dir":"Articles","previous_headings":"","what":"Confounded effects in joint tests","title":"Explanations supplement","text":"design empty cells, creates estimability issues; context joint_tests(), means certain main- interaction effects estimated, leading reduced degrees freedom joint tests. Instead, estimable parts lost effects pooled together set contrasts labeled (confounded) output (long showconf = TRUE). simple illustration based warpbreaks dataset last cell removed. empty cells, 1 d.f. wool, 2 d.f. tension, 2 d.f. wool:tension, total 5 d.f. (6 cells, 6 - 1 = 5 d.f. contrasts among ). missing cell, can estimate 5 - 1 = 4 d.f. worth effects, (confounding) part accounts 2 purely main effects interaction effects. obtain extra 2 d.f.? Well, first , easy obtain joint test comparisons among cell means simply pool together contrasts tested jt, compare . , obtain estimable functions associated jt: can get joint test together via trickery: (Note: case isn’t obvious, couldn’t just pooled together F ratios effects, type-III tests necessarily independent.) now test.4 d.f. worth effects comparing cells, test.ef just effects top part jt table. can get unexplained part test.d.f.-weighted subtraction: gives us F.ratio shown (confounded) row jt results . ’s ! Back Contents","code":"options(contrasts = c(\"contr.treatment\", \"contr.poly\"))   ## ensure system default w <- warpbreaks[1:40, ]   ### no data for (wool = B, tension = H) w.lm <- lm(breaks ~ wool * tension, data = w) w.rg <- ref_grid(w.lm) (jt <- joint_tests(w.rg)) ##  model term   df1 df2 F.ratio p.value note ##  tension        1  35   6.064  0.0189    e ##  wool:tension   1  35   3.740  0.0613    e ##  (confounded)   2  35   2.266  0.1187      ##  ## e: df1 reduced due to non-estimability (test.all <- test(contrast(w.rg, \"consec\"), joint = TRUE)) ##  df1 df2 F.ratio p.value note ##    4  35   4.332  0.0060    e ##  ## e: df1 reduced due to non-estimability (ef <- attr(jt, \"est.fcns\")) ## $tension ##      (Intercept) woolB  tensionM tensionH woolB:tensionM woolB:tensionH ## [1,]           0     0 0.8944272        0      0.4472136              0 ##  ## $`wool:tension` ##      (Intercept) woolB tensionM tensionH woolB:tensionM woolB:tensionH ## [1,]           0     0        0        0              1              0 tmp <- w.rg tmp@linfct <- do.call(rbind, ef)      # combine EFs into a matrix tmp@grid <- tmp@grid[1:2, ]           # replace the @linfct and @grid slots (test.ef <- test(tmp, joint = TRUE))  #  -- that's enough to get the test ##  df1 df2 F.ratio p.value ##    2  35   6.398  0.0043 (test.all$df1 * test.all$F.ratio  -  test.ef$df1 * test.ef$F.ratio) /     (test.all$df1 - test.ef$df1) ## [1] 2.266"},{"path":"https://rvlenth.github.io/emmeans/articles/xplanations.html","id":"offsets","dir":"Articles","previous_headings":"","what":"Intricacies of offsets","title":"Explanations supplement","text":"Many model-fitting functions provide two ways specifying model offsets: model formula, separate offset argument. purpose section discuss deal emmeans, particular, decided handle differently, even though seem equivalent. illustrate, consider following two models: models specify, different ways, offset log(Holders); regression coefficients fitted values. treat two models way emmeans. mod1, offset part model formula, treated making predictions: linear prediction includes term log(Holders), regression coefficient 1. mod2, model formula include variable Holders, don’t use predictor. Instead, regard offset argument implying covariate computed advance fitting model, constrained regression coefficient 1. Let’s see plays looking reference grids: distinction fourth predictor – mod1, Holders, mod2, generated covariate named .static.offset.. (call “static” offset depend model predictors, whereas mod1 regarded dynamic offset.) either case, fourth variable set mean default. Now let’s compare EMMs: don’t get estimates. mod1 (rg1), offset added \\(\\log\\text{Holders} = \\log{364.98} \\approx 5.90\\), mod2 (rg2), added offset \\(\\text{.static.offset.} \\approx 4.90\\). Thinking , offsets logs arithmetic geometric means, respectively, Holders; fact offset logged makes EMMs differ. Poisson models, often want estimate rates rather counts; can specifying offset \\(\\log 1 = 0\\) get rate per holder: ’d get exactly estimates using rg2 cases, forcing offset zero. Finally, suppose want use different offsets age group. done follows: mod1, compute mean(Holders) separately Age: mod2, Holders considered predictor, instead need separate mean offsets: models, EMMs increase rather decrease age, reflecting larger numbers holders age increases. Back Contents Index vignette topics","code":"require(MASS) mod1 <- glm(Claims ~ District + Group + Age + offset(log(Holders)),             data = Insurance,             family = poisson) mod2 <- glm(Claims ~ District + Group + Age,             offset = log(Holders),             data = Insurance,              family = poisson) (rg1 <- ref_grid(mod1)) ## 'emmGrid' object with variables: ##     District = 1, 2, 3, 4 ##     Group = <1l, 1-1.5l, 1.5-2l, >2l ##     Age = <25, 25-29, 30-35, >35 ##     Holders = 364.98 ## Transformation: \"log\" (rg2 <- ref_grid(mod2)) ## 'emmGrid' object with variables: ##     District = 1, 2, 3, 4 ##     Group = <1l, 1-1.5l, 1.5-2l, >2l ##     Age = <25, 25-29, 30-35, >35 ##     .static.offset. = 4.9042 ## Transformation: \"log\" emmeans(rg1, \"Age\") ##  Age   emmean     SE  df asymp.LCL asymp.UCL ##  <25     4.43 0.0686 Inf      4.30      4.57 ##  25-29   4.24 0.0522 Inf      4.14      4.34 ##  30-35   4.09 0.0493 Inf      3.99      4.18 ##  >35     3.90 0.0264 Inf      3.84      3.95 ##  ## Results are averaged over the levels of: District, Group  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95 emmeans(rg2, \"Age\") ##  Age   emmean     SE  df asymp.LCL asymp.UCL ##  <25     3.44 0.0686 Inf      3.30      3.57 ##  25-29   3.25 0.0522 Inf      3.14      3.35 ##  30-35   3.09 0.0493 Inf      2.99      3.19 ##  >35     2.90 0.0264 Inf      2.85      2.95 ##  ## Results are averaged over the levels of: District, Group  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95 emmeans(rg1, \"Age\", offset = 0, type = \"response\") ##  Age    rate      SE  df asymp.LCL asymp.UCL ##  <25   0.230 0.01580 Inf     0.201     0.264 ##  25-29 0.190 0.00993 Inf     0.172     0.211 ##  30-35 0.163 0.00805 Inf     0.148     0.180 ##  >35   0.135 0.00355 Inf     0.128     0.142 ##  ## Results are averaged over the levels of: District, Group  ## Confidence level used: 0.95  ## Intervals are back-transformed from the log scale emmeans(mod1, \"Age\", cov.reduce = Holders ~ Age) ##  Age   emmean     SE  df asymp.LCL asymp.UCL ##  <25     2.80 0.0686 Inf      2.66      2.93 ##  25-29   3.32 0.0522 Inf      3.22      3.43 ##  30-35   3.42 0.0493 Inf      3.33      3.52 ##  >35     4.96 0.0264 Inf      4.91      5.01 ##  ## Results are averaged over the levels of: District, Group  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95 emmeans(mod2, \"Age\", cov.reduce = .static.offset. ~ Age) ##  Age   emmean     SE  df asymp.LCL asymp.UCL ##  <25     2.15 0.0686 Inf      2.02      2.29 ##  25-29   2.90 0.0522 Inf      2.79      3.00 ##  30-35   3.04 0.0493 Inf      2.95      3.14 ##  >35     4.58 0.0264 Inf      4.53      4.63 ##  ## Results are averaged over the levels of: District, Group  ## Results are given on the log (not the response) scale.  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"contents","dir":"Articles","previous_headings":"","what":"Contents","title":"For developers: Extending **emmeans**","text":"vignette explains developers may incorporate emmeans support packages. user looking quick way obtain results unsupported model, probably better trying use qdrg() function. Introduction Data example Supporting rlm objects Supporting lqs objects Communication methods Hook functions Exported methods emmeans Existing support rsm objects Dispatching restrictions Exporting registering methods Conclusions Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"intro","dir":"Articles","previous_headings":"","what":"Introduction","title":"For developers: Extending **emmeans**","text":"Suppose want use emmeans type model doesn’t (yet) support. , suppose developed new package fancy model-fitting function, ’d like work emmeans. can ? Well, hope emmeans designed extended. first thing look help page extending package: gives details fact need write two S3 methods, recover_data emm_basis, class object model-fitting function returns. recover_data method needed recreate dataset reference grid can identified. emm_basis method determines linear functions needed evaluate point reference grid obtain associated information—variance-covariance matrix—needed estimation testing. methods must also exported package available users. See section exporting methods details suggestions. vignette presents example suitable methods developed, discusses issues arise. Back Contents","code":"help(\"extending-emmeans\", package=\"emmeans\")"},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"dataex","dir":"Articles","previous_headings":"","what":"Data example","title":"For developers: Extending **emmeans**","text":"MASS package contains various functions robust outlier-resistant model fitting. cobble together emmeans support . first, let’s create suitable dataset (simulated two-factor experiment) testing. y values generated using predetermined means Cauchy-distributed errors. serious outliers data.","code":"fake = expand.grid(rep = 1:5, A = c(\"a1\",\"a2\"), B = c(\"b1\",\"b2\",\"b3\")) fake$y = c(11.46,12.93,11.87,11.01,11.92,17.80,13.41,13.96,14.27,15.82,            23.14,23.75,-2.09,28.43,23.01,24.11,25.51,24.11,23.95,30.37,            17.75,18.28,17.82,18.52,16.33,20.58,20.55,20.77,21.21,20.10)"},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"rlm","dir":"Articles","previous_headings":"","what":"Supporting rlm","title":"For developers: Extending **emmeans**","text":"MASS package provides rlm function fits robust-regression models using M estimation. ’ll fit model using default settings tuning parameters: first lesson learn extending emmeans sometimes, already works! works rlm objects inherit lm, supported emmeans package, rlm objects aren’t enough different create problems. Back Contents","code":"library(MASS) fake.rlm = rlm(y ~ A * B, data = fake)  library(emmeans) emmeans(fake.rlm, ~ B | A) ## A = a1: ##  B  emmean    SE df asymp.LCL asymp.UCL ##  b1   11.8 0.477 NA      10.9      12.8 ##  b2   23.3 0.477 NA      22.4      24.2 ##  b3   17.8 0.477 NA      16.9      18.7 ##  ## A = a2: ##  B  emmean    SE df asymp.LCL asymp.UCL ##  b1   14.7 0.477 NA      13.7      15.6 ##  b2   24.7 0.477 NA      23.8      25.6 ##  b3   20.6 0.477 NA      19.7      21.6 ##  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"lqs","dir":"Articles","previous_headings":"","what":"Supporting lqs objects","title":"For developers: Extending **emmeans**","text":"MASS resistant-regression functions lqs, lmsreg, ltsreg another story, however. create lqs objects extensions class, issues, including even vcov method. , really need write new methods lqs objects. First, let’s fit model.","code":"fake.lts = ltsreg(y ~ A * B, data = fake)"},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"rd-lqs","dir":"Articles","previous_headings":"Supporting lqs objects","what":"The recover_data method","title":"For developers: Extending **emmeans**","text":"usually easy matter write recover_data method. Look one lm objects: Note obtain call component call method class call, additional arguments terms component na.action. happens can access attributes exactly way lm objects; : Let’s test : recovered data excludes response variable y (owing delete.response call), fine.","code":"emmeans:::recover_data.lm ## function(object, frame = object$model, ...) { ##         fcall = object$call ##     recover_data(fcall, delete.response(terms(object)), object$na.action,  ##                  frame = frame, pwts = weights(object), ...) ## } ## <bytecode: 0x000001d47d21fb30> ## <environment: namespace:emmeans> recover_data.lqs = emmeans:::recover_data.lm rec.fake = recover_data(fake.lts) head(rec.fake) ##    A  B ## 1 a1 b1 ## 2 a1 b1 ## 3 a1 b1 ## 4 a1 b1 ## 5 a1 b1 ## 6 a2 b1"},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"rdargs","dir":"Articles","previous_headings":"Supporting lqs objects > The recover_data method","what":"Special arguments","title":"For developers: Extending **emmeans**","text":"way, two special arguments data params may handed recover_data via ref_grid emmeans related function; may need provide don’t use recover_data.call function. data argument needed cover desperate situation occurs certain kinds models underlying data information saved object—e.g., models fitted iteratively modifying data. cases, way recover data user give explicitly, recover_data just adds needed attributes . params argument needed model formula refers variables besides predictors. example, model may include spline term, knots saved user’s environment vector referred call fit model. trying recover data, try construct data frame containing variables present right-hand side model, scalars different lengths number observations, error occurs. need exclude names params reconstructing data. Many model objects contain model frame slot; example, model fitted lm(..., model = TRUE) member $model containing model frame. can useful recovering data, provided none predictors transformed (predictors transformed, original predictor values model frame ’s harder recover ). Therefore, model frame available model object, provided frame argument recover_data.call(); data = NULL, check made trms, function calls, data set frame. course, rarer case original data available model object, specify data.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"rderrs","dir":"Articles","previous_headings":"Supporting lqs objects > The recover_data method","what":"Error handling","title":"For developers: Extending **emmeans**","text":"check error conditions recover_data, simply return character string desired message, rather invoking stop. provides cleaner exit. reason whenever recover_data throws error, informative message suggesting data params provided displayed. character return value tested throws different error string message.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"ebreqs","dir":"Articles","previous_headings":"Supporting lqs objects","what":"The emm_basis method","title":"For developers: Extending **emmeans**","text":"emm_basis method four required arguments: , respectively, model object, terms component (least right-hand side model), list levels factors, grid predictor combinations specify reference grid. function must obtain six things return named list. matrix X linear functions point reference grid, regression coefficients bhat; variance-covariance matrix V; matrix nbasis non-estimable functions; function dffun(k,dfargs) computing degrees freedom linear function sum(k*bhat); list dfargs arguments pass dffun. Optionally, returned list may include model.matrix element (model matrix data compact version thereof obtained via .cmpMM()), , included, enables submodel option. write emm_basis function, examining existing methods can help; best resource predict method object question, looking carefully see predict values new set predictors (e.g., newdata predict.lm). Following advice, let’s take look :","code":"args(emmeans:::emm_basis.lm) ## function (object, trms, xlev, grid, ...)  ## NULL MASS:::predict.lqs ## function (object, newdata, na.action = na.pass, ...)  ## { ##     if (missing(newdata))  ##         return(fitted(object)) ##     Terms <- delete.response(terms(object)) ##     m <- model.frame(Terms, newdata, na.action = na.action, xlev = object$xlevels) ##     if (!is.null(cl <- attr(Terms, \"dataClasses\")))  ##         .checkMFClasses(cl, m) ##     X <- model.matrix(Terms, m, contrasts.arg = object$contrasts) ##     drop(X %*% object$coefficients) ## } ## <bytecode: 0x000001d47fe0e128> ## <environment: namespace:MASS>"},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"eblqs","dir":"Articles","previous_headings":"","what":"For developers: Extending **emmeans**","title":"For developers: Extending **emmeans**","text":"Based , listing emm_basis method lqs objects: explaining , let’s verify works: Hooray! Note results comparable fake.rlm, albeit standard errors quite bit smaller. (fact, SEs misleading; better method estimating covariances probably implemented, beyond scope vignette.) Back Contents","code":"emm_basis.lqs = function(object, trms, xlev, grid, ...) {      m = model.frame(trms, grid, na.action = na.pass, xlev = xlev)     X = model.matrix(trms, m, contrasts.arg = object$contrasts)      bhat = coef(object)      Xmat = model.matrix(trms, data=object$model)                      # 5     V = rev(object$scale)[1]^2 * solve(t(Xmat) %*% Xmat)     nbasis = matrix(NA)      dfargs = list(df = nrow(Xmat) - ncol(Xmat))     dffun = function(k, dfargs) dfargs$df     list(X = X, bhat = bhat, nbasis = nbasis, V = V,                  #10          dffun = dffun, dfargs = dfargs) } emmeans(fake.lts, ~ B | A) ## A = a1: ##  B  emmean    SE df lower.CL upper.CL ##  b1   11.9 0.228 24     11.4     12.3 ##  b2   23.1 0.228 24     22.6     23.6 ##  b3   17.8 0.228 24     17.3     18.2 ##  ## A = a2: ##  B  emmean    SE df lower.CL upper.CL ##  b1   13.9 0.228 24     13.4     14.4 ##  b2   24.1 0.228 24     23.6     24.5 ##  b3   20.5 0.228 24     20.0     21.0 ##  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"dissecting-emm_basis-lqs","dir":"Articles","previous_headings":"Supporting lqs objects","what":"Dissecting emm_basis.lqs","title":"For developers: Extending **emmeans**","text":"Let’s go listing method, line--line: Lines 2–3: Construct linear functions, X. pretty standard two-step process: First obtain model frame, m, grid predictors, pass data model.matrix create associated design matrix. promised, code essentially identical find predict.lqs. Line 4: Obtain coefficients, bhat. model objects coef method. Lines 5–6: Obtain covariance matrix, V, bhat. many models, can obtained using object’s vcov method. case. Instead, cobbled one together using inverse X’X matrix ordinary regression, variance estimate found last element scale element object. probably -estimates variances distorts covariances, robust estimators efficiency loss. Line 7: Compute basis non-estimable functions. applies possibility rank deficiency model. lqs methods don’t allow rank deficiencies, fitted model, can sure linear functions estimable; signal setting nbasis equal 1 x 1 matrix NA. rank deficiency possible, estimability package (required emmeans) provides nonest.basis function makes fairly painless—coded nbasis = estimability::nonest.basis(Xmat). subtleties need know regarding estimability. Suppose model rank-deficient, design matrix X p columns rank r < p. case, bhat length p (r), p - r elements equal NA, corresponding columns X excluded fit. Also, X p columns. words, alter throw-columns X corresponding elements bhat—even NA coefficients—essential assessing estimability. V r x r, however—covariance matrix non-excluded predictors. Lines 8–9: Obtain dffun dfargs. little awkward designed allow support mixed models, approximate methods may used obtain degrees freedom. function dffun expected two arguments: k, vector coefficients bhat, dfargs, list containing additional arguments. case (many models), degrees freedom regardless k. put required degrees freedom dfargs write dffun simply returns value. (Note: asymptotic tests CIs desired, return Inf degrees freedom.) Line 10: Return results named list. Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"communic","dir":"Articles","previous_headings":"","what":"Communication between methods","title":"For developers: Extending **emmeans**","text":"need pass information obtained recover_data() emm_basis() method, simply incorporate attr(data, \"misc\") data dataset returned recover_data(). Subsequently, attribute available emm_grid() adding misc argument.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"hooks","dir":"Articles","previous_headings":"","what":"Hook functions","title":"For developers: Extending **emmeans**","text":"linear models supported emmeans straightforward structure: Regression coefficients, covariance matrix, set linear functions define reference grid. However, complex. example clm class ordinal package, allows scale model addition location model. scale model used, scale parameters included model matrix, regression coefficients, covariance matrix, can’t just use usual matrix operations obtain estimates standard errors. facilitate using custom routines tasks, emm_basis.clm function function provided emmeans includes, misc part, names (character constants) two “hook” functions: misc$estHook name function call computing estimates, standard errors, degrees freedom (summary method); misc$vcovHook name function call obtain covariance matrix grid values (used vcov method). functions called lieu usual built-routines purposes, return appropriately sized matrices. addition, may want apply form special post-processing reference grid constructed. provide , give name function post-process object misc$postGridHook. , clm objects (well polr MASS package) serve example. allow mode specification two cases, calls post-processing. \"cum.prob\" mode uses regrid function transform linear predictor cumulative-probability scale. \"prob\" mode performs , well applying contrasts necessary convert cumulative probabilities class probabilities. Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"exported","dir":"Articles","previous_headings":"","what":"Exported methods from emmeans","title":"For developers: Extending **emmeans**","text":"package developers’ convenience, emmeans exports S3 methods recover_data /emm_basis—use methods(\"recover_data\") methods(\"emm_basis\") discover ones. may need invoke one methods perhaps make small changes—especially model-fitting algorithm makes heavy use existing model type supported emmeans. methods exported, use recover_data() .emm_basis(), run emmeans’s namespace, thus providing access available methods.. additional functions exported may useful developers. follows: emmeans::..vars(expr, retain) users package may include $ [[]] operators model formulas. need get variable names, base::.vars probably give need. example, form = ~ data$x + data[[5]], base::.vars(form) returns names \"data\" \"x\", whereas emmeans::..vars(form) returns names \"data$x\" \"data[[5]]\". retain argument may used specify regular expressions patterns retain parts variable names. emmeans::.diag(x, nrow, ncol) base diag function booby trap whereby, example, diag(57.6) returns 57 x 57 identity matrix rather 1 x 1 matrix 57.6 element. emmeans::.diag(57.6) return latter. function works identically diag except tail run around identity-matrix trap. emmeans::.aovlist.dffun(k, dfargs) function exported needed computing degrees freedom models fitted using aov, may useful cases Satterthwaite degrees--freedom calculations needed. requires dfargs slot contain analogous contents. emmeans::.get.offset(terms, grid) terms model formula containing offset call, compute offset context grid (data.frame). emmeans::..vcov(object, ...) call ref_grid, emmeans, etc., user may use vcov. specify alternative function matrix use covariance matrix fixed-effects coefficients. function supports feature. Calling ..vcov place vcov method substitute user’s vcov. specified. emmeans::.std.link.labels(fam, misc) useful emm_basis methods generalized linear models. Call fam equal family object model, misc either existing list, just list() none. returns new misc list containing link function , cases, extra features used certain types link functions (e.g., log link, setups returning ratio comparisons type = \"response\"). emmeans::.num.key(levs, key) Returns integer indices elements key levs key character vector; just returns integer values already integer. Also throws error levels mismatched indices exceed legal range. useful custom contrast functions (.emmc functions). emmeans::.get.excl(levs, exclude, include) support exclude include arguments contrast functions. checks legality returns integer vector exclude indices levs, given specified integer character arguments exclude include. .emmc function, exclude default integer(0) include default. emmeans::.cmpMM(X, weights, assign) creates compact version model matrix X (, preferably, QR decomposition). useful want emm_basis() method return model.matrix element. returned result just R portion QR decomposition diag(sqrt(weights)) %*% X, assign attribute added. X qr object, assume weights already incorporated, true qr slot lm object. Back Contents","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"rsm","dir":"Articles","previous_headings":"","what":"Existing support for rsm objects","title":"For developers: Extending **emmeans**","text":"nontrivial example existing package supports emmeans, show support offered rsm package. rsm function returns rsm object extension lm class. Part extension coded.data structures whereby, typical response-surface analysis, models fitted variables linearly transformed (coded) scope predictor represented plus minus 1 coded scale. Without extra support rsm, emmeans work just fine rsm objects; data coded, becomes awkward present results terms original predictors original, uncoded scale. emmeans-related methods rsm provide mode argument may used specify whether want work coded uncoded data. possible values mode \"asis\" (ignore codings, present), \"coded\" (use coded scale), \"decoded\" (use decoded scale). first two actually decoding done; seems clearer provide separate options represent two different situations.","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"rdrsm","dir":"Articles","previous_headings":"Existing support for rsm objects","what":"The recover_data method","title":"For developers: Extending **emmeans**","text":"Note coding predictor transformation, response transformation (, , ’s already supported emmeans infrastructure). , handle \"decode\" mode, need actually decode predictors used construct reference grid. means need make recover_data lot fancier! : Lines 2–7 ensure mode legal, retrieves codings object, obtain results get recover_data lm object. mode \"decoded\", codings used, ’s need. Otherwise, need return decoded data. However, isn’t quite simple, model equation still defined coded scale. Rather try translate model coefficients covariance matrix decoded scale, elected remember need later put things back coded scale. lines 9–10, retrieve attributes recovered data provide predictor names terms object coded scale. line 11, replace recovered data decoded data. way, codings comprise list formulas coded name left original variable name right. possible predictors coded (example, blocking factors ). loop lines 12–18, coded predictor names replaced decoded names. technical reasons discussed later, also remove coded predictor names copy, cpred, list predictors coded model. line 19, \"predictors\" attribute data replaced modified version. Now, nasty technicality. ref_grid function emmeans lines code recover_data called determine terms model convert covariates factors vice versa; code uses model formula. formula involves variables coded scale, variables longer present data, error occur tries access . Luckily, simply take terms formula, won’t hurt coded predictors converted way. line 20, update trms simpler model coded variables excluded (intercept explicitly included ensure right-hand side even cpred empty). save terms attribute, original terms new \"orig\" attribute retrieved later. data object, modified , returned. data decoded, ref_grid construct grid using decoded variables. line 23, save codings \"misc\" attribute, accessed later emm_basis().","code":"recover_data.rsm = function(object, data, mode = c(\"asis\", \"coded\", \"decoded\"), ...) {     mode = match.arg(mode)     cod = rsm::codings(object)     fcall = object$call     if(is.null(data))                                                 # 5         data = emmeans::recover_data(fcall,                     delete.response(terms(object)), object$na.action,                     weights = weights(object), ...)     if (!is.null(cod) && (mode == \"decoded\")) {         pred = cpred = attr(data, \"predictors\")         trms = attr(data, \"terms\")                                    #10         data = rsm::decode.data(rsm::as.coded.data(data, formulas = cod))         for (form in cod) {             vn = all.vars(form)             if (!is.na(idx <- grep(vn[1], pred))) {                  pred[idx] = vn[2]                                     #15                 cpred = setdiff(cpred, vn[1])             }         }         attr(data, \"predictors\") = pred         new.trms = update(trms, reformulate(c(\"1\", cpred)))           #20         attr(new.trms, \"orig\") = trms         attr(data, \"terms\") = new.trms         attr(data, \"misc\") = cod     }     data }"},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"ebrsm","dir":"Articles","previous_headings":"Existing support for rsm objects","what":"The emm_basis method","title":"For developers: Extending **emmeans**","text":"Now comes emm_basis method called grid defined. listed : much simpler. coding formulas obtained misc (line 4) don’t re-obtain object. determine decoding done (line 5); , , convert grid back coded scale (line 6) recover original terms attribute (line 7). rest borrowed directly emm_basis.lm method emmeans. Note line 13 uses one exported functions described preceding section. Lines 15–18 use functions estimability package handle possibility model rank-deficient.","code":"emm_basis.rsm = function(object, trms, xlev, grid,                           mode = c(\"asis\", \"coded\", \"decoded\"), misc, ...) {     mode = match.arg(mode)     cod = misc     if(!is.null(cod) && mode == \"decoded\") {                          # 5         grid = rsm::coded.data(grid, formulas = cod)         trms = attr(trms, \"orig\")     }          m = model.frame(trms, grid, na.action = na.pass, xlev = xlev)     #10     X = model.matrix(trms, m, contrasts.arg = object$contrasts)     bhat = as.numeric(object$coefficients)      V = emmeans::.my.vcov(object, ...)          if (sum(is.na(bhat)) > 0)                                         #15         nbasis = estimability::nonest.basis(object$qr)     else         nbasis = estimability::all.estble     dfargs = list(df = object$df.residual)     dffun = function(k, dfargs) dfargs$df                             #20      list(X = X, bhat = bhat, nbasis = nbasis, V = V,           dffun = dffun, dfargs = dfargs, misc = list()) }"},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"demo","dir":"Articles","previous_headings":"Existing support for rsm objects","what":"A demonstration","title":"For developers: Extending **emmeans**","text":"’s demonstration rsm support. standard example rsm fits second-order model CR.rs2 dataset organized two blocks two coded predictors. First, let’s look results coded scale—ordinary lm object. Now, coded variables x1 x2 derived coding formulas predictors Time Temp: Thus, example, coded value x1 = 1 corresponds time 85 + 1 x 5 = 90. results working decoded predictors. Note list must now given terms Time Temp: Since supplied settings decoded scale used coded scale, EMMs identical previous output.","code":"library(\"rsm\") example(\"rsm\")   ### (output is not shown) ### emmeans(CR.rs2, ~ x1 * x2, mode = \"coded\",          at = list(x1 = c(-1, 0, 1), x2 = c(-2, 2))) ##  x1 x2 emmean    SE df lower.CL upper.CL ##  -1 -2   75.0 0.298  7     74.3     75.7 ##   0 -2   77.0 0.240  7     76.4     77.5 ##   1 -2   76.4 0.298  7     75.6     77.1 ##  -1  2   76.8 0.298  7     76.1     77.5 ##   0  2   79.3 0.240  7     78.7     79.9 ##   1  2   79.2 0.298  7     78.5     79.9 ##  ## Results are averaged over the levels of: Block  ## Confidence level used: 0.95 codings(CR.rs1) ## $x1 ## x1 ~ (Time - 85)/5 ##  ## $x2 ## x2 ~ (Temp - 175)/5 emmeans(CR.rs2, ~ Time * Temp, mode = \"decoded\",          at = list(Time = c(80, 85, 90), Temp = c(165, 185))) ##  Time Temp emmean    SE df lower.CL upper.CL ##    80  165   75.0 0.298  7     74.3     75.7 ##    85  165   77.0 0.240  7     76.4     77.5 ##    90  165   76.4 0.298  7     75.6     77.1 ##    80  185   76.8 0.298  7     76.1     77.5 ##    85  185   79.3 0.240  7     78.7     79.9 ##    90  185   79.2 0.298  7     78.5     79.9 ##  ## Results are averaged over the levels of: Block  ## Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"dispatch","dir":"Articles","previous_headings":"","what":"Dispatching and restrictions","title":"For developers: Extending **emmeans**","text":"emmeans package internal support number model classes. recover_data() emm_basis() dispatched, search made external methods given class; found, methods used instead internal ones. However, certain restrictions apply aim override existing internal method: class name extended must appear first second position results class(object). , may base class provide recover_data() emm_basis() methods, also work direct descendants thereof; class third place later inheritance ignored. Certain classes vital correct operation package, e.g., \"lm\", \"glm\", etc., may overridden. existing internal methods class(es) provide methods , restrictions .","code":""},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"exporting","dir":"Articles","previous_headings":"","what":"Exporting and registering your methods","title":"For developers: Extending **emmeans**","text":"make methods available users package, methods must exported. R CRAN evolving way S3 methods registry increasingly important; good idea provide . problem package users emmeans installed. Thus, registering methods must done conditionally. provide courtesy function .emm_register() make simple. Suppose package offers two model classes foo bar, includes corresponding functions recover_data.foo, recover_data.bar, emm_basis.foo, emm_basis.bar. register methods, add modify .onLoad function package (traditionally saved source file zzz.R): also add emmeans (>= 1.4) estimability (required emmeans) Suggests field DESCRIPTION file. Back Contents","code":".onLoad <- function(libname, pkgname) {     if (requireNamespace(\"emmeans\", quietly = TRUE))         emmeans::.emm_register(c(\"foo\", \"bar\"), pkgname) }"},{"path":"https://rvlenth.github.io/emmeans/articles/xtending.html","id":"concl","dir":"Articles","previous_headings":"","what":"Conclusions","title":"For developers: Extending **emmeans**","text":"relatively simple write appropriate methods work emmeans model objects support. hope vignette helpful understanding . Furthermore, developer package fits linear models, encourage include recover_data emm_basis methods classes objects, users access emmeans support. Back Contents Index vignette topics","code":""},{"path":"https://rvlenth.github.io/emmeans/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Russell V. Lenth. Author, maintainer, copyright holder. Ben Bolker. Contributor. Paul Buerkner. Contributor. Iago Giné-Vázquez. Contributor. Maxime Herve. Contributor. Maarten Jung. Contributor. Jonathon Love. Contributor. Fernando Miguez. Contributor. Julia Piaskowski. Contributor. Hannes Riebl. Contributor. Henrik Singmann. Contributor.","code":""},{"path":"https://rvlenth.github.io/emmeans/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lenth R (2024). emmeans: Estimated Marginal Means, aka Least-Squares Means. R package version 1.10.2, https://rvlenth.github.io/emmeans/, https://rvlenth.github.io/emmeans/.","code":"@Manual{,   title = {emmeans: Estimated Marginal Means, aka Least-Squares Means},   author = {Russell V. Lenth},   year = {2024},   note = {R package version 1.10.2, https://rvlenth.github.io/emmeans/},   url = {https://rvlenth.github.io/emmeans/}, }"},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/index.html","id":"website","dir":"","previous_headings":"","what":"Website","title":"Estimated Marginal Means, aka Least-Squares Means","text":"https://rvlenth.github.io/emmeans/","code":""},{"path":"https://rvlenth.github.io/emmeans/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Estimated Marginal Means, aka Least-Squares Means","text":"Estimated marginal means (EMMs, also known least-squares means context traditional regression models) derived using model make predictions regular grid predictor combinations (called reference grid). predictions may possibly averaged (typically equal weights) one predictors. marginally-averaged predictions useful describing results fitting model, particularly presenting effects factors. emmeans package can easily produce results, well various graphs (interaction-style plots side--side intervals). Estimation testing pairwise comparisons EMMs, several types contrasts, provided. rank-deficient models, estimability predictions checked, avoid outputting results uniquely defined. models continuous predictors interact factors, package’s emtrends function works terms reference grid predicted slopes trend lines factor combination. Vignettes provided various aspects EMMs using package. See CRAN page. try provide flexible (pretty basic) graphics support emmGrid objects produced package. Also, support provided nested fixed effects. Response transformations link functions supported via type argument many functions (e.g., type = \"response\" back-transform results response scale). Also, regrid() function provided reconstruct object transformed scale user wishes. Two-way support glht function multcomp package.","code":""},{"path":"https://rvlenth.github.io/emmeans/index.html","id":"model-support","dir":"","previous_headings":"","what":"Model support","title":"Estimated Marginal Means, aka Least-Squares Means","text":"package incorporates support many types models, including standard models fitted using lm, glm, relatives, various mixed models, GEEs, survival models, count models, ordinal responses, zero-inflated models, others. Provisions models include special modes accessing different types predictions; example, zero-inflated models, one may opt estimated response including zeros, just linear predictor, zero model. details, see vignette(\"models\", package = \"emmeans\") Various Bayesian models (carBayes, MCMCglmm, MCMCpack) supported way creating posterior sample least-squares means contrasts thereof, may examined using tools coda package. Package developers encouraged incorporate emmeans support models writing recover_data emm_basis methods. See vignette(\"extending\", package = \"emmeans\")","code":""},{"path":"https://rvlenth.github.io/emmeans/index.html","id":"versions-and-installation","dir":"","previous_headings":"","what":"Versions and installation","title":"Estimated Marginal Means, aka Least-Squares Means","text":"CRAN latest CRAN version may found https://CRAN.R-project.org/package=emmeans. Also site, formatted versions package’s vignettes may viewed. GitHub install latest development version GitHub, install newest version devtools package; run Note: Windows user, also first download install latest version Rtools. latest release notes development version, see NEWS file","code":"remotes::install_github(\"rvlenth/emmeans\", dependencies = TRUE, build_opts = \"\")  ### To install without vignettes (faster): remotes::install_github(\"rvlenth/emmeans\")"},{"path":"https://rvlenth.github.io/emmeans/index.html","id":"tidiness-can-be-dangerous","dir":"","previous_headings":"","what":"“Tidiness” can be dangerous","title":"Estimated Marginal Means, aka Least-Squares Means","text":"see users terrible hurry get results. develop “workflow” plan-several steps pipe together. ’s useful don’t think happens steps; ’re statistics, thinking! functions emmeans package yield results accompanied annotations transformations involved, P-value adjustments made, families adjustments, etc. just pipe results code, never see annotations. Please slow ! Look actual results emmeans package function without post-processing – None. way, ’ll see annotated summaries. Statistics pretty hard stuff. Don’t make harder blindfolding .","code":""},{"path":"https://rvlenth.github.io/emmeans/index.html","id":"supersession-plan","dir":"","previous_headings":"","what":"Supersession plan","title":"Estimated Marginal Means, aka Least-Squares Means","text":"developer emmeans continues maintain occasionally add new features. However, none us immortal; neither software. thought trying find co-maintainer carry ball gone lose interest, flip side codebase getting less messy time goes – impose someone else? thought now point, enough active R developers want capabilities emmeans longer picture, feel free supersede package better. code publicly available GitHub, just take useful replace .","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/as.emmGrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to and from emmGrid objects — as.list.emmGrid","title":"Convert to and from emmGrid objects — as.list.emmGrid","text":"useful utility functions creating compact version emmGrid object may saved later reconstructed, converting old ref.grid lsmobj objects emmGrid objects.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/as.emmGrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to and from emmGrid objects — as.list.emmGrid","text":"","code":"# S3 method for emmGrid as.list(x, model.info.slot = FALSE, ...)  as.emm_list(object, ...)  as.emmGrid(object, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/as.emmGrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to and from emmGrid objects — as.list.emmGrid","text":"x emmGrid object model.info.slot Logical value: Include model.info slot? Set TRUE want preserve original call  information needed submodel option. FALSE, nesting information () saved ... .emmGrid, additional arguments passed  update.emmGrid returning object. argument ignored .list.emmGrid object Object converted class emmGrid. may list returned .list.emmGrid, ref.grid lsmobj object created emmeans's predecessor,  lsmeans package. error thrown object converted.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/as.emmGrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to and from emmGrid objects — as.list.emmGrid","text":".list.emmGrid returns object class list. .emm_list returns object class emm_list. .emmGrid returns object class emmGrid.      However, fact, .emmGrid .emm_list check     attribute object decide whether return emmGrid emm_list) object.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/as.emmGrid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert to and from emmGrid objects — as.list.emmGrid","text":"emmGrid object S4 object, saved text format saved without lot overhead. using .list, essential parts object converted list format can easily compactly saved use, say, another session another user. Providing list arguments emmobj allows user  restore working emmGrid object.","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/as.emmGrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert to and from emmGrid objects — as.list.emmGrid","text":"","code":"pigs.lm <- lm(log(conc) ~ source + factor(percent), data = pigs) pigs.sav <- as.list(ref_grid(pigs.lm))  pigs.anew <- as.emmGrid(pigs.sav) emmeans(pigs.anew, \"source\") #>  source emmean     SE df lower.CL upper.CL #>  fish     3.39 0.0367 23     3.32     3.47 #>  soy      3.67 0.0374 23     3.59     3.74 #>  skim     3.80 0.0394 23     3.72     3.88 #>  #> Results are averaged over the levels of: percent  #> Results are given on the log (not the response) scale.  #> Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/reference/auto.noise.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto Pollution Filter Noise — auto.noise","title":"Auto Pollution Filter Noise — auto.noise","text":"Three-factor experiment comparing pollution-filter noise two filters, three sizes cars, two sides car.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/auto.noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Auto Pollution Filter Noise — auto.noise","text":"","code":"auto.noise"},{"path":"https://rvlenth.github.io/emmeans/reference/auto.noise.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Auto Pollution Filter Noise — auto.noise","text":"data frame 36 observations following 4 variables. noise Noise level decibels (see note) - numeric vector. size size vehicle - ordered factor     levels S, M, L. type Type anti-pollution filter - factor levels     Std Octel side side car measurement taken --     factor levels L R.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/auto.noise.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Auto Pollution Filter Noise — auto.noise","text":"dataset obtained Data Story Library (DASL)   Carnegie-Mellon University. Apparently since removed.   original dataset altered assigning meaningful names factors   sorting observations random order run order   experiment.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/auto.noise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Auto Pollution Filter Noise — auto.noise","text":"data statement Texaco, Inc., Air Water Pollution Subcommittee Senate Public Works Committee June 26, 1973.     Mr. John McKinley, President Texaco, cited automobile filter developed Associated Octel Company effective reducing pollution. However,  questions raised effects filters vehicle performance,  fuel consumption, exhaust gas back pressure, silencing. last  question, referred data included evidence silencing properties Octel filter least equal standard silencers.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/auto.noise.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Auto Pollution Filter Noise — auto.noise","text":"data source claims noise measured decibels,   values implausible. believe measurements actually   tenths dB (centibels?). Looking values dataset, note    every measurement ends 0 5, reasonable believe   measurements accurate nearest half decibel.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/auto.noise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auto Pollution Filter Noise — auto.noise","text":"","code":"# (Based on belief that noise/10 is in decibel units) noise.lm <- lm(noise/10 ~ size * type * side, data = auto.noise)  # Interaction plot of predictions emmip(noise.lm, type ~ size | side)   # Confidence intervals plot(emmeans(noise.lm, ~ size | side*type))"},{"path":"https://rvlenth.github.io/emmeans/reference/CLD.emmGrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Compact letter displays — cld.emmGrid","title":"Compact letter displays — cld.emmGrid","text":"method multcomp::cld() provided users desiring produce  compact-letter displays (CLDs).  method uses Piepho (2004) algorithm (implemented multcompView package) generate compact letter display pairwise comparisons estimated marginal means. function obtains (possibly adjusted) P values pairwise comparisons means, using contrast function method = \"pairwise\". P value exceeds alpha, two means least one letter common.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/CLD.emmGrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compact letter displays — cld.emmGrid","text":"","code":"# S3 method for emmGrid cld(object, details = FALSE, sort = TRUE, by,   alpha = 0.05, Letters = c(\"1234567890\", LETTERS, letters),   reversed = decreasing, decreasing = FALSE, signif.sets = FALSE,   delta = 0, ...)  # S3 method for emm_list cld(object, ..., which = 1)"},{"path":"https://rvlenth.github.io/emmeans/reference/CLD.emmGrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compact letter displays — cld.emmGrid","text":"object object class emmGrid details Logical value determining whether detailed information tests pairwise comparisons displayed sort Logical value determining whether EMMs sorted comparisons produced. TRUE, results displayed according reversed. Character value giving name names variables separate families comparisons tested. NULL, means compared. missing, object's .vars setting, , used. alpha Numeric value giving significance level comparisons Letters Character vector letters use display. strings length greater 1 expanded individual characters reversed, decreasing Logical value (passed multcompView::multcompLetters.) TRUE, order use letters reversed. Either reversed decreasing may specified, thus providing compatibility multcompView::multcompLetters(..., reversed, ...) multcomp::cld(..., decreasing, ...). addition, sort reversed TRUE, sort order results reversed. signif.sets Logical value. FALSE (delta = 0),  ‘traditional’ compact-letter display constructed groupings representing sets estimates statistically different. TRUE, criteria reversed two estimates sharing symbol test significantly different. See also delta. delta Numeric value passed test.emmGrid. positive, used equivalence threshold TOST procedure two-sided equivalence testing. resulting compact letter display, two estimates share grouping letter found statistically equivalent -- , groupings reflect actual findings equivalence rather failure find significant difference. delta nonzero, signif.sets ignored. ... Arguments passed contrast (example, adjust method) element emm_list object process (length exceeds one, first one used)","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/CLD.emmGrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compact letter displays — cld.emmGrid","text":"summary_emm object showing estimated marginal means plus additional column labeled .group (signif.sets = FALSE),  .signif.set (signif.sets = TRUE), .equiv.set (delta > 0).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/CLD.emmGrid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Compact letter displays — cld.emmGrid","text":"warn default display encourages poor practice interpreting significance tests. CLDs misleading visually group means comparisons P > alpha though  equal, fact failed prove differ. better alternative one wants show groupings specify equivalence threshold delta; groupings based actual findings equivalence. Another way display actual findings set signif.sets = TRUE, estimates group  found statistically different. Obviously, different options require different interpretations results; annotations label given final column help guide assess results. alternatives, consider pwpp (graphical display P  values) pwpm (matrix display).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/CLD.emmGrid.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compact letter displays — cld.emmGrid","text":"Piepho, Hans-Peter (2004) algorithm letter-based    representation pairwise comparisons,    Journal Computational Graphical Statistics,    13(2), 456-466.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/CLD.emmGrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compact letter displays — cld.emmGrid","text":"","code":"if(requireNamespace(\"multcomp\"))     emm_example(\"cld-multcomp\") #>  #> --- Running code from 'system.file(\"extexamples\", \"cld-multcomp.R\", package = \"emmeans\")' #>  #> > pigs.lm <- lm(log(conc) ~ source + factor(percent),  #> +     data = pigs) #>  #> > pigs.emm <- emmeans(pigs.lm, \"percent\", type = \"response\") #>  #> > multcomp::cld(pigs.emm, alpha = 0.1, Letters = LETTERS) #>  percent response   SE df lower.CL upper.CL .group #>        9     31.4 1.28 23     28.8     34.1  A     #>       12     37.5 1.44 23     34.7     40.6   B    #>       15     39.0 1.70 23     35.6     42.7   B    #>       18     42.3 2.24 23     37.9     47.2   B    #>  #> Results are averaged over the levels of: source  #> Confidence level used: 0.95  #> Intervals are back-transformed from the log scale  #> P value adjustment: tukey method for comparing a family of 4 estimates  #> Tests are performed on the log scale  #> significance level used: alpha = 0.1  #> NOTE: If two or more means share the same grouping symbol, #>       then we cannot show them to be different. #>       But we also did not show them to be the same.  #>  #> > multcomp::cld(pigs.emm, alpha = 0.1, signif.sets = TRUE) #>  percent response   SE df lower.CL upper.CL .signif.set #>        9     31.4 1.28 23     28.8     34.1  123        #>       12     37.5 1.44 23     34.7     40.6  1          #>       15     39.0 1.70 23     35.6     42.7   2         #>       18     42.3 2.24 23     37.9     47.2    3        #>  #> Results are averaged over the levels of: source  #> Confidence level used: 0.95  #> Intervals are back-transformed from the log scale  #> P value adjustment: tukey method for comparing a family of 4 estimates  #> Tests are performed on the log scale  #> significance level used: alpha = 0.1  #> Estimates sharing the same symbol are significantly different  #>  #> > multcomp::cld(pigs.emm, delta = log(1.25), adjust = \"sidak\") #>  percent response   SE df lower.CL upper.CL .equiv.set #>        9     31.4 1.28 23     28.1     35.0  1         #>       12     37.5 1.44 23     33.8     41.6   2        #>       15     39.0 1.70 23     34.6     43.9   2        #>       18     42.3 2.24 23     36.7     48.8    3       #>  #> Results are averaged over the levels of: source  #> Confidence level used: 0.95  #> Conf-level adjustment: sidak method for 4 estimates  #> Intervals are back-transformed from the log scale  #> P value adjustment: sidak method for 6 tests  #> Statistics are tests of equivalence with a threshold of 0.22314  #> P values are left-tailed  #> Tests are performed on the log scale  #> significance level used: alpha = 0.05  #> Estimates sharing the same symbol test as equivalent  #>      # Use emm_example(\"cld-multcomp\", list = TRUE) # to just list the code"},{"path":"https://rvlenth.github.io/emmeans/reference/contrast.html","id":null,"dir":"Reference","previous_headings":"","what":"Contrasts and linear functions of EMMs — contrast","title":"Contrasts and linear functions of EMMs — contrast","text":"methods provide follow-analyses emmGrid objects: Contrasts, pairwise comparisons, tests, confidence intervals. may also used compute arbitrary linear functions predictions EMMs.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/contrast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contrasts and linear functions of EMMs — contrast","text":"","code":"contrast(object, ...)  # S3 method for emmGrid contrast(object, method = \"eff\", interaction = FALSE, by,   offset = NULL, scale = NULL, name = \"contrast\",   options = get_emm_option(\"contrast\"), type, adjust, simple,   combine = FALSE, ratios = TRUE, parens, enhance.levels = TRUE, wts,   ...)  # S3 method for emmGrid pairs(x, reverse = FALSE, ...)  # S3 method for emmGrid coef(object, ...)  # S3 method for emmGrid weights(object, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/contrast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contrasts and linear functions of EMMs — contrast","text":"object object class emmGrid ... Additional arguments passed methods method Character value giving root name contrast method (e.g. \"pairwise\" -- see emmc-functions). Alternatively, function form, named list coefficients (contrast linear function) must conform number results group. multi-factor situation, factor levels combined treated like single factor. interaction Character vector, logical value, list. specified, method ignored. See “Interaction contrasts” section details. Character names variable(s) used ``'' groups. contrasts joint tests evaluated separately combination variables. object created groups, used unless overridden. Use = NULL use groups . offset, scale Numeric vectors length group. scale values, supplied, multiply respective linear estimates, offset values added. Scalar values also allowed.  (arguments ignored interaction specified.) name Character name use override default label contrasts used table headings subsequent contrasts returned object. options non-NULL, named list arguments pass update.emmGrid, just object constructed. type Character: prediction type (e.g., \"response\") -- added options adjust Character: adjustment method (e.g., \"bonferroni\") -- added options simple Character vector list: Specify factor(s) , list thereof. See section simple contrasts. combine Logical value determines returned simple list. See section simple contrasts. ratios Logical value determining log logit transforms handled. transformations exceptional cases valid way back-transform contrasts: differences logs logs ratios, differences logits odds ratios. ratios = TRUE summarized type = \"response\", contrast results back-transformed ratios whenever true contrasts (coefficients sum zero). transformations, natural way back-transform contrasts, even summarized type = \"response\", contrasts computed displayed linear-predictor scale. Similarly,  ratios = FALSE, log logit transforms treated way transformation. parens character NULL. character value, labels levels contrasted parenthesized match regular expression  parens[1] (via grep). default emm_option(\"parens\"). Optionally, parens may contain second third elements specifying use left right parentheses (default \"(\" \")\"). Specify parens = NULL parens = \"^\" (match anything) disable parenthesization. enhance.levels character logical.  character, levels named factors contrasted enhanced  appending name factor; e.g., factor named \"trt\" levels B, trt comparison labeled trtA - trtB. enhance.levels logical, TRUE (default),  factors numeric levels enhanced; course FALSE, levels enhanced. levels variables enhanced,  names factors exist silently ignored.  enhance labels beyond done , change directly via levels<-. wts wts argument contrast methods. omit argument unless want unequal wts. Otherwise recommend specifying wts = NA instructs wts obtained object, separately group. numerical wts specified, must conform number levels group, weights used group. x emmGrid object reverse Logical value - determines whether use \"pairwise\" (TRUE) \"revpairwise\" (FALSE).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/contrast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contrasts and linear functions of EMMs — contrast","text":"contrast pairs return object class  emmGrid. grid correspond levels contrasts   variables. exception emm_list object returned simple list combine  FALSE. coef returns data.frame containing \"parent\" object's grid,  along columns named c.1, c.2, ... containing contrast coefficients used produce linear functions embodied object. coef() returns coefficients object result call contrast(), parent object object handed contrast. useful understanding interaction contrasts. weights returns weights stored row object,    vector 1s weights saved.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/contrast.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Contrasts and linear functions of EMMs — contrast","text":"object nesting structure (can seen via   str(object)), grouping factors involved forced   service variables, contrasts thus computed   separately nest. turn may lead irregular grid   returned emmGrid object, may valid subsequent   emmeans calls.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/contrast.html","id":"pairs-method","dir":"Reference","previous_headings":"","what":"Pairs method","title":"Contrasts and linear functions of EMMs — contrast","text":"call pairs(object) equivalent   contrast(object, method = \"pairwise\"); pairs(object,   reverse = TRUE) contrast(object, method =   \"revpairwise\").","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/contrast.html","id":"interaction-contrasts","dir":"Reference","previous_headings":"","what":"Interaction contrasts","title":"Contrasts and linear functions of EMMs — contrast","text":"interaction specified,   interaction contrasts computed. Specifically contrasts generated   factor separately, one time; contrasts applied   object (first time around) previous result   (subsequently). (factors specified skipped.) final   result comprises contrasts contrasts, , equivalently, products   contrasts factors involved. named elements interaction   assigned contrast methods; others assigned order   appearance object@levels. contrast factors resulting    emmGrid object ordered interaction. interaction may character vector list valid contrast   methods (documented method argument). vector   list shorter number needed, recycled. Alternatively,   user specifies contrast = TRUE, contrast specified   method used factors involved.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/contrast.html","id":"simple-contrasts","dir":"Reference","previous_headings":"","what":"Simple contrasts","title":"Contrasts and linear functions of EMMs — contrast","text":"simple essentially complement :   simple character vector, set factors   grid except simple. simple list,   element used turn simple, assembled   \"emm_list\". generate simple main effects, use   simple = \"\" (works unless actually factor named   \"\"). Note non-missing simple cause   ignored. Ordinarily, simple list \"\", return value   emm_list object entry correspondence   entries simple. However, combine = TRUE,   elements combined one family contrasts single   emmGrid object using   rbind.emmGrid.. case, adjust argument sets   adjustment method combined set contrasts.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/contrast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contrasts and linear functions of EMMs — contrast","text":"","code":"warp.lm <- lm(breaks ~ wool*tension, data = warpbreaks) (warp.emm <- emmeans(warp.lm, ~ tension | wool)) #> wool = A: #>  tension emmean   SE df lower.CL upper.CL #>  L         44.6 3.65 48     37.2     51.9 #>  M         24.0 3.65 48     16.7     31.3 #>  H         24.6 3.65 48     17.2     31.9 #>  #> wool = B: #>  tension emmean   SE df lower.CL upper.CL #>  L         28.2 3.65 48     20.9     35.6 #>  M         28.8 3.65 48     21.4     36.1 #>  H         18.8 3.65 48     11.4     26.1 #>  #> Confidence level used: 0.95   contrast(warp.emm, \"poly\")    # inherits 'by = \"wool\"' from warp.emm #> wool = A: #>  contrast  estimate   SE df t.ratio p.value #>  linear      -20.00 5.16 48  -3.878  0.0003 #>  quadratic    21.11 8.93 48   2.363  0.0222 #>  #> wool = B: #>  contrast  estimate   SE df t.ratio p.value #>  linear       -9.44 5.16 48  -1.831  0.0733 #>  quadratic   -10.56 8.93 48  -1.182  0.2432 #>   ### Custom contrast coefs (we already have wool as 'by' thus 3 means to contrast) contrast(warp.emm, list(mid.vs.ends = c(-1,2,-1)/2, lo.vs.hi = c(1,0,-1))) #> wool = A: #>  contrast    estimate   SE df t.ratio p.value #>  mid.vs.ends   -10.56 4.47 48  -2.363  0.0222 #>  lo.vs.hi       20.00 5.16 48   3.878  0.0003 #>  #> wool = B: #>  contrast    estimate   SE df t.ratio p.value #>  mid.vs.ends     5.28 4.47 48   1.182  0.2432 #>  lo.vs.hi        9.44 5.16 48   1.831  0.0733 #>   pairs(warp.emm) #> wool = A: #>  contrast estimate   SE df t.ratio p.value #>  L - M      20.556 5.16 48   3.986  0.0007 #>  L - H      20.000 5.16 48   3.878  0.0009 #>  M - H      -0.556 5.16 48  -0.108  0.9936 #>  #> wool = B: #>  contrast estimate   SE df t.ratio p.value #>  L - M      -0.556 5.16 48  -0.108  0.9936 #>  L - H       9.444 5.16 48   1.831  0.1704 #>  M - H      10.000 5.16 48   1.939  0.1389 #>  #> P value adjustment: tukey method for comparing a family of 3 estimates   # Effects (dev from mean) of the 6 factor combs, with enhanced levels: contrast(warp.emm, \"eff\", by = NULL,      enhance.levels = c(\"wool\", \"tension\"))   #>  contrast              estimate   SE df t.ratio p.value #>  tensionL woolA effect  16.4074 3.33 48   4.929  0.0001 #>  tensionM woolA effect  -4.1481 3.33 48  -1.246  0.4289 #>  tensionH woolA effect  -3.5926 3.33 48  -1.079  0.4289 #>  tensionL woolB effect   0.0741 3.33 48   0.022  0.9823 #>  tensionM woolB effect   0.6296 3.33 48   0.189  0.9823 #>  tensionH woolB effect  -9.3704 3.33 48  -2.815  0.0212 #>  #> P value adjustment: fdr method for 6 tests       pairs(warp.emm, simple = \"wool\") # same as pairs(warp.emm, by = \"tension\") #> tension = L: #>  contrast estimate   SE df t.ratio p.value #>  A - B       16.33 5.16 48   3.167  0.0027 #>  #> tension = M: #>  contrast estimate   SE df t.ratio p.value #>  A - B       -4.78 5.16 48  -0.926  0.3589 #>  #> tension = H: #>  contrast estimate   SE df t.ratio p.value #>  A - B        5.78 5.16 48   1.120  0.2682 #>   # Do all \"simple\" comparisons, combined into one family pairs(warp.emm, simple = \"each\", combine = TRUE) #>  wool tension contrast estimate   SE df t.ratio p.value #>  A    .       L - M      20.556 5.16 48   3.986  0.0021 #>  A    .       L - H      20.000 5.16 48   3.878  0.0029 #>  A    .       M - H      -0.556 5.16 48  -0.108  1.0000 #>  B    .       L - M      -0.556 5.16 48  -0.108  1.0000 #>  B    .       L - H       9.444 5.16 48   1.831  0.6594 #>  B    .       M - H      10.000 5.16 48   1.939  0.5255 #>  .    L       A - B      16.333 5.16 48   3.167  0.0241 #>  .    M       A - B      -4.778 5.16 48  -0.926  1.0000 #>  .    H       A - B       5.778 5.16 48   1.120  1.0000 #>  #> P value adjustment: bonferroni method for 9 tests   if (FALSE) {  ## Note that the following are NOT the same: contrast(warp.emm, simple = c(\"wool\", \"tension\")) contrast(warp.emm, simple = list(\"wool\", \"tension\")) ## The first generates contrasts for combinations of wool and tension ##   (same as by = NULL) ## The second generates contrasts for wool by tension, and for  ##   tension by wool, respectively. }  # An interaction contrast for tension:wool tw.emm <- contrast(warp.emm, interaction = c(tension = \"poly\", wool = \"consec\"),                     by = NULL) tw.emm          # see the estimates #>  tension_poly wool_consec estimate    SE df t.ratio p.value #>  linear       B - A           10.6  7.29 48   1.447  0.1543 #>  quadratic    B - A          -31.7 12.63 48  -2.507  0.0156 #>  coef(tw.emm)    # see the contrast coefficients #>   tension wool c.1 c.2 #> 1       L    A   1  -1 #> 2       M    A   0   2 #> 3       H    A  -1  -1 #> 4       L    B  -1   1 #> 5       M    B   0  -2 #> 6       H    B   1   1  # Use of scale and offset #   an unusual use of the famous stack-loss data... mod <- lm(Water.Temp ~ poly(stack.loss, degree = 2), data = stackloss) (emm <- emmeans(mod, \"stack.loss\", at = list(stack.loss = 10 * (1:4)))) #>  stack.loss emmean    SE df lower.CL upper.CL #>          10   18.8 0.463 18     17.9     19.8 #>          20   22.3 0.564 18     21.1     23.5 #>          30   24.9 0.646 18     23.5     26.3 #>          40   26.7 0.958 18     24.6     28.7 #>  #> Confidence level used: 0.95  # Convert results from Celsius to Fahrenheit: confint(contrast(emm, \"identity\", scale = 9/5, offset = 32)) #>  contrast     estimate    SE df lower.CL upper.CL #>  stack.loss10     65.9 0.833 18     64.1     67.6 #>  stack.loss20     72.1 1.015 18     70.0     74.3 #>  stack.loss30     76.8 1.163 18     74.4     79.3 #>  stack.loss40     80.0 1.724 18     76.4     83.6 #>  #> Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/reference/eff_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate effect sizes and confidence bounds thereof — eff_size","title":"Calculate effect sizes and confidence bounds thereof — eff_size","text":"Standardized effect sizes typically calculated using pairwise differences estimates, divided SD population providing context effects. function calculates effect sizes emmGrid object, confidence intervals , accounting uncertainty estimated effects population SD.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/eff_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate effect sizes and confidence bounds thereof — eff_size","text":"","code":"eff_size(object, sigma, edf, method = \"pairwise\", ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/eff_size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate effect sizes and confidence bounds thereof — eff_size","text":"object emmGrid object,  typically one defining EMMs  contrasted. instead, class(object) == \"emm_list\", produced emmeans(model, pairwise ~ treatment), message displayed; contrasts already therein used;  method replaced \"identity\". sigma numeric scalar, value population SD. edf numeric scalar specifies equivalent degrees freedom sigma. way specifying uncertainty sigma, regard estimate sigma^2 proportional chi-square random variable edf degrees freedom. (edf confused df argument may passed via ... specify degrees freedom use \\(t\\) statistics confidence intervals.) method contrast method use define effects. passed contrast elements object scaled. ... Additional arguments passed contrast","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/eff_size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate effect sizes and confidence bounds thereof — eff_size","text":"emmGrid object containing effect sizes","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/eff_size.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate effect sizes and confidence bounds thereof — eff_size","text":"variables specified object remain force returned effects, unless overridden optional arguments. models single random effect, fitted using lm; case, stats::sigma stats::df.residual functions may useful specifying sigma edf. models one random effect, sigma may based combination random-effect variances. Specifying edf can rather unintuitive also relatively uncritical; smaller value, wider confidence intervals effect size. value sqrt(2/edf) can interpreted relative accuracy sigma; example, edf = 50, \\(\\sqrt(2/50) = 0.2\\), meaning sigma accurate plus minus 20 percent. Note example , tried two different edf values kind bracketing/sensitivity-analysis strategy. value Inf allowable, case assuming sigma known exactly. Obviously, narrows confidence intervals effect sizes -- unrealistically fact sigma unknown.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/eff_size.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate effect sizes and confidence bounds thereof — eff_size","text":"effects always computed scale linear-predictor; response transformation link function completely ignored. wish base effect sizes response scale, enough replace object regrid(object), back-transformation changes SD required compute effect sizes. Paired data: careful paired-data situations, Cohen's d typically referenced SD paired differences rather residual SD. may need enlarge sigma factor sqrt(2) obtain comparable results software. Disclaimer: substantial disagreement among practitioners appropriate sigma use computing effect sizes; , indeed, whether effect-size measure appropriate situations. user completely responsible specifying  appropriate parameters (failing ). examples illustrate sobering message effect sizes often nearly accurate may think.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/eff_size.html","id":"computation","dir":"Reference","previous_headings":"","what":"Computation","title":"Calculate effect sizes and confidence bounds thereof — eff_size","text":"function uses calls regrid put estimated marginal means (EMMs) log scale. extra element added grid log sigma standard error (assume sigma uncorrelated log EMMs). call contrast subtracts log{sigma} log EMMs, yielding values log(EMM/sigma). Finally, results re-gridded back original scale desired contrasts computed using method. log-scaling part, actually rescale absolute values keep track signs.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/eff_size.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate effect sizes and confidence bounds thereof — eff_size","text":"","code":"fiber.lm <- lm(strength ~ diameter + machine, data = fiber)  emm <- emmeans(fiber.lm, \"machine\") eff_size(emm, sigma = sigma(fiber.lm), edf = df.residual(fiber.lm)) #>  contrast effect.size    SE df lower.CL upper.CL #>  A - B         -0.650 0.650 11   -2.081    0.781 #>  A - C          0.993 0.726 11   -0.604    2.590 #>  B - C          1.643 0.800 11   -0.118    3.405 #>  #> sigma used for effect sizes: 1.595  #> Confidence level used: 0.95   # or equivalently: eff_size(pairs(emm), sigma(fiber.lm), df.residual(fiber.lm), method = \"identity\") #>  contrast effect.size    SE df lower.CL upper.CL #>  (A - B)       -0.650 0.650 11   -2.081    0.781 #>  (A - C)        0.993 0.726 11   -0.604    2.590 #>  (B - C)        1.643 0.800 11   -0.118    3.405 #>  #> sigma used for effect sizes: 1.595  #> Confidence level used: 0.95    ### Mixed model example: if (require(nlme)) withAutoprint({   Oats.lme <- lme(yield ~ Variety + factor(nitro),                    random = ~ 1 | Block / Variety,                   data = Oats)   # Combine variance estimates   VarCorr(Oats.lme)   (totSD <- sqrt(214.4724 + 109.6931 + 162.5590))   # I figure edf is somewhere between 5 (Blocks df) and 51 (Resid df)   emmV <- emmeans(Oats.lme, ~ Variety)   eff_size(emmV, sigma = totSD, edf = 5)   eff_size(emmV, sigma = totSD, edf = 51) }, spaced = TRUE) #> Loading required package: nlme #>  #> >   Oats.lme <- lme(yield ~ Variety + factor(nitro),  #> +                   random = ~ 1 | Block / Variety, #> +                   data = Oats) #>  #> >   # Combine variance estimates #> >   VarCorr(Oats.lme) #>             Variance     StdDev   #> Block =     pdLogChol(1)          #> (Intercept) 214.4721     14.64486 #> Variety =   pdLogChol(1)          #> (Intercept) 109.6932     10.47345 #> Residual    162.5591     12.74987 #>  #> >   (totSD <- sqrt(214.4724 + 109.6931 + 162.5590)) #> [1] 22.06183 #>  #> >   # I figure edf is somewhere between 5 (Blocks df) and 51 (Resid df) #> >   emmV <- emmeans(Oats.lme, ~ Variety) #>  #> >   eff_size(emmV, sigma = totSD, edf = 5) #>  contrast                 effect.size    SE df lower.CL upper.CL #>  Golden Rain - Marvellous      -0.240 0.330  5   -1.087    0.608 #>  Golden Rain - Victory          0.312 0.336  5   -0.551    1.174 #>  Marvellous - Victory           0.551 0.365  5   -0.387    1.490 #>  #> Results are averaged over the levels of: nitro  #> sigma used for effect sizes: 22.06  #> Degrees-of-freedom method: inherited from containment when re-gridding  #> Confidence level used: 0.95  #>  #> >   eff_size(emmV, sigma = totSD, edf = 51) #>  contrast                 effect.size    SE df lower.CL upper.CL #>  Golden Rain - Marvellous      -0.240 0.322  5   -1.067    0.587 #>  Golden Rain - Victory          0.312 0.322  5   -0.517    1.140 #>  Marvellous - Victory           0.551 0.325  5   -0.285    1.388 #>  #> Results are averaged over the levels of: nitro  #> sigma used for effect sizes: 22.06  #> Degrees-of-freedom method: inherited from containment when re-gridding  #> Confidence level used: 0.95   # Multivariate model for the same data:  MOats.lm <- lm(yield ~ Variety, data = MOats)  eff_size(emmeans(MOats.lm, \"Variety\"),            sigma = sqrt(mean(sigma(MOats.lm)^2)),   # RMS of sigma()           edf = df.residual(MOats.lm)) #>  contrast                 effect.size    SE df lower.CL upper.CL #>  Golden Rain - Marvellous      -0.237 0.496 15   -1.295     0.82 #>  Golden Rain - Victory          0.308 0.498 15   -0.752     1.37 #>  Marvellous - Victory           0.545 0.504 15   -0.529     1.62 #>  #> Results are averaged over the levels of: rep.meas  #> sigma used for effect sizes: 22.31  #> Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/reference/emmc-functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Contrast families — contrast-methods","title":"Contrast families — contrast-methods","text":"Functions extension .emmc provide named contrast families. One standard ones documented may used, user may write function.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmc-functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contrast families — contrast-methods","text":"","code":"pairwise.emmc(levs, exclude = integer(0), include, ...)  revpairwise.emmc(levs, exclude = integer(0), include, ...)  tukey.emmc(levs, reverse = FALSE, ...)  poly.emmc(levs, max.degree = min(6, k - 1), ...)  trt.vs.ctrl.emmc(levs, ref = 1, reverse = FALSE, exclude = integer(0),   include, ...)  trt.vs.ctrl1.emmc(levs, ref = 1, ...)  trt.vs.ctrlk.emmc(levs, ref = length(levs), ...)  dunnett.emmc(levs, ref = 1, ...)  eff.emmc(levs, exclude = integer(0), include, wts = rep(1, length(levs)),   ...)  del.eff.emmc(levs, exclude = integer(0), include, wts = rep(1,   length(levs)), ...)  consec.emmc(levs, reverse = FALSE, exclude = integer(0), include, ...)  mean_chg.emmc(levs, reverse = FALSE, exclude = integer(0), include, ...)  wtcon.emmc(levs, wts, cmtype = \"GrandMean\", ...)  identity.emmc(levs, exclude = integer(0), include, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/emmc-functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contrast families — contrast-methods","text":"levs Vector factor levels exclude integer vector indices, character vector levels exclude consideration. levels receive weight 0 contrasts. Character levels must exactly match elements levs. include integer character vector levels include (complement exclude). error result user specifies exclude include. ... Additional arguments, passed related methods appropriate reverse Logical value determine direction comparisons max.degree Integer specifying maximum degree polynomial contrasts ref Integer(s) character(s) specifying level(s) use  reference. Character values must exactly match elements levs (including enhancements -- see examples) wts Optional weights use eff.emmc del.eff.emmc contrasts. default equal weights. exclude include specified, wts may either length levs length included levels. former case, weights excluded levels set zero. wts impact results unless least three levels included contrast. cmtype type argument passed contrMat","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmc-functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contrast families — contrast-methods","text":"data.frame, column containing contrast coefficients levs.   \"desc\" attribute used label results emmeans,   \"adjust\" attribute gives default adjustment method multiplicity.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmc-functions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Contrast families — contrast-methods","text":"standard contrast family default multiple-testing adjustment noted . adjustments often approximate; exacting adjustment, use interfaces provided glht multcomp package. pairwise.emmc, revpairwise.emmc, tukey.emmc generate contrasts pairwise comparisons among estimated marginal means levels levs. distinction direction subtracted. factor levels , B, C, D, pairwise.emmc generates comparisons -B, -C, -D, B-C, B-D, C-D, whereas revpairwise.emmc generates B-, C-, C-B, D-, D-B, D-C. tukey.emmc invokes pairwise.emmc revpairwise.emmc depending reverse. default multiplicity adjustment method \"tukey\", approximate standard errors differ. poly.emmc generates orthogonal polynomial contrasts, assuming equally-spaced factor levels. derived poly function, ad hoc algorithm used scale integer coefficients (usually) published tables orthogonal polynomial contrasts. default multiplicity adjustment method \"none\". trt.vs.ctrl.emmc relatives generate contrasts comparing one level (average specified levels) levels. argument ref index(es) (labels) reference level(s). trt.vs.ctrl1.emmc trt.vs.ctrl.emmc reference value 1, trt.vs.ctrlk.emmc trt.vs.ctrl reference value length(levs). dunnett.emmc trt.vs.ctrl. default multiplicity adjustment method \"dunnettx\", close approximation Dunnett adjustment. Note functions, illegal overlap ref levels exclude levels. found, error thrown. consec.emmc mean_chg.emmc useful contrasting treatments occur sequence. factor levels , B, C, D, E, consec.emmc generates comparisons B-, C-B, D-C, mean_chg.emmc generates contrasts (B+C+D)/3 - , (C+D)/2 - (+B)/2, D - (+B+C)/3. reverse = TRUE, differences go opposite direction. eff.emmc del.eff.emmc generate contrasts compare level average levels (eff.emmc) levels (del.eff.emmc). differ scaled. set k EMMs, del.eff.emmc gives weight 1 one EMM weight -1/(k-1) others, eff.emmc gives weights (k-1)/k -1/k respectively, subtracting overall EMM EMM. default multiplicity adjustment method \"fdr\". Bonferroni-based method slightly conservative; see p.adjust. wtcon.emmc generates weighted contrasts based function  contrMat function multcomp package, using provided type documented . user provides  wts, conform length levs; however, wts specified, contrast fill-required, usually safer (especially != NULL usually means weights different group). identity.emmc simply returns identity matrix (data frame), minus columns specified exclude. potentially useful cases contrast function must specified, none desired.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmc-functions.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Contrast families — contrast-methods","text":"Caution needed cases user alters ordering   results (e.g., using \"[...]\" operator),   contrasts generated depend order levels provided.   example, suppose trt.vs.ctrl1 contrasts applied two   groups levels ordered (Ctrl, T1, T2) (T1, T2, Ctrl) respectively,   contrasts generated (T1 - Ctrl, T2 - Ctrl)   first group (T2 - T1, Ctrl - T1) second group, first   level group used reference level.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmc-functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contrast families — contrast-methods","text":"","code":"warp.lm <- lm(breaks ~ wool*tension, data = warpbreaks) warp.emm <- emmeans(warp.lm, ~ tension | wool) contrast(warp.emm, \"poly\") #> wool = A: #>  contrast  estimate   SE df t.ratio p.value #>  linear      -20.00 5.16 48  -3.878  0.0003 #>  quadratic    21.11 8.93 48   2.363  0.0222 #>  #> wool = B: #>  contrast  estimate   SE df t.ratio p.value #>  linear       -9.44 5.16 48  -1.831  0.0733 #>  quadratic   -10.56 8.93 48  -1.182  0.2432 #>  contrast(warp.emm, \"trt.vs.ctrl\", ref = \"M\") #> wool = A: #>  contrast estimate   SE df t.ratio p.value #>  L - M      20.556 5.16 48   3.986  0.0005 #>  H - M       0.556 5.16 48   0.108  0.9863 #>  #> wool = B: #>  contrast estimate   SE df t.ratio p.value #>  L - M      -0.556 5.16 48  -0.108  0.9863 #>  H - M     -10.000 5.16 48  -1.939  0.1077 #>  #> P value adjustment: dunnettx method for 2 tests  if (FALSE) { ## Same when enhanced labeling is used: contrast(warp.emm, \"trt.vs.ctrl\",           enhance.levels = \"tension\", ref = \"tensionM\")}  # Comparisons with grand mean contrast(warp.emm, \"eff\") #> wool = A: #>  contrast estimate   SE df t.ratio p.value #>  L effect    13.52 2.98 48   4.540  0.0001 #>  M effect    -7.04 2.98 48  -2.363  0.0333 #>  H effect    -6.48 2.98 48  -2.177  0.0344 #>  #> wool = B: #>  contrast estimate   SE df t.ratio p.value #>  L effect     2.96 2.98 48   0.995  0.3247 #>  M effect     3.52 2.98 48   1.182  0.3247 #>  H effect    -6.48 2.98 48  -2.177  0.1033 #>  #> P value adjustment: fdr method for 3 tests  # Comparisons with a weighted grand mean contrast(warp.emm, \"eff\", wts = c(2, 5, 3)) #> wool = A: #>  contrast estimate   SE df t.ratio p.value #>  L effect    16.28 3.61 48   4.509  0.0001 #>  M effect    -4.28 2.25 48  -1.903  0.0946 #>  H effect    -3.72 3.22 48  -1.156  0.2535 #>  #> wool = B: #>  contrast estimate   SE df t.ratio p.value #>  L effect     2.56 3.61 48   0.708  0.4824 #>  M effect     3.11 2.25 48   1.384  0.2592 #>  H effect    -6.89 3.22 48  -2.139  0.1127 #>  #> P value adjustment: fdr method for 3 tests   # Compare only low and high tensions # Note pairs(emm, ...) calls contrast(emm, \"pairwise\", ...) pairs(warp.emm, exclude = 2) #> wool = A: #>  contrast estimate   SE df t.ratio p.value #>  L - H       20.00 5.16 48   3.878  0.0003 #>  #> wool = B: #>  contrast estimate   SE df t.ratio p.value #>  L - H        9.44 5.16 48   1.831  0.0733 #>  # (same results using exclude = \"M\" or include = c(\"L\",\"H\") or include = c(1,3))  ### Setting up a custom contrast function helmert.emmc <- function(levs, ...) {     M <- as.data.frame(contr.helmert(levs))     names(M) <- paste(levs[-1],\"vs earlier\")     attr(M, \"desc\") <- \"Helmert contrasts\"     M } contrast(warp.emm, \"helmert\") #> Error in contrast.emmGrid(warp.emm, \"helmert\"): Contrast function 'helmert.emmc' not found if (FALSE) { # See what is used for polynomial contrasts with 6 levels emmeans:::poly.emmc(1:6) }"},{"path":"https://rvlenth.github.io/emmeans/reference/emmeans-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimated marginal means (aka Least-squares means) — emmeans-package","title":"Estimated marginal means (aka Least-squares means) — emmeans-package","text":"package provides methods obtaining estimated marginal means (EMMs, also  known least-squares means) factor combinations variety models. Supported models include [generalized linear] models, models counts, multivariate, multinomial ordinal responses, survival models, GEEs, Bayesian models. latter, posterior samples EMMs provided. package can compute contrasts linear combinations marginal means various multiplicity adjustments. One can also estimate contrast slopes trend lines. graphical displays results provided.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmeans-package.html","id":"overview","dir":"Reference","previous_headings":"","what":"Overview","title":"Estimated marginal means (aka Least-squares means) — emmeans-package","text":"Vignettes number vignettes provided help user get acquainted emmeans package see examples. Concept Estimated marginal means (see Searle et al. 1980 popular summarizing linear models include factors. balanced experimental designs, just marginal means. unbalanced data, essence estimate marginal means observed data arisen balanced experiment. Earlier developments regarding techniques developed least-squares context sometimes referred “least-squares means”. Since early development, concept expanded far beyond least-squares settings. Reference grids implementation emmeans relies concept reference grid, array factor predictor levels. Predictions made grid, estimated marginal means (EMMs) defined averages predictions zero dimensions grid. function ref_grid explicitly creates reference grid can subsequently used obtain least-squares means. object returned ref_grid class \"emmGrid\", class used estimated marginal means (see ). reference-grid framework expands slightly upon Searle et al.'s definitions EMMs, possible include multiple levels covariates grid. Models supported mentioned package description, many types models supported package.  See vignette(\"models\", \"emmeans\") full details.  models may require packages installed order  access available features. models explicitly supported, may still possible basic post hoc analyses via qdrg function. Estimated marginal means emmeans function computes EMMs given fitted model (previously constructed emmGrid object), using specification indicating factors include. emtrends function creates sort results estimating comparing slopes fitted lines. return emmGrid object. Summaries analysis summary.emmGrid  method may used display emmGrid object. Special-purpose summaries available via confint.emmGrid test.emmGrid, latter can also joint test several estimates. user may specify variables, multiplicity-adjustment methods, confidence levels, etc., transformation link function involved, may reverse-transform results response scale. Contrasts comparisons contrast method emmGrid objects used obtain contrasts among estimates; several standard contrast families available deviations mean, polynomial contrasts, comparisons one controls. Another emmGrid object returned, can summarized analyzed. convenience, pairs.emmGrid method provided case pairwise comparisons. Graphs plot.emmGrid method display side--side confidence intervals estimates, /“comparison arrows” whereby *P* values pairwise differences can observed much arrows overlap. emmip function displays estimates like interaction plot, multi-paneled variables. graphics capabilities require lattice package installed. MCMC support model fitted using MCMC methods, posterior chains(s) parameter estimates retained converted posterior samples EMMs contrasts thereof. may summarized plotted like MCMC results, using tools , say coda bayesplot. multcomp interface .glht function glht method emmGrids provide interface glht function multcomp package, thus providing exacting simultaneous estimation testing. package also provides emm function works alternative mcp call glht.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimated marginal means (Least-squares means) — emmeans","title":"Estimated marginal means (Least-squares means) — emmeans","text":"Compute estimated marginal means (EMMs) specified factors factor combinations linear model; optionally, comparisons contrasts among . EMMs also known least-squares means.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimated marginal means (Least-squares means) — emmeans","text":"","code":"emmeans(object, specs, by = NULL, fac.reduce = function(coefs) apply(coefs,   2, mean), contr, options = get_emm_option(\"emmeans\"), weights, offset, ...,   tran)"},{"path":"https://rvlenth.github.io/emmeans/reference/emmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimated marginal means (Least-squares means) — emmeans","text":"object object class emmGrid; fitted model object supported, result call lm lmer. Many fitted-model objects supported; see vignette(\"models\", \"emmeans\") details. specs character vector specifying names predictors EMMs desired. specs may also formula list (optionally named) valid specs. Use formulas described Overview section .  Note: recommend using two-sided formulas; see note contr. character vector specifying names predictors condition . fac.reduce function combines rows matrix single vector. implements ``marginal averaging'' aspect EMMs.  default mean rows. Typically overridden, kind weighted mean rows. fac.reduce nonlinear, bizarre results likely, EMMs interpretable. NOTE: weights argument non-missing, fac.reduce ignored. contr character value list specifying contrasts added. See contrast. Note: contr ignored specs formula. Note 2:: recommend using argument; obtaining means obtaining contrasts two different things, best separate steps, using contrast function contrasts. options non-NULL, named list arguments pass update.emmGrid, just object constructed. (Options may also included ...; see ‘options’ section .) weights Character value, numeric vector, numeric matrix specifying weights use averaging predictions. See “Weights” section . Also, object already reference grid, weights (character) passed ref_grid wt.nuis case  nuisance factors specified. can override specifying  wt.nuis explicitly. --less makes weighting nuisance factors consistent primary factors. offset Numeric vector scalar. specified, adds offset predictions, overrides offset model reference grid. vector length differing number rows  result, subsetted cyclically recycled. ... object already \"emmGrid\" object, arguments passed ref_grid. Common examples , cov.reduce, data, type,  regrid, df, nesting, vcov.. Model-type-specific options (see vignette(\"models\", \"emmeans\")), commonly mode, may used well. addition, model formula contains references variables predictors, must provide params argument list names. arguments may also used lieu options. See  ‘Options’ section . tran Placeholder prevent included .... non-missing, added `options`. See ‘Options’ section.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimated marginal means (Least-squares means) — emmeans","text":"specs character vector one-sided formula,   object class \"emmGrid\". number methods   provided analysis, including  summary.emmGrid, confint.emmGrid,  test.emmGrid, contrast.emmGrid,   pairs.emmGrid. specs list formula left-hand side, return value emm_list object, simply list emmGrid objects.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmeans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimated marginal means (Least-squares means) — emmeans","text":"Users also consult documentation ref_grid,  many important options EMMs implemented , via  ... argument.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmeans.html","id":"overview","dir":"Reference","previous_headings":"","what":"Overview","title":"Estimated marginal means (Least-squares means) — emmeans","text":"Estimated marginal means EMMs (sometimes called least-squares means) predictions linear model reference grid; marginal averages thereof. ref_grid function identifies/creates reference grid upon emmeans based. prefer terms “least-squares means” “predicted marginal means”, functions lsmeans pmmeans provided wrappers. See wrappers. specs formula, form ~ specs, ~ specs | , contr ~ specs, contr ~ specs | . formula parsed variables therein used arguments specs, , contr indicated. left-hand side optional (recommend ), specified  name contrast family (e.g., pairwise). Operators like * : needed formula delineate names, otherwise ignored. special case mean (weighted mean) predictions desired, specify specs ~ 1 \"1\". number standard contrast families provided. can identified  functions names ending .emmc -- see documentation emmc-functions details -- including write .emmc function custom contrasts.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmeans.html","id":"weights","dir":"Reference","previous_headings":"","what":"Weights","title":"Estimated marginal means (Least-squares means) — emmeans","text":"weights vector, length must equal   number predictions averaged obtain EMM.   matrix, row matrix used turn, wrapping back   first row needed.  doubt averaged (  many), first call emmeans weights = \"show.levels\". weights string, partially match one following: \"equal\" Use equally weighted average. \"proportional\" Weight proportion frequencies (  original data) factor combinations averaged . \"outer\" Weight proportion individual factor's   marginal frequencies. Thus, weights combination factors   outer product one-factor margins \"cells\" Weight according frequencies cells   averaged. \"flat\" Give equal weight cells data, ignore   empty cells. \"show.levels\" convenience feature understanding   averaged . Instead table EMMs, causes   function return table showing levels averaged ,   order appear. Outer weights like 'expected' counts chi-square test independence, yield results obtained proportional averaging one factor time. except \"cells\" uses set weights mean. model predicted values cell means, cell weights yield raw averages data factors involved. Using \"flat\" similar \"cells\", except nonempty cells weighted equally empty cells ignored.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmeans.html","id":"offsets","dir":"Reference","previous_headings":"","what":"Offsets","title":"Estimated marginal means (Least-squares means) — emmeans","text":"Unlike ref_grid, offset need scalar. enough values supplied, cyclically recycled. vector offsets,  important understand ordering results goes first  name specs varying fastest. factors, vary slower primary ones, first variable varies fastest within hierarchy. See examples.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmeans.html","id":"options-and-","dir":"Reference","previous_headings":"","what":"Options and ...","title":"Estimated marginal means (Least-squares means) — emmeans","text":"Arguments go options may instead included ...,   typically, arguments type, infer, etc. essence   passed summary.emmGrid. Arguments places    overridden ones .... danger ... arguments partially match used   ref_grid update.emmGrid, creating conflict.   occur, usually can resolved providing complete (least    longer) argument names; isolating non-ref_grid arguments   options; calling ref_grid separately passing   result object. See -run example . Also, specs two-sided formula, contr specified,   potential confusion concerning ... arguments   apply means, contrasts. confusion possible,   suggest things separately    (call emmeans contrasts, followed call    contrast). treat   adjust special case: applied emmeans results      contrasts specified, otherwise passed contrast.","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/emmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimated marginal means (Least-squares means) — emmeans","text":"","code":"warp.lm <- lm(breaks ~ wool * tension, data = warpbreaks) emmeans (warp.lm,  ~ wool | tension) #> tension = L: #>  wool emmean   SE df lower.CL upper.CL #>  A      44.6 3.65 48     37.2     51.9 #>  B      28.2 3.65 48     20.9     35.6 #>  #> tension = M: #>  wool emmean   SE df lower.CL upper.CL #>  A      24.0 3.65 48     16.7     31.3 #>  B      28.8 3.65 48     21.4     36.1 #>  #> tension = H: #>  wool emmean   SE df lower.CL upper.CL #>  A      24.6 3.65 48     17.2     31.9 #>  B      18.8 3.65 48     11.4     26.1 #>  #> Confidence level used: 0.95  # or equivalently emmeans(warp.lm, \"wool\", by = \"tension\")  # 'adjust' argument ignored in emmeans, passed to contrast part... emmeans (warp.lm, poly ~ tension | wool, adjust = \"sidak\") #> $emmeans #> wool = A: #>  tension emmean   SE df lower.CL upper.CL #>  L         44.6 3.65 48     37.2     51.9 #>  M         24.0 3.65 48     16.7     31.3 #>  H         24.6 3.65 48     17.2     31.9 #>  #> wool = B: #>  tension emmean   SE df lower.CL upper.CL #>  L         28.2 3.65 48     20.9     35.6 #>  M         28.8 3.65 48     21.4     36.1 #>  H         18.8 3.65 48     11.4     26.1 #>  #> Confidence level used: 0.95  #>  #> $contrasts #> wool = A: #>  contrast  estimate   SE df t.ratio p.value #>  linear      -20.00 5.16 48  -3.878  0.0006 #>  quadratic    21.11 8.93 48   2.363  0.0439 #>  #> wool = B: #>  contrast  estimate   SE df t.ratio p.value #>  linear       -9.44 5.16 48  -1.831  0.1412 #>  quadratic   -10.56 8.93 48  -1.182  0.4272 #>  #> P value adjustment: sidak method for 2 tests  #>   # 'adjust' argument NOT ignored ... emmeans (warp.lm, ~ tension | wool, adjust = \"sidak\") #> wool = A: #>  tension emmean   SE df lower.CL upper.CL #>  L         44.6 3.65 48    35.53     53.6 #>  M         24.0 3.65 48    14.98     33.0 #>  H         24.6 3.65 48    15.53     33.6 #>  #> wool = B: #>  tension emmean   SE df lower.CL upper.CL #>  L         28.2 3.65 48    19.20     37.2 #>  M         28.8 3.65 48    19.76     37.8 #>  H         18.8 3.65 48     9.76     27.8 #>  #> Confidence level used: 0.95  #> Conf-level adjustment: sidak method for 3 estimates    if (FALSE) {   ### Offsets: Consider a silly example:   emmeans(warp.lm, ~ tension | wool, offset = c(17, 23, 47)) @ grid   # note that offsets are recycled so that each level of tension receives   # the same offset for each wool.   # But using the same offsets with ~ wool | tension will probably not   # be what you want because the ordering of combinations is different. }"},{"path":"https://rvlenth.github.io/emmeans/reference/emmGrid-class.html","id":null,"dir":"Reference","previous_headings":"","what":"The emmGrid class — emmGrid-class","title":"The emmGrid class — emmGrid-class","text":"emmGrid class encapsulates linear functions regression parameters, defined grid predictors. includes reference grids grids marginal means thereof (aka estimated marginal means). Objects class `emmGrid` may used independently underlying model object. Instances created primarily ref_grid emmeans, several related functions.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmGrid-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"The emmGrid class — emmGrid-class","text":"model.info list. Contains elements call (call produced model), terms (terms object), xlev (factor-level information) roles list. Contains least elements predictors,  responses, multresp. character vector names  variables. grid data.frame. Contains combinations variables define reference grid. addition, auxiliary column named \".wgt.\" holding observed frequencies weights factor combination (excluding covariates). model one offset() calls, another auxiliary column named \".offset.\". Auxiliary columns considered part reference grid. (However, variables included offset calls reference grid.) levels list. entry character vector distinct levels variable reference grid. Note grid obtained applying function expand.grid list matlevs list. Like levels levels matrices original dataset. Matrix columns always concatenated treated single variable purposes reference grid linfct matrix. row consists linear function regression coefficients predicting corresponding element reference grid. rows matrix go one--one correspondence rows grid, columns elements bhat. bhat numeric. regression coefficients. multivariate response, matrix coefficients flattened single vector, linfct V redefined appropriately. Important: bhat must include NA values produced result  collinearity predictors. taken care later  estimability check. nbasis matrix. basis non-estimable functions regression coefficients. Every EMM correspond linear combination rows linfct, result must orthogonal columns nbasis order estimable. everything estimable, nbasis 1 x 1 matrix NA. V matrix. symmetric variance-covariance matrix bhat dffun function two arguments. dffun(k, dfargs) return degrees freedom linear function sum(k*bhat), NA unavailable dfargs list. Used hold additional information needed dffun. misc list. Additional information used methods. include least following: estName (label estimates linear functions), default values infer, level, adjust used summary.emmGrid method. Elements slot may modified desired using update.emmGrid method. post.beta matrix. sample posterior distribution regression coefficients, MCMC methods used; 1 x 1 matrix NA otherwise. non-trivial, .mcmc.emmGrid method returns post.beta %*% t(linfct), sample posterior distribution EMMs.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmGrid-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"The emmGrid class — emmGrid-class","text":"methods objects S3 methods except show.    include [.emmGrid, .glht.emmGrid,   .mcmc.emmGrid, .mcmc.list.emmGrid (see coda),   cld.emmGrid (see multcomp),   coef.emmGrid, confint.emmGrid,    contrast.emmGrid, pairs.emmGrid,   plot.emmGrid, predict.emmGrid, print.emmGrid,   rbind.emmGrid, show.emmGrid, str.emmGrid,    summary.emmGrid, test.emmGrid,    update.emmGrid, vcov.emmGrid,    xtable.emmGrid","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmGrid-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Miscellaneous methods for emmGrid objects — str.emmGrid","title":"Miscellaneous methods for emmGrid objects — str.emmGrid","text":"Miscellaneous methods emmGrid objects","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmGrid-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Miscellaneous methods for emmGrid objects — str.emmGrid","text":"","code":"# S3 method for emmGrid str(object, ...)  # S3 method for emmGrid print(x, ..., export = FALSE)  # S3 method for emmGrid vcov(object, ..., sep = get_emm_option(\"sep\"))"},{"path":"https://rvlenth.github.io/emmeans/reference/emmGrid-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Miscellaneous methods for emmGrid objects — str.emmGrid","text":"object emmGrid object ... (required used) x emmGrid object export Logical value. FALSE, object printed.  TRUE, list invisibly returned, contains character elements named summary annotations may saved  displayed user sees fit. summary character matrix  (list matrices, variable effect). annotations character vector annotations  printed summary summaries. sep separator pasting levels creating row column names vcov() results","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmGrid-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Miscellaneous methods for emmGrid objects — str.emmGrid","text":"vcov method returns symmetric matrix variances   covariances predict.emmGrid(object, type = \"lp\")","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmGrid-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Miscellaneous methods for emmGrid objects — str.emmGrid","text":"","code":"warp.lm <- lm(breaks ~ wool * tension, data = warpbreaks) warp.emm <- emmeans(warp.lm, ~ tension | wool) vcov(warp.emm) |> zapsmall() #>          L A      M A      H A      L B      M B      H B #> L A 13.29887  0.00000  0.00000  0.00000  0.00000  0.00000 #> M A  0.00000 13.29887  0.00000  0.00000  0.00000  0.00000 #> H A  0.00000  0.00000 13.29887  0.00000  0.00000  0.00000 #> L B  0.00000  0.00000  0.00000 13.29887  0.00000  0.00000 #> M B  0.00000  0.00000  0.00000  0.00000 13.29887  0.00000 #> H B  0.00000  0.00000  0.00000  0.00000  0.00000 13.29887  vcov(pairs(warp.emm), sep = \"|\") |> zapsmall() #>           L - M|A  L - H|A   M - H|A   L - M|B  L - H|B   M - H|B #> L - M|A  26.59774 13.29887 -13.29887   0.00000  0.00000   0.00000 #> L - H|A  13.29887 26.59774  13.29887   0.00000  0.00000   0.00000 #> M - H|A -13.29887 13.29887  26.59774   0.00000  0.00000   0.00000 #> L - M|B   0.00000  0.00000   0.00000  26.59774 13.29887 -13.29887 #> L - H|B   0.00000  0.00000   0.00000  13.29887 26.59774  13.29887 #> M - H|B   0.00000  0.00000   0.00000 -13.29887 13.29887  26.59774"},{"path":"https://rvlenth.github.io/emmeans/reference/emmip.html","id":null,"dir":"Reference","previous_headings":"","what":"Interaction-style plots for estimated marginal means — emmip","title":"Interaction-style plots for estimated marginal means — emmip","text":"Creates interaction plot EMMs based fitted model simple formula specification.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interaction-style plots for estimated marginal means — emmip","text":"","code":"emmip(object, formula, ...)  # S3 method for default emmip(object, formula, type, CIs = FALSE, PIs = FALSE,   style, engine = get_emm_option(\"graphics.engine\"), plotit = TRUE,   nesting.order = FALSE, ...)  emmip_ggplot(emms, style = \"factor\", dodge = 0.1, xlab = labs$xlab,   ylab = labs$ylab, tlab = labs$tlab, facetlab = \"label_context\", scale,   dotarg = list(shape = \"circle\"), linearg = list(linetype = \"solid\"),   CIarg = list(lwd = 2, alpha = 0.5), PIarg = list(lwd = 1.25, alpha =   0.33), col, ...)  emmip_lattice(emms, style = \"factor\", xlab = labs$xlab, ylab = labs$ylab,   tlab = labs$tlab, pch = c(1, 2, 6, 7, 9, 10, 15:20), lty = 1,   col = NULL, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/emmip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interaction-style plots for estimated marginal means — emmip","text":"object object class emmGrid, fitted model class supported emmeans package formula Formula form  trace.factors ~ x.factors | .factors. EMMs plotted x.factor level trace.factors. .factors optional, present, determines separate panels. element formula may single factor model, combination factors using * operator. ... Additional arguments passed emmeans (object already emmGrid object), predict.emmGrid,  emmip_ggplot, emmip_lattice. type predict.emmGrid, determines whether want inverse-transform predictions (type = \"response\") (choice). default \"link\", unless \"predict.type\" option force; see emm_options. addition, user may specify type = \"scale\" create transformed scale vertical axis based object's response  transformation link function. CIs Logical value. TRUE, confidence intervals (HPD intervals Bayesian models) added plot  (works engine = \"ggplot\"). PIs Logical value. TRUE, prediction intervals added plot  (works engine = \"ggplot\"). allowed underlying model family \"gaussian\". CIs PIs TRUE, prediction intervals somewhat longer, lighter, thinner confidence intervals. Additional parameters predict.emmGrid (e.g., sigma) may passed via .... Bayesian models, PIs require frequentist = TRUE  value sigma. style Optional character value. effect horizontal variable single numeric variable. style unspecified \"numeric\", horizontal scale numeric curves plotted using lines (symbols). style = \"factor\", horizontal variable treated levels factor (equally spaced along horizontal scale), curves plotted using lines symbols. horizontal variable character factor, combination one predictor, \"factor\" style always used. engine Character value matching \"ggplot\" (default),  \"lattice\", \"none\". graphics engine used produce plot. require, respectively, ggplot2 lattice package installed. Specifying \"none\" equivalent setting plotit = FALSE. plotit Logical value. TRUE, graphical object returned; FALSE, data.frame returned containing values used construct plot. nesting.order Logical value. TRUE, factors nested presented order according nesting factors, even nesting factors present formula. FALSE, variables formula used order variables. emms data.frame created calling emmip plotit = FALSE. Certain variables attributes expected exist data frame; see section detailing rendering functions. dodge Numerical amount passed ggplot2::position_dodge  points intervals offset collide. xlab, ylab, tlab Character labels horizontal axis, vertical axis, traces (different curves), respectively. emmip function generates automatically provides therm via labs  attribute, user may override desired. facetlab Labeller facets (variables play). Use \"label_value\" show just factor levels, \"label_both\" show factor names factor levels. default \"label_context\" decides based many factors . See documentation ggplot2::label_context. scale missing, object class scales::trans specifying (usually) nonlinear scaling vertical axis. example,  scales = scales::log_trans() specifies logarithmic scale. fine-tuning purposes, additional arguments ggplot2::scale_y_continuous may included ... . dotarg list arguments passed geom_point customize appearance points linearg list arguments passed geom_line customize appearance lines CIarg, PIarg lists arguments passed geom_linerange customize appearance intervals. (Note: linetype aesthetic defaults \"solid\" hood) col emmip_ggplot, adds color = col (colour) *arg lists. intended setting common color everything, black--white plot.  emmip_lattice, col specifies colors use group, recycled needed. specified, default trellis colors used. pch (Lattice ) plotting characters use group (.e., levels trace.factors). recycled needed. lty (Lattice ) line types use group. Recycled needed.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interaction-style plots for estimated marginal means — emmip","text":"plotit = FALSE, data.frame (actually,  summary_emm object) table EMMs plotted.   variables plotted named xvar yvar, trace   factor named tvar. data frame added \"labs\" attribute containing labels xlab, ylab, tlab respective variables. confidence limits also   included, renamed LCL UCL. plotit = TRUE, function   returns object class \"ggplot\" \"trellis\", depending   engine.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmip.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Interaction-style plots for estimated marginal means — emmip","text":"Conceptually, function equivalent    interaction.plot summarization function thought    return EMMs.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmip.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interaction-style plots for estimated marginal means — emmip","text":"object fitted model, emmeans called appropriate specification obtain estimated marginal means combination factors present formula (addition,  arguments ... match , trend,  cov.reduce, fac.reduce passed emmeans).  Otherwise, object emmGrid object, first element  used, must contain one estimate combination factors present formula.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmip.html","id":"rendering-functions","dir":"Reference","previous_headings":"","what":"Rendering functions","title":"Interaction-style plots for estimated marginal means — emmip","text":"functions emmip_ggplot emmip_lattice called plotit == TRUE render plots;  may also called later object saved via plotit = FALSE (engine = \"none\"). functions require emms contains variables xvar, yvar, tvar, attributes \"labs\" \"vars\". Confidence intervals plotted variables LCL UCL exist; prediction intervals plotted LPL UPL exist. Finally, must contain variables named attr(emms, \"vars\"). emmip_ggplot, colors, linetypes, shapes assigned groups (according tvar) unless overridden. , example, one may  different symbols group simply specifying dotarg = list().","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/emmip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interaction-style plots for estimated marginal means — emmip","text":"","code":"#--- Three-factor example noise.lm = lm(noise ~ size * type * side, data = auto.noise)  # Separate interaction plots of size by type, for each side emmip(noise.lm, type ~ size | side)   # One interaction plot, using combinations of size and side as the x factor # ... with added confidence intervals and some formatting changes emmip(noise.lm, type ~ side * size, CIs = TRUE,     CIarg = list(lwd = 1, alpha = 1, color = \"cyan\"),     dotarg = list(color = \"black\"))   # Create a black-and-white version of above with different linetypes # (Let the linetypes and symbols default to the palette) emmip(noise.lm, type ~ side * size, CIs = TRUE, col = \"black\",       linearg = list(), dotarg = list(size = 2), CIarg = list(alpha = 1)) +     ggplot2::theme_bw()   # One interaction plot using combinations of type and side as the trace factor emmip(noise.lm, type * side ~ size)   # Individual traces in panels emmip(noise.lm, ~ size | type * side)   # Example for the 'style' argument fib.lm = lm(strength ~ machine * sqrt(diameter), data = fiber) fib.rg = ref_grid(fib.lm, at = list(diameter = c(3.5, 4, 4.5, 5, 5.5, 6)^2)) emmip(fib.rg, machine ~ diameter)   # curves (because diameter is numeric)  emmip(fib.rg, machine ~ diameter, style = \"factor\")  # points and lines   # For an example using extra ggplot2 code, see 'vignette(\"messy-data\")', # in the section on nested models.  ### Options with transformations or link functions neuralgia.glm <- glm(Pain ~ Treatment * Sex + Age, family = binomial(),                       data = neuralgia)   # On link scale: emmip(neuralgia.glm, Treatment ~ Sex)   # On response scale: emmip(neuralgia.glm, Treatment ~ Sex, type = \"response\")   # With transformed axis scale and custom scale divisions emmip(neuralgia.glm, Treatment ~ Sex, type = \"scale\",     breaks = seq(0.10, 0.90, by = 0.10))"},{"path":"https://rvlenth.github.io/emmeans/reference/emmobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct an emmGrid object from scratch — emmobj","title":"Construct an emmGrid object from scratch — emmobj","text":"allows user incorporate results obtained analysis emmGrid object, enabling use emmGrid methods perform related follow-analyses.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct an emmGrid object from scratch — emmobj","text":"","code":"emmobj(bhat, V, levels, linfct = diag(length(bhat)), df = NA, dffun,   dfargs = list(), post.beta = matrix(NA), nesting = NULL, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/emmobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct an emmGrid object from scratch — emmobj","text":"bhat Numeric. Vector regression coefficients V Square matrix. Covariance matrix bhat levels Named list vector. Levels factor(s) define estimates defined linfct. list, assume one factor named \"level\" linfct Matrix. Linear functions bhat combination  levels. df Numeric value function arguments (x, dfargs). number, used degrees freedom. function, return degrees freedom sum(x*bhat), additional parameters dfargs. dffun Overrides df specified. convenience match slot names returned object. dfargs List containing arguments df. ignored df numeric. post.beta Matrix whose columns comprise sample posterior distribution regression coefficients (typically, column averages bhat). 1 x 1 matrix NA indicates sample unavailable. nesting Nesting specification ref_grid. ignored model.info supplied. ... Arguments passed update.emmGrid","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct an emmGrid object from scratch — emmobj","text":"emmGrid object","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emmobj.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct an emmGrid object from scratch — emmobj","text":"arguments must conformable. includes length  bhat, number columns linfct, number  columns post.beta must equal. product  lengths levels must equal number rows  linfct. grid slot returned object generated   expand.grid using levels arguments.  rows linfct corresponding order. functions qdrg emmobj close cousins, produce emmGrid objects. starting summary statistics existing grid, emmobj useful, qdrg useful starting unsupported fitted model.","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/emmobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct an emmGrid object from scratch — emmobj","text":"","code":"# Given summary statistics for 4 cells in a 2 x 2 layout, obtain  # marginal means and comparisons thereof. Assume heteroscedasticity # and use the Satterthwaite method levels <- list(trt = c(\"A\", \"B\"), dose = c(\"high\", \"low\")) ybar <- c(57.6, 43.2, 88.9, 69.8) s <-    c(12.1, 19.5, 22.8, 43.2) n <-    c(44,   11,   37,   24) se2 = s^2 / n Satt.df <- function(x, dfargs)     sum(x * dfargs$v)^2 / sum((x * dfargs$v)^2 / (dfargs$n - 1))      expt.rg <- emmobj(bhat = ybar, V = diag(se2),     levels = levels, linfct = diag(c(1, 1, 1, 1)),     df = Satt.df, dfargs = list(v = se2, n = n), estName = \"mean\") plot(expt.rg)   ( trt.emm <- emmeans(expt.rg, \"trt\") ) #>  trt mean   SE   df lower.CL upper.CL #>  A   73.2 2.08 52.6     69.1     77.4 #>  B   56.5 5.30 33.0     45.7     67.3 #>  #> Results are averaged over the levels of: dose  #> Confidence level used: 0.95  ( dose.emm <- emmeans(expt.rg, \"dose\") ) #>  dose mean   SE   df lower.CL upper.CL #>  high 50.4 3.08 12.0     43.7     57.1 #>  low  79.3 4.79 31.4     69.6     89.1 #>  #> Results are averaged over the levels of: trt  #> Confidence level used: 0.95   rbind(pairs(trt.emm), pairs(dose.emm), adjust = \"mvt\") #>  contrast   estimate   SE    df t.ratio p.value #>  A - B          16.8 5.69 23.23   2.941  0.0143 #>  high - low    -28.9 5.69  7.49  -5.084  0.0027 #>  #> Results are averaged over some or all of the levels of: dose, trt  #> P value adjustment: mvt method for 2 tests"},{"path":"https://rvlenth.github.io/emmeans/reference/emm_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Run or list additional examples — emm_example","title":"Run or list additional examples — emm_example","text":"function exists provide cleaner-looking examples help files must run conditionally another package. Typically want run code (run = TRUE default), otherwise just list console (list = TRUE).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emm_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run or list additional examples — emm_example","text":"","code":"emm_example(name, run = !list, list = FALSE, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/emm_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run or list additional examples — emm_example","text":"name Character name file run. look file name (\".R\" appended) system files provided emmeans. run Logical choosing whether run example code list Logical choosing whether list example code ... Used developer","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emm_example.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run or list additional examples — emm_example","text":"","code":"# List an example emm_example(\"qdrg-biglm\", list = TRUE) #> # Post hoc analysis of a \"biglm\" object -- not supported by emmeans #> bigmod <- biglm(log(conc) ~ source + factor(percent), data = pigs) #>  #> rg1 <- qdrg(log(conc) ~ source + factor(percent), data = pigs,  #>     coef = coef(bigmod), vcov = vcov(bigmod), df = bigmod$df.residual) #>  #> emmeans(rg1, \"source\", type = \"response\") #>  #> ## But in this particular case, we could have done it the easy way: #> ##     rg1 <- qdrg(object = bigmod) #>   # Run an example if (require(biglm))     emm_example(\"qdrg-biglm\") #> Loading required package: biglm #> Loading required package: DBI #>  #> --- Running code from 'system.file(\"extexamples\", \"qdrg-biglm.R\", package = \"emmeans\")' #>  #> > bigmod <- biglm(log(conc) ~ source + factor(percent),  #> +     data = pigs) #>  #> > rg1 <- qdrg(log(conc) ~ source + factor(percent),  #> +     data = pigs, coef = coef(bigmod), vcov = vcov(bigmod), df = bigmod$df.residual) #>  #> > emmeans(rg1, \"source\", type = \"response\") #>  source response   SE  df asymp.LCL asymp.UCL #>  fish       29.8 1.09 Inf      27.7      32.0 #>  soy        39.1 1.47 Inf      36.4      42.1 #>  skim       44.6 1.75 Inf      41.2      48.1 #>  #> Results are averaged over the levels of: percent  #> Confidence level used: 0.95  #> Intervals are back-transformed from the log scale  #>"},{"path":"https://rvlenth.github.io/emmeans/reference/emm_list-object.html","id":null,"dir":"Reference","previous_headings":"","what":"The emm_list class — emm_list","title":"The emm_list class — emm_list","text":"emm_list object simply list emmGrid objects. list returned, example, emmeans two-sided formula list specs argument. Several methods class provided, detailed . Typically, methods just quietly thing emmGrid methods, using first element list. can specify select different element, just run corresponding emmGrid method object[[k]].","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emm_list-object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The emm_list class — emm_list","text":"","code":"# S3 method for emm_list contrast(object, ..., which = 1)  # S3 method for emm_list pairs(x, ..., which = 1)  # S3 method for emm_list test(object, ..., which = seq_along(object))  # S3 method for emm_list confint(object, ..., which = seq_along(object))  # S3 method for emm_list plot(x, ..., which = 1)  # S3 method for emm_list coef(object, ..., which = 2)  # S3 method for emm_list str(object, ...)  # S3 method for emm_list summary(object, ..., which = seq_along(object))  # S3 method for emm_list print(x, ...)  # S3 method for emm_list as.data.frame(x, ...)  # S3 method for summary_eml as.data.frame(x, row.names = NULL, optional = FALSE,   which, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/emm_list-object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The emm_list class — emm_list","text":"object, x object class emm_list ... additional arguments passed corresponding emmGrid method integer vector specifying elements select. row.names, optional Required arguments .data.frame, ignored","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emm_list-object.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The emm_list class — emm_list","text":"list objects returned corresponding emmGrid method (thus, often, another emm_list object). However,  length 1, one result wrapped list. summary.emm_list returns object class summary_eml, list summary_emm objects. .data.frame methods return single data frame via .data.frame(rbind(x)). See also rbind.emm_list .data.frame.emmGrid","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emm_list-object.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"The emm_list class — emm_list","text":"plot method uses first element ; others ignored. export option provided printing emm_list (see print.emmGrid). wish export objects,  must separately element list.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emm_options.html","id":null,"dir":"Reference","previous_headings":"","what":"Set or change emmeans options — emm_options","title":"Set or change emmeans options — emm_options","text":"Use emm_options set change various options used emmeans package. options set separately different contexts emmGrid objects created, named list option lists.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emm_options.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set or change emmeans options — emm_options","text":"","code":"emm_options(..., disable)  get_emm_option(x, default = emm_defaults[[x]])  emm_defaults"},{"path":"https://rvlenth.github.io/emmeans/reference/emm_options.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Set or change emmeans options — emm_options","text":"object class list length 21.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emm_options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set or change emmeans options — emm_options","text":"... Option names values (see Details) disable non-missing, reset options defaults  disable tests TRUE (first save possible later  restoration). Otherwise, previously saved options restored. important bug reporting; please see section reproducible bugs. disable specified, arguments ignored. x Character value - name option queried default Value return x found","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emm_options.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set or change emmeans options — emm_options","text":"emm_options returns current options (result    getOption(\"emmeans\")) -- invisibly, unless called arguments. get_emm_option returns currently stored option x,    default value found.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emm_options.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set or change emmeans options — emm_options","text":"emmeans's options stored list system option \"emmeans\".  Thus, emm_options(foo = bar)  options(emmeans = list(..., foo = bar)) ... represents previously existing options. list emm_defaults contains default values case corresponding element system option emmeans NULL. Currently, following main list entries supported: ref_grid named list defaults objects created ref_grid. affect objects well. example, emmeans called fitted model object, calls ref_grid option affect resulting emmGrid object. emmeans named list defaults objects created   emmeans emtrends. contrast named list defaults objects created   contrast.emmGrid pairs.emmGrid. summary named list defaults used methods   summary.emmGrid, predict.emmGrid, test.emmGrid,   confint.emmGrid, emmip. option can   affect latter four \"predict.method\". sep character value use separator labeling factor combinations.   labels potentially used several places contrast    plot.emmGrid combinations factors compared plotted.   default \" \". parens Character vector determines labels parenthesized   contrasted. first element regular expression, second   third elements used left right parentheses.    See details parens argument contrast. default   parenthesize labels containing four arithmetic operators,    using round parentheses. cov.keep default value cov.keep ref_grid.   Defaults \"2\", .e., two-level covariates treated like factors. graphics.engine character value matching    c(\"ggplot\", \"lattice\"), setting default engine use   emmip plot.emmGrid.  Defaults \"ggplot\". msg.interaction logical value controlling whether   message displayed emmeans averages factor involved   interaction. probably appropriate , unless   interaction weak. Defaults TRUE. msg.nesting logical value controlling whether   display message nesting structure auto-detected. existence   structure affects computations EMMs. Sometimes, nesting   structure falsely detected -- namely user omitted   main effects included interactions. change   model fit, produces different parameterization picked   reference grid constructed. Defaults TRUE. rg.limit integer value setting limit number rows   newly constructed reference grid. checked based number   levels factors involved; excludes levels multivariate   responses yet known. reference grid consists   possible combinations predictors, can become huge   several factors. error thrown limit exceeded. One can use    nuisance argument ref_grid collapse nuisance   factors, thus making grid smaller. Defaults 10,000. simplify.names logical value controlling whether   simplify (possible) names model formula refer datasets --   example, simplify predictor name like “data$trt”   just “trt”? Defaults TRUE. opt.digits logical value controlling precision   summaries printed. TRUE (default), number digits   displayed just enough reasonably distinguish estimates ends   confidence intervals; always least 3 digits.   FALSE, system value getOption(\"digits\") used. back.bias.adj logical value controlling whether    try adjust bias back-transforming. FALSE, use naive   back transformation. TRUE sigma available valid,   second-order adjustment applied estimate mean response   scale. warning issued valid sigma available enable.submodel logical value. TRUE, enables support    selected model classes implement submodel option.   FALSE, support disabled. Setting option FALSE   save excess memory consumption. options specific purposes: estble.tol Tolerance determining estimability rank-deficient cases. absent, value emm_defaults$estble.tol) used. save.ref_grid Logical value TRUE wish  latest reference grid created saved .Last.ref_grid. default FALSE. Options lme4::lmerMod models Options lmer.df, disable.pbkrtest, pbkrtest.limit, disable.lmerTest, lmerTest.limit options affect degrees freedom computed lmerMod objects produced lme4 package). See section \"models\" vignette details.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emm_options.html","id":"reproducible-bugs","dir":"Reference","previous_headings":"","what":"Reproducible bugs","title":"Set or change emmeans options — emm_options","text":"options set display attributes likely associated bugs code. However, options (e.g., cov.keep) essentially configuration settings may affect /whether code runs, settings options may cause subtle effects may hard reproduce. Therefore, sending bug report, please create reproducible example make sure bug occurs options set defaults. done preceding  emm_options(disable = TRUE). way, disable works like stack (LIFO buffer), disable = TRUE equivalent emm_options(saved.opts = emm_options())  emm_options(disable = FALSE) equivalent  options(emmeans = get_emm_option(\"saved.opts\")). completely erase options, use options(emmeans = NULL)","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/emm_options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set or change emmeans options — emm_options","text":"","code":"if (FALSE) { emm_options(ref_grid = list(level = .90),             contrast = list(infer = c(TRUE,FALSE)),             estble.tol = 1e-6) # Sets default confidence level to .90 for objects created by ref.grid # AS WELL AS emmeans called with a model object (since it creates a  # reference grid). In addition, when we call 'contrast', 'pairs', etc., # confidence intervals rather than tests are displayed by default. }  if (FALSE) { emm_options(disable.pbkrtest = TRUE) # This forces use of asymptotic methods for lmerMod objects. # Set to FALSE or NULL to re-enable using pbkrtest. }  # See tolerance being used for determining estimability get_emm_option(\"estble.tol\") #> [1] 1e-08  if (FALSE) { # Set all options to their defaults emm_options(disable = TRUE) # ... and perhaps follow with code for a minimal reproducible bug, #     which may include emm_options() clls if they are pertinent ...  # restore options that had existed previously emm_options(disable = FALSE) }"},{"path":"https://rvlenth.github.io/emmeans/reference/emtrends.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimated marginal means of linear trends — emtrends","title":"Estimated marginal means of linear trends — emtrends","text":"emtrends function useful fitted model involves numerical predictor \\(x\\)  interacting another predictor (typically factor). models specify \\(x\\) different trend depending \\(\\); thus, may interest estimate compare trends. Analogous emmeans setting, construct reference grid predicted trends, possibly average predictors grid.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emtrends.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimated marginal means of linear trends — emtrends","text":"","code":"emtrends(object, specs, var, delta.var = 0.001 * rng, max.degree = 1, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/emtrends.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimated marginal means of linear trends — emtrends","text":"object supported model object (reference grid) specs Specifications marginal trends desired -- emmeans. specs missing NULL, emmeans run reference grid specified trends returned. var Character value giving name variable respect  difference quotient linear predictors computed. order useful, var numeric predictor interacts least one factor specs. instead computing EMMs, compute compare slopes var trend levels specified predictor(s). EMMs, marginal averages computed predictors specs . See also “Generalizations” section . delta.var value h use forming difference quotient \\((f(x+h) - f(x))/h\\). Changing (especially changing sign) may necessary avoid numerical problems logs negative numbers. default value 1/1000 range var dataset. max.degree Integer value. maximum degree trends compute (capped 5). greater 1, additional factor degree added grid, corresponding numerical derivatives orders 1, 2, ..., max.degree estimates. ... Additional arguments passed ref_grid  emmeans appropriate. See Details.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emtrends.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimated marginal means of linear trends — emtrends","text":"emmGrid emm_list object, according specs. See emmeans details list returned.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emtrends.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimated marginal means of linear trends — emtrends","text":"function works constructing reference grids object  various values var, calculating difference quotients predictions reference grids. Finally, emmeans called given specs, thus computing marginal averages needed difference quotients. ... arguments passed ref_grid emmeans; examples optional arguments include optional arguments (often mode) apply specific models; ref_grid options data, , cov.reduce, mult.names, nesting, transform; emmeans options weights (please avoid trend offset.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emtrends.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Estimated marginal means of linear trends — emtrends","text":"earlier versions emtrends, first argument named model rather object. (name changed potential mis-matching mode argument, option several types models.) backward compatibility, model still works provided arguments named. important understand trends computed emtrends equivalent polynomial contrasts parallel model var regarded factor. model object assumed fit smooth function var, estimated trends reflect local behavior particular value(s) var; whereas var modeled factor polynomial contrasts computed, contrasts represent global pattern changes levels var. See pigs.poly pigs.fact examples illustration. linear quadratic trends depend value  percent, cubic trend constant (true cubic polynomial, underlying model). cubic contrast factorial model P value cubic trend, cubic trend everywhere.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/emtrends.html","id":"generalizations","dir":"Reference","previous_headings":"","what":"Generalizations","title":"Estimated marginal means of linear trends — emtrends","text":"Instead single predictor, user may specify monotone function one variable, e.g., var = \"log(dose)\". , chain rule applied. Note , example, object contains log(dose) predictor, comparing slopes estimated model, whereas specifying var = \"dose\" perform transformation slopes, making predicted trends vary depending dose.","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/emtrends.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimated marginal means of linear trends — emtrends","text":"","code":"fiber.lm <- lm(strength ~ diameter*machine, data=fiber) # Obtain slopes for each machine ... ( fiber.emt <- emtrends(fiber.lm, \"machine\", var = \"diameter\") ) #>  machine diameter.trend    SE df lower.CL upper.CL #>  A                1.104 0.194  9    0.666     1.54 #>  B                0.857 0.224  9    0.351     1.36 #>  C                0.864 0.208  9    0.394     1.33 #>  #> Confidence level used: 0.95  # ... and pairwise comparisons thereof pairs(fiber.emt) #>  contrast estimate    SE df t.ratio p.value #>  A - B     0.24714 0.296  9   0.835  0.6919 #>  A - C     0.24008 0.284  9   0.845  0.6863 #>  B - C    -0.00705 0.306  9  -0.023  0.9997 #>  #> P value adjustment: tukey method for comparing a family of 3 estimates   # Suppose we want trends relative to sqrt(diameter)... emtrends(fiber.lm, ~ machine | diameter, var = \"sqrt(diameter)\",           at = list(diameter = c(20, 30))) #> diameter = 20: #>  machine sqrt(diameter).trend   SE df lower.CL upper.CL #>  A                       9.88 1.73  9     5.96     13.8 #>  B                       7.67 2.00  9     3.14     12.2 #>  C                       7.73 1.86  9     3.52     11.9 #>  #> diameter = 30: #>  machine sqrt(diameter).trend   SE df lower.CL upper.CL #>  A                      12.10 2.12  9     7.30     16.9 #>  B                       9.39 2.45  9     3.84     14.9 #>  C                       9.47 2.28  9     4.31     14.6 #>  #> Confidence level used: 0.95   # Obtaining a reference grid mtcars.lm <- lm(mpg ~ poly(disp, degree = 2) * (factor(cyl) + factor(am)), data = mtcars)  # Center trends at mean disp for each no. of cylinders mtcTrends.rg <- emtrends(mtcars.lm, var = \"disp\",                            cov.reduce = disp ~ factor(cyl)) summary(mtcTrends.rg)  # estimated trends at grid nodes #>  disp cyl am disp.trend     SE df #>   105   4  0    -0.0949 0.0829 20 #>   183   6  0    -0.0024 0.0496 20 #>   353   8  0    -0.0106 0.0105 20 #>   105   4  1    -0.1212 0.0338 20 #>   183   6  1    -0.0217 0.0573 20 #>   353   8  1    -0.0147 0.0645 20 #>  emmeans(mtcTrends.rg, \"am\", weights = \"prop\") #>  am disp.trend     SE df lower.CL upper.CL #>   0    -0.0378 0.0312 20   -0.103  0.02733 #>   1    -0.0529 0.0260 20   -0.107  0.00145 #>  #> Results are averaged over the levels of: cyl  #> Confidence level used: 0.95    ### Higher-degree trends ...  pigs.poly <- lm(conc ~ poly(percent, degree = 3), data = pigs) emt <- emtrends(pigs.poly, ~ degree | percent, \"percent\", max.degree = 3,                 at = list(percent = c(9, 13.5, 18)))        # note: 'degree' is an extra factor created by 'emtrends'         summary(emt, infer = c(TRUE, TRUE)) #> percent =  9.0: #>  degree    percent.trend     SE df lower.CL upper.CL t.ratio p.value #>  linear          2.39923 3.6504 25   -5.119    9.917   0.657  0.5170 #>  quadratic      -0.22674 1.1026 25   -2.498    2.044  -0.206  0.8387 #>  cubic           0.00548 0.0825 25   -0.164    0.175   0.066  0.9475 #>  #> percent = 13.5: #>  degree    percent.trend     SE df lower.CL upper.CL t.ratio p.value #>  linear          0.69212 1.5636 25   -2.528    3.912   0.443  0.6618 #>  quadratic      -0.15277 0.1747 25   -0.513    0.207  -0.874  0.3903 #>  cubic           0.00548 0.0825 25   -0.164    0.175   0.066  0.9475 #>  #> percent = 18.0: #>  degree    percent.trend     SE df lower.CL upper.CL t.ratio p.value #>  linear         -0.34928 4.1176 25   -8.830    8.131  -0.085  0.9331 #>  quadratic      -0.07880 1.1505 25   -2.448    2.291  -0.068  0.9459 #>  cubic           0.00548 0.0825 25   -0.164    0.175   0.066  0.9475 #>  #> Confidence level used: 0.95   # Compare above results with poly contrasts when 'percent' is modeled as a factor ... pigs.fact <- lm(conc ~ factor(percent), data = pigs) emm <- emmeans(pigs.fact, \"percent\")  contrast(emm, \"poly\") #>  contrast  estimate    SE df t.ratio p.value #>  linear      23.837 14.74 25   1.617  0.1184 #>  quadratic   -5.500  6.29 25  -0.874  0.3903 #>  cubic        0.888 13.36 25   0.066  0.9475 #>  # Some P values are comparable, some aren't! See Note in documentation"},{"path":"https://rvlenth.github.io/emmeans/reference/extending-emmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Support functions for model extensions — extending-emmeans","title":"Support functions for model extensions — extending-emmeans","text":"documents functions methods may useful package  developers wishing add support emmeans model objects.user package developer may add emmeans support model class writing recover_data emm_basis methods class. (Users need quick way obtain results model supported may better served qdrg function.) several exported functions may useful. See \"xtending\" vignette details.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/extending-emmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Support functions for model extensions — extending-emmeans","text":"","code":"recover_data(object, ...)  # S3 method for call recover_data(object, trms, na.action, data = NULL,   params = \"pi\", frame, pwts, addl.vars, ...)  emm_basis(object, trms, xlev, grid, ...)  .recover_data(object, ...)  .emm_basis(object, trms, xlev, grid, ...)  .emm_register(classes, pkgname)  .std.link.labels(fam, misc)  .combine.terms(...)  .aovlist.dffun(k, dfargs)  .cmpMM(X, weights = rep(1, nrow(X)), assign = attr(X$qr, \"assign\"))  .get.excl(levs, exc, inc)  .get.offset(terms, grid)  .my.vcov(object, vcov. = .statsvcov, ...)  .all.vars(expr, retain = c(\"\\\\$\", \"\\\\[\\\\[\", \"\\\\]\\\\]\", \"'\", \"\\\"\"),   ...)  .diag(x, nrow, ncol)  .num.key(levs, key)  .emm_vignette(css = system.file(\"css\", \"clean-simple.css\", package =   \"emmeans\"), highlight = NULL, ...)  .hurdle.support(cmu, cshape, cp0, cmean, zmu, zshape, zp0)  .zi.support(zmu, zshape, zp0)"},{"path":"https://rvlenth.github.io/emmeans/reference/extending-emmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Support functions for model extensions — extending-emmeans","text":"object object class supported new method. ... Additional parameters may supported method. trms terms component object (typically response deleted, e.g. via delete.response) na.action Integer vector indices observations ignore; NULL none data Data frame. Usually, NULL. However, non-null, used place reconstructed dataset. must predictors used model, factor levels must match used fitting model. params Character vector giving names variables model formula predictors. example, spline model may involve local variable knots predictor, value needed fit model. Names parameters actually used harmless, default value \"pi\" (numeric constant base R) provided case model involves . example involving splines may found https://github.com/rvlenth/emmeans/issues/180. frame Optional data.frame. Many model objects contain  model frame used fitting model. cases  predictor transformations, model frame original predictor values usable recovering data. Thus, frame non-missing data NULL, check made trms function calls, use data = frame. can helpful provides modicum security possibility original data used fitting model altered removed. pwts Optional vector prior weights. Typically, may obtained fitted model via weights(model). provided, used set weights long non-NULL length  number rows data. addl.vars Character value vector specifying additional predictors include reference grid. must names variables exist, get error.  may useful need additional computations later depend variables; e.g.,  bias adjustments random slopes variables among fixed predictors. xlev Named list factor levels (excluding ones coerced  factors model formula) grid data.frame (provided ref_grid) containing  predictor settings needed reference grid classes Character names one classes registered. package must contain functions recover_data.foo emm_basis.foo class foo listed classes. pkgname Character name package providing methods (usually second argument .onLoad) fam Result call family(object) misc list intended @misc slot emmGrid object k, dfargs Arguments .aovlist.dffun, made available  convenience developers providing support similar provided  aovlist objects X, weights, assign Arguments .cmpMM, compacts model matrix X much smaller matrix row space. Specifically, returns R portion QR decomposition. X already class qr, used directly. weights weights used model fit, assign used unravelling pivoting done qr. levs, key .num.key function returns numeric indices levels levs set levels key exc, inc Arguments .get.excl useful writing .emmc functions generating contrast coefficients, supports arguments exclude include excluding specifying levels use. terms terms component vcov. Function matrix returns suitable covariance matrix. default .statsvcov stats::vcov. ..vcov  function called place vcov, supports user  able specify different matrix function via optional vcov. argument. expr, retain Arguments ..vars, alternative .vars special provisions retaining special characters retain, thus allowing model specifications like y ~ data$trt * df[[\"dose\"]] x, nrow, ncol Arguments .diag, alternative  diag lacks idiosyncrasy returning identity matrix x length 1. css, package, highlight Arguments .emm_vignette, clean simple alternative html_document use output style Markdown file. vignettes emmeans package use output style. cmu, zmu .hurdle.support .zi.support,  specify vector back-transformed  estimates count zero model, respectively cshape, zshape Shape parameter count zero model, respectively cp0, zp0 Function (mu, shape) computing Prob(Y = 0) count zero model, respectively cmean Function (mu, shape) computing mean count model. Typically, just returns mu","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/extending-emmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Support functions for model extensions — extending-emmeans","text":"recover_data method must return data.frame containing variables appear predictors model,   attributes \"call\", \"terms\", \"predictors\",   \"responses\". (recover_data.call    provide attributes.) emm_basis method return list   following elements: X matrix linear functions grid,   number rows grid number columns equal length   bhat. bhat vector regression coefficients fixed effects.   include NAs result rank deficiencies. nbasis matrix whose columns form basis non-estimable functions   beta, 1x1 matrix NA rank deficiency. V estimated covariance matrix bhat. dffun function (k, dfargs) returns degrees   freedom associated sum(k * bhat). dfargs list containing additional arguments needed   dffun   .recover_data .emm_basis hidden exported versions  recover_data emm_basis, respectively. run emmeans's   namespace, thus providing access existing methods. .std.link.llabels returns modified version misc appropriate information included corresponding information fam combine.terms returns terms object resulting   combining terms formulas .... .get.offset returns values, based grid,  offset component terms .hurdle.support returns matrix 3 rows containing       estimated mean responses differentials wrt cmu zmu,       resp. .zi.support returns matrix 2 rows containing       estimated probabilities 0 differentials wrt mu.       See section hurdle zero-inflated models.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/extending-emmeans.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Support functions for model extensions — extending-emmeans","text":"Without explicit data argument, recover_data returns    current version dataset. dataset changed    since model fitted, data used fit    model. especially important know simulation studies    data randomly generated permuted, cases    several datasets processed one step (e.g., using dplyr).    cases, users careful provide actual data    used fit model data argument.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/extending-emmeans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Support functions for model extensions — extending-emmeans","text":"create reference grid, ref_grid function needs reconstruct data used fitting model, obtain matrix linear functions regression coefficients given grid predictor values. tasks performed calls recover_data emm_basis respectively. vignette giving details examples available via vignette(\"xtending\", \"emmeans\") extend emmeans's support additional model types, one need write S3 methods two functions. existing methods serve helpful guidance writing new ones.  work recover_data can done method class \"call\", providing terms component na.action data additional arguments. Writing emm_basis method involved, existing methods (e.g., emmeans:::emm_basis.lm) can serve models. Certain recover_data emm_basis methods exported emmeans. (find , methods(\"recover_data\").) object based another model-fitting object, may needed call one exported methods perhaps make modifications results. Contact developer need others exported. model multivariate response, bhat needs “flattened” single vector, X V must constructed consistently. models non-full-rank result possible (often, can tell seeing singular.ok argument model-fitting function), summary.emmGrid relatives check estimability prediction, using nonest.basis function estimability package. models already supported detailed \"models\" vignette. packages may provide additional emmeans support object classes.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/extending-emmeans.html","id":"communication-between-methods","dir":"Reference","previous_headings":"","what":"Communication between methods","title":"Support functions for model extensions — extending-emmeans","text":"recover_data method generates information needed emm_basis, information may incorporated creating \"misc\" attribute returned recovered data. information passed misc  argument ref_grid calls emm_basis.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/extending-emmeans.html","id":"optional-hooks","dir":"Reference","previous_headings":"","what":"Optional hooks","title":"Support functions for model extensions — extending-emmeans","text":"models may need something standard linear estimates standard errors. , custom functions may pointed via items misc$estHook, misc$vcovHook misc$postGridHook. just name hook function provided character string, retrieved using get. estHook function arguments (object, .se, tol, ...) object emmGrid object, .se logical flag whether return standard error, tol tolerance assessing estimability. return matrix 3 columns: estimates, standard errors (NA .se==FALSE), degrees freedom (NA asymptotic). number rows object@linfct. vcovHook function arguments (object, tol, ...) described. return covariance matrix estimates. Finally, postGridHook, present, called end ref_grid; takes one argument, constructed object, return suitably modified emmGrid object.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/extending-emmeans.html","id":"registering-s-methods-for-a-model-class","dir":"Reference","previous_headings":"","what":"Registering S3 methods for a model class","title":"Support functions for model extensions — extending-emmeans","text":".emm_register function provided convenience conditionally  register S3 methods model class, recover_data.foo emm_basis.foo, foo class name. package implement .onLoad function call .emm_register emmeans installed. See example.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/extending-emmeans.html","id":"support-for-hurdle-and-zero-inflated-models","dir":"Reference","previous_headings":"","what":"Support for Hurdle and Zero-inflated models","title":"Support functions for model extensions — extending-emmeans","text":"functions .hurdle.support .zi.support help facilitate   calculations needed estimate mean response (count model zero model   combined) models. .hurdle.support returns matrix three rows.   first estimated mean hurdle model, 2nd 3rd rows   differentials count zero models, needed delta-method   calculations. use , regard @linfct slot comprising   two sets columns, count zero models respectively.   delta method calculations, multiply rows count part    differentials times link$mu.eta evcaluated part linear predictor.   zero part, using differentials mu.eta.   resulting matrix , covariance mean response   AVA' Vis @V slot object. function zi.support works way, much simpler,   used estimate probability 0 differential either    part zero-inflated model hurdle model. See code emm_basis.zeroinfl emm_basis.hurdle   used models fitted pscl package.","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/extending-emmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Support functions for model extensions — extending-emmeans","text":"","code":"if (FALSE) { #--- If your package provides recover_data and emm_grid methods for class 'mymod', #--- put something like this in your package code -- say in zzz.R:   .onLoad <- function(libname, pkgname) {     if (requireNamespace(\"emmeans\", quietly = TRUE))       emmeans::.emm_register(\"mymod\", pkgname)   } }"},{"path":"https://rvlenth.github.io/emmeans/reference/feedlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Feedlot data — feedlot","title":"Feedlot data — feedlot","text":"unbalanced analysis--covariance example, one covariate affected factor. Feeder calves various herds enter feedlot, fed one three diets. weight animal entry covariate, weight slaughter response.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/feedlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Feedlot data — feedlot","text":"","code":"feedlot"},{"path":"https://rvlenth.github.io/emmeans/reference/feedlot.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Feedlot data — feedlot","text":"data frame 67 observations 4 variables: herd factor levels 9 16 3     32 24 31 19 36 34 35     33, designating herd feeder calf came . diet factor levels Low Medium     High: energy level diet given animal. swt numeric vector: weight animal slaughter. ewt numeric vector: weight animal entry feedlot.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/feedlot.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Feedlot data — feedlot","text":"Urquhart NS (1982) Adjustment covariates one factor affects   covariate. Biometrics 38, 651-660.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/feedlot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Feedlot data — feedlot","text":"data arise Western Regional Research Project conducted New Mexico State University. Calves born 1975 commercial herds entered feedlot yearlings. diets herds interest factors. covariate, ewt, thought dependent herd due different genetic backgrounds, breeding history, etc. levels herd ordered similarity genetic background. Note: empty cells cross-classification  herd diet.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/feedlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Feedlot data — feedlot","text":"","code":"feedlot.lm <- lm(swt ~ ewt + herd*diet, data = feedlot)  # Obtain EMMs with a separate reference value of ewt for each  # herd. This reproduces the last part of Table 2 in the reference emmeans(feedlot.lm,  ~ diet | herd,  cov.reduce = ewt ~ herd) #> herd = 9: #>  diet   emmean   SE df lower.CL upper.CL #>  Low       839 32.7 36      773      906 #>  Medium    877 40.1 36      796      958 #>  High   nonEst   NA NA       NA       NA #>  #> herd = 16: #>  diet   emmean   SE df lower.CL upper.CL #>  Low       940 41.3 36      856     1024 #>  Medium    951 60.3 36      829     1073 #>  High   nonEst   NA NA       NA       NA #>  #> herd = 3: #>  diet   emmean   SE df lower.CL upper.CL #>  Low       981 32.8 36      915     1048 #>  Medium   1002 41.2 36      918     1085 #>  High     1015 63.5 36      886     1144 #>  #> herd = 32: #>  diet   emmean   SE df lower.CL upper.CL #>  Low      1003 33.2 36      936     1070 #>  Medium    890 40.2 36      809      972 #>  High      970 32.9 36      904     1037 #>  #> herd = 24: #>  diet   emmean   SE df lower.CL upper.CL #>  Low       982 28.3 36      924     1039 #>  Medium    982 32.7 36      916     1048 #>  High   nonEst   NA NA       NA       NA #>  #> herd = 31: #>  diet   emmean   SE df lower.CL upper.CL #>  Low      1128 32.9 36     1062     1195 #>  Medium   1069 40.4 36      987     1151 #>  High     1111 56.6 36      996     1226 #>  #> herd = 19: #>  diet   emmean   SE df lower.CL upper.CL #>  Low      1087 28.3 36     1030     1145 #>  Medium   1036 40.0 36      955     1117 #>  High      999 56.7 36      884     1114 #>  #> herd = 36: #>  diet   emmean   SE df lower.CL upper.CL #>  Low      1155 40.5 36     1073     1237 #>  Medium   1062 41.3 36      978     1146 #>  High     1191 57.2 36     1075     1307 #>  #> herd = 34: #>  diet   emmean   SE df lower.CL upper.CL #>  Low       987 33.6 36      918     1055 #>  Medium   1015 41.0 36      931     1098 #>  High     1048 40.1 36      967     1129 #>  #> herd = 35: #>  diet   emmean   SE df lower.CL upper.CL #>  Low      1094 29.1 36     1035     1153 #>  Medium   1092 41.8 36     1008     1177 #>  High     1103 40.0 36     1021     1184 #>  #> herd = 33: #>  diet   emmean   SE df lower.CL upper.CL #>  Low      1207 57.3 36     1091     1323 #>  Medium   1031 32.7 36      964     1097 #>  High     1018 56.6 36      903     1133 #>  #> Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/reference/fiber.html","id":null,"dir":"Reference","previous_headings":"","what":"Fiber data — fiber","title":"Fiber data — fiber","text":"Fiber data Montgomery Design (8th ed.), p.656 (Table 15.10). Useful simple analysis--covariance example.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/fiber.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fiber data — fiber","text":"","code":"fiber"},{"path":"https://rvlenth.github.io/emmeans/reference/fiber.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Fiber data — fiber","text":"data frame 15 observations 3 variables: machine factor levels B C.      primary factor interest. strength numeric vector. response variable. diameter numeric vector. covariate.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/fiber.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Fiber data — fiber","text":"Montgomery, D. C. (2013) Design Analysis Experiments   (8th ed.). John Wiley Sons, ISBN 978-1-118-14692-7.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/fiber.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fiber data — fiber","text":"goal experiment compare mean breaking strength fibers produced three machines. testing , technician also measured diameter fiber, measurement may used concomitant variable improve precision estimates.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/fiber.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fiber data — fiber","text":"","code":"fiber.lm <- lm(strength ~ diameter + machine, data=fiber) ref_grid(fiber.lm) #>  diameter machine prediction    SE df #>      24.1 A             40.4 0.724 11 #>      24.1 B             41.4 0.744 11 #>      24.1 C             38.8 0.788 11 #>   # Covariate-adjusted means and comparisons emmeans(fiber.lm, pairwise ~ machine) #> $emmeans #>  machine emmean    SE df lower.CL upper.CL #>  A         40.4 0.724 11     38.8     42.0 #>  B         41.4 0.744 11     39.8     43.1 #>  C         38.8 0.788 11     37.1     40.5 #>  #> Confidence level used: 0.95  #>  #> $contrasts #>  contrast estimate   SE df t.ratio p.value #>  A - B       -1.04 1.01 11  -1.024  0.5781 #>  A - C        1.58 1.11 11   1.431  0.3596 #>  B - C        2.62 1.15 11   2.283  0.1005 #>  #> P value adjustment: tukey method for comparing a family of 3 estimates  #>"},{"path":"https://rvlenth.github.io/emmeans/reference/glht-support.html","id":null,"dir":"Reference","previous_headings":"","what":"Support for multcomp::glht — emm","title":"Support for multcomp::glht — emm","text":"functions methods provide interface emmeans multcomp::glht function simultaneous inference provided multcomp package.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/glht-support.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Support for multcomp::glht — emm","text":"","code":"emm(...)  as.glht(object, ...)  # S3 method for emmGrid as.glht(object, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/glht-support.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Support for multcomp::glht — emm","text":"... emm, specs, , contr arguments normally supply emmeans. specs required. Otherwise, arguments passed methods. may also include argument; see Details. object object class emmGrid emm_list","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/glht-support.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Support for multcomp::glht — emm","text":"emm returns object intermediate class   multcomp::glht method. .glht returns object class glht glht_list according whether object class emmGrid emm_list.    See Details glht_lists.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/glht-support.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Support for multcomp::glht — emm","text":"multivariate-\\(t\\) routines used glht require   estimates family integer degrees freedom. cases   true, message displayed shows df used.   user may override via df argument.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/glht-support.html","id":"details-for-emm","dir":"Reference","previous_headings":"","what":"Details for emm","title":"Support for multcomp::glht — emm","text":"emm meant called \"glht\" second (linfct) argument. works similarly multcomp::mcp, except specs (optionally contr arguments) provided call emmeans. specifications ... result list (.e., emm_list object), default, last element list passed glht. However, ... contains argument consisting integer values, list elements indexes selected combined passed glht. checking done whether indexes valid, keyword must spelled-.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/glht-support.html","id":"details-for-as-glht","dir":"Reference","previous_headings":"","what":"Details for as.glht","title":"Support for multcomp::glht — emm","text":"variable force, obtain glht object; otherwise glht_list. latter defined emmeans, multcomp, simply list glht objects.  Appropriate convenience methods coef, confint, plot, summary, vcov provided, simply apply corresponding glht methods member.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/glht-support.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Support for multcomp::glht — emm","text":"","code":"if(require(multcomp, quietly = TRUE))      emm_example(\"glht-multcomp\")  #>  #> Attaching package: 'TH.data' #> The following object is masked from 'package:MASS': #>  #>     geyser #>  #> --- Running code from 'system.file(\"extexamples\", \"glht-multcomp.R\", package = \"emmeans\")' #>  #> > warp.lm <- lm(breaks ~ wool * tension, data = warpbreaks) #>  #> > summary(glht(warp.lm, emm(pairwise ~ tension | wool))) #> $`wool = A` #>  #> \t Simultaneous Tests for General Linear Hypotheses #>  #> Fit: lm(formula = breaks ~ wool * tension, data = warpbreaks) #>  #> Linear Hypotheses: #>            Estimate Std. Error t value Pr(>|t|)     #> L - M == 0  20.5556     5.1573   3.986   <0.001 *** #> L - H == 0  20.0000     5.1573   3.878   <0.001 *** #> M - H == 0  -0.5556     5.1573  -0.108    0.994     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> (Adjusted p values reported -- single-step method) #>  #>  #> $`wool = B` #>  #> \t Simultaneous Tests for General Linear Hypotheses #>  #> Fit: lm(formula = breaks ~ wool * tension, data = warpbreaks) #>  #> Linear Hypotheses: #>            Estimate Std. Error t value Pr(>|t|) #> L - M == 0  -0.5556     5.1573  -0.108    0.994 #> L - H == 0   9.4444     5.1573   1.831    0.170 #> M - H == 0  10.0000     5.1573   1.939    0.139 #> (Adjusted p values reported -- single-step method) #>  #>  #>  #> > summary(glht(warp.lm, emm(pairwise ~ tension | wool,  #> +     which = 1:2, by = \"wool\"))) #> $`wool = A` #>  #> \t Simultaneous Tests for General Linear Hypotheses #>  #> Fit: lm(formula = breaks ~ wool * tension, data = warpbreaks) #>  #> Linear Hypotheses: #>               Estimate Std. Error t value Pr(>|t|)     #> L, . == 0      44.5556     3.6468  12.218  < 0.001 *** #> M, . == 0      24.0000     3.6468   6.581  < 0.001 *** #> H, . == 0      24.5556     3.6468   6.734  < 0.001 *** #> ., L - M == 0  20.5556     5.1573   3.986  0.00103 **  #> ., L - H == 0  20.0000     5.1573   3.878  0.00174 **  #> ., M - H == 0  -0.5556     5.1573  -0.108  0.99949     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> (Adjusted p values reported -- single-step method) #>  #>  #> $`wool = B` #>  #> \t Simultaneous Tests for General Linear Hypotheses #>  #> Fit: lm(formula = breaks ~ wool * tension, data = warpbreaks) #>  #> Linear Hypotheses: #>               Estimate Std. Error t value Pr(>|t|)     #> L, . == 0      28.2222     3.6468   7.739   <0.001 *** #> M, . == 0      28.7778     3.6468   7.891   <0.001 *** #> H, . == 0      18.7778     3.6468   5.149   <0.001 *** #> ., L - M == 0  -0.5556     5.1573  -0.108    0.999     #> ., L - H == 0   9.4444     5.1573   1.831    0.253     #> ., M - H == 0  10.0000     5.1573   1.939    0.210     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> (Adjusted p values reported -- single-step method) #>  #>  #>  #> > warp.emm <- emmeans(warp.lm, ~tension | wool) #>  #> > summary(as.glht(pairs(warp.emm))) #> $`wool = A` #>  #> \t Simultaneous Tests for General Linear Hypotheses #>  #> Linear Hypotheses: #>            Estimate Std. Error t value Pr(>|t|)     #> L - M == 0  20.5556     5.1573   3.986   <0.001 *** #> L - H == 0  20.0000     5.1573   3.878   <0.001 *** #> M - H == 0  -0.5556     5.1573  -0.108    0.994     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> (Adjusted p values reported -- single-step method) #>  #>  #> $`wool = B` #>  #> \t Simultaneous Tests for General Linear Hypotheses #>  #> Linear Hypotheses: #>            Estimate Std. Error t value Pr(>|t|) #> L - M == 0  -0.5556     5.1573  -0.108    0.994 #> L - H == 0   9.4444     5.1573   1.831    0.170 #> M - H == 0  10.0000     5.1573   1.939    0.139 #> (Adjusted p values reported -- single-step method) #>  #>  #>  #> > summary(as.glht(pairs(warp.emm), by = NULL)) #>  #> \t Simultaneous Tests for General Linear Hypotheses #>  #> Linear Hypotheses: #>               Estimate Std. Error t value Pr(>|t|)    #> L - M, A == 0  20.5556     5.1573   3.986  0.00129 ** #> L - H, A == 0  20.0000     5.1573   3.878  0.00183 ** #> M - H, A == 0  -0.5556     5.1573  -0.108  0.99996    #> L - M, B == 0  -0.5556     5.1573  -0.108  0.99996    #> L - H, B == 0   9.4444     5.1573   1.831  0.30796    #> M - H, B == 0  10.0000     5.1573   1.939  0.25532    #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> (Adjusted p values reported -- single-step method) #>  #>      # Use emm_example(\"glht-multcomp\", list = TRUE) # to see just the code"},{"path":"https://rvlenth.github.io/emmeans/reference/hpd.summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize an emmGrid from a Bayesian model — hpd.summary","title":"Summarize an emmGrid from a Bayesian model — hpd.summary","text":"function computes point estimates HPD intervals factor combination object@emmGrid. function may called independently, called automatically S3 method summary.emmGrid object based Bayesian model. (Note: level argument, default, passed prob).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/hpd.summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize an emmGrid from a Bayesian model — hpd.summary","text":"","code":"hpd.summary(object, prob, by, type, point.est = median, delta,   bias.adjust = get_emm_option(\"back.bias.adj\"), sigma, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/hpd.summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize an emmGrid from a Bayesian model — hpd.summary","text":"object emmGrid object non-missing post.beta slot prob numeric probability content HPD intervals (note: specified, current level option used; see emm_options) factors use variables type prediction type summary.emmGrid point.est function use compute point estimates  posterior sample grid point delta Numeric equivalence threshold (linear predictor scale  regardless type). See section equivalence testing. bias.adjust Logical value whether adjust bias back-transforming (type = \"response\"). requires value  sigma exist object specified. sigma Error SD assumed bias correction ( type = \"response\". specified, object@misc$sigma used, warning found invalid. Note: sigma may vector, long conforms  number observations posterior sample. ... required used","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/hpd.summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize an emmGrid from a Bayesian model — hpd.summary","text":"object class summary_emm","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/hpd.summary.html","id":"equivalence-testing-note","dir":"Reference","previous_headings":"","what":"Equivalence testing note","title":"Summarize an emmGrid from a Bayesian model — hpd.summary","text":"delta positive, two columns labeled p.equiv   odds.eq appended summary. p.equiv fraction   posterior estimates absolute values less delta.   odds.eq column just p.equiv converted odds ratio;   posterior odds equivalence. high value p.equiv evidence   favor equivalence. can used obtain something equivalent   (spirit) frequentist Schuirmann (TOST) procedure, whereby   conclude equivalence significance level \\(\\alpha\\) \\((1 - 2\\alpha)\\)   confidence interval falls entirely interval \\([-\\delta, \\delta]\\).   Similarly Bayesian context, equally strong argument   equivalence obtained p.equiv exceeds \\(1 - 2\\alpha\\). closely related quantity ROPE (region practical equivalence),   obtainable via bayestestR::rope(object, range = c(-delta, delta)).   value approximately 100 * p.equiv / 0.95 default   ci = 0.95 used. See also bayestestR's    issue #567. Finally, Bayes factor equivalence obtainable dividing    odds.eq prior odds equivalence, assessed elicited separately.","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/hpd.summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize an emmGrid from a Bayesian model — hpd.summary","text":"","code":"if(require(\"coda\"))      emm_example(\"hpd.summary-coda\") #> Loading required package: coda #>  #> --- Running code from 'system.file(\"extexamples\", \"hpd.summary-coda.R\", package = \"emmeans\")' #>  #> > cbpp.rg <- do.call(emmobj, readRDS(system.file(\"extdata\",  #> +     \"cbpplist\", package = \"emmeans\"))) #>  #> > cbpp.emm <- emmeans(cbpp.rg, \"period\") #>  #> > hpd.summary(cbpp.emm) #>  period emmean lower.HPD upper.HPD #>  1       -1.43     -1.96    -0.894 #>  2       -2.39     -3.13    -1.823 #>  3       -2.52     -3.19    -1.862 #>  4       -2.97     -3.88    -1.998 #>  #> Point estimate displayed: median  #> Results are given on the logit (not the response) scale.  #> HPD interval probability: 0.95  #>  #> > summary(pairs(cbpp.emm), type = \"response\", delta = log(2)) #>  contrast          odds.ratio lower.HPD upper.HPD p.equiv odds.eq #>  period1 / period2       2.60     1.264      4.34   0.210  0.2658 #>  period1 / period3       2.90     1.266      5.42   0.114  0.1287 #>  period1 / period4       4.64     1.595      9.76   0.026  0.0267 #>  period2 / period3       1.14     0.486      2.36   0.918 11.1951 #>  period2 / period4       1.78     0.580      4.35   0.604  1.5253 #>  period3 / period4       1.55     0.437      4.01   0.700  2.3333 #>  #> Point estimate displayed: median  #> 'p.equiv' and 'odds.eq' based on posterior P(|lin. pred.| < 0.6931)  #> Results are back-transformed from the log odds ratio scale  #> HPD interval probability: 0.95  #>      # Use emm_example(\"hpd.summary-coda\", list = TRUE) # to see just the code"},{"path":"https://rvlenth.github.io/emmeans/reference/joint_tests.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute joint tests of the terms in a model — joint_tests","title":"Compute joint tests of the terms in a model — joint_tests","text":"function produces analysis--variance-like table based linear functions predictors model emmGrid object. Specifically, function constructs, combination factors (covariates reduced two levels), set (interaction) contrasts via contrast, tests using test joint = TRUE. Optionally, one predictors may used variable(s), separate tables tests produced combination .","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/joint_tests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute joint tests of the terms in a model — joint_tests","text":"","code":"joint_tests(object, by = NULL, show0df = FALSE, showconf = TRUE,   cov.reduce = make.meanint(1), ...)  make.meanint(delta)  meanint(x)  make.symmint(ctr, delta)  symmint(ctr)"},{"path":"https://rvlenth.github.io/emmeans/reference/joint_tests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute joint tests of the terms in a model — joint_tests","text":"object fitted model, emmGrid, emm_list. latter, first element used. character names variables. Separate sets tests run combination . show0df logical value; TRUE, results zero numerator degrees freedom displayed, FALSE skipped showconf logical value. models estimability issues (e.g., missing cells), showconf = TRUE, test remaining effects purely due contrasts single term. found, labeled (confounded). See vignette(\"xplanations\") information. cov.reduce function. object fitted model, replaced ref_grid(object, cov.reduce = cov.reduce, ...). purpose, functions meanint symmint available returning interval around mean around zero, respectively. Se section covariates. ... additional arguments passed ref_grid emmeans delta, ctr arguments make.meanint make.symmint x argument meanint symmint","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/joint_tests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute joint tests of the terms in a model — joint_tests","text":"summary_emm object (produced  summary.emmGrid). effects   estimable contrasts omitted results.    may additional row named (confounded) accounts   additional degrees freedom effects accounted    preceding rows. returned object also includes \"est.fcns\" attribute,   named list containing linear functions associated joint test.    estimable functions included confounded effects. make.meanint returns function  function(x) mean(x) + delta * c(-1, 1),   make.symmint(ctr, delta) returns function function(x) ctr + delta * c(-1, 1) (depend x).         cases delta = 1, meanint = make.meanint(1) symmint(ctr) = make.symmint(ctr, 1) retained back-compatibility reasons.         functions available primarily use cov.reduce.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/joint_tests.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute joint tests of the terms in a model — joint_tests","text":"models factors, covariates, tests correspond “type III” tests la SAS, long equal-weighted averaging used estimability issues. covariates present interact factors, results depend covariate handled constructing reference grid. See section covariates . point one must always remember joint_tests always tests contrasts among EMMs, context reference grid, whereas type III tests tests model coefficients -- may may anything EMMs contrasts.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/joint_tests.html","id":"dealing-with-covariates","dir":"Reference","previous_headings":"","what":"Dealing with covariates","title":"Compute joint tests of the terms in a model — joint_tests","text":"covariate (predictor) must one value  reference grid order test effect included results. Therefore, object model, default cov.reduce = meanint sets covariate symmetric interval mean. object existing reference grid, often one value  covariates, case excluded joint tests. Covariates present complications values reference grid can affect joint tests effects. covariates centered around means (default), tests obtain can described joint tests covariate-adjusted means; intended use . However, software SAS car::Anova adopt convention centering covariates around zero; purpose, one can use cov.reduce = symmint(0) calling model object (constructing reference grid). However, adjusted means covariates set around zero make much sense context interpreting estimated marginal means, unless covariate means really zero. See examples toy dataset.","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/joint_tests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute joint tests of the terms in a model — joint_tests","text":"","code":"pigs.lm <- lm(log(conc) ~ source * factor(percent), data = pigs)  (jt <- joint_tests(pigs.lm))             ## will be same as type III ANOVA #>  model term     df1 df2 F.ratio p.value #>  source           2  17  30.256  <.0001 #>  percent          3  17   8.214  0.0013 #>  source:percent   6  17   0.926  0.5011 #>   ### Estimable functions associated with \"percent\" attr(jt, \"est.fcns\") $ \"percent\" #>      (Intercept) sourcesoy sourceskim factor(percent)12 factor(percent)15 #> [1,]           0         0          0         -0.904534          0.000000 #> [2,]           0         0          0          0.000000         -0.904534 #> [3,]           0         0          0          0.000000          0.000000 #>      factor(percent)18 sourcesoy:factor(percent)12 sourceskim:factor(percent)12 #> [1,]          0.000000                  -0.3015113                   -0.3015113 #> [2,]          0.000000                   0.0000000                    0.0000000 #> [3,]         -0.904534                   0.0000000                    0.0000000 #>      sourcesoy:factor(percent)15 sourceskim:factor(percent)15 #> [1,]                   0.0000000                    0.0000000 #> [2,]                  -0.3015113                   -0.3015113 #> [3,]                   0.0000000                    0.0000000 #>      sourcesoy:factor(percent)18 sourceskim:factor(percent)18 #> [1,]                   0.0000000                    0.0000000 #> [2,]                   0.0000000                    0.0000000 #> [3,]                  -0.3015113                   -0.3015113  joint_tests(pigs.lm, weights = \"outer\")  ## differently weighted #>  model term     df1 df2 F.ratio p.value #>  source           2  17  28.601  <.0001 #>  percent          3  17   7.889  0.0016 #>  source:percent   6  17   0.926  0.5011 #>   joint_tests(pigs.lm, by = \"source\")      ## separate joint tests of 'percent' #> source = fish: #>  model term df1 df2 F.ratio p.value #>  percent      3  17   1.712  0.2023 #>  #> source = soy: #>  model term df1 df2 F.ratio p.value #>  percent      3  17   1.290  0.3097 #>  #> source = skim: #>  model term df1 df2 F.ratio p.value #>  percent      3  17   6.676  0.0035 #>   ### Comparisons with type III tests in SAS toy = data.frame(     treat = rep(c(\"A\", \"B\"), c(4, 6)),     female = c(1, 0, 0, 1,   0, 0, 0, 1, 1, 0 ),     resp = c(17, 12, 14, 19, 28, 26, 26, 34, 33, 27)) toy.fac = lm(resp ~ treat * factor(female), data = toy) toy.cov = lm(resp ~ treat * female, data = toy) # (These two models have identical fitted values and residuals)  # -- SAS output we'd get with toy.fac -- ## Source          DF    Type III SS    Mean Square   F Value   Pr > F ## treat            1    488.8928571    488.8928571    404.60   <.0001 ## female           1     78.8928571     78.8928571     65.29   0.0002 ## treat*female     1      1.7500000      1.7500000      1.45   0.2741 #  # -- SAS output we'd get with toy.cov -- ## Source          DF    Type III SS    Mean Square   F Value   Pr > F ## treat            1    252.0833333    252.0833333    208.62   <.0001 ## female           1     78.8928571     78.8928571     65.29   0.0002 ## female*treat     1      1.7500000      1.7500000      1.45   0.2741  joint_tests(toy.fac) #>  model term   df1 df2 F.ratio p.value #>  treat          1   6 404.601  <.0001 #>  female         1   6  65.291  0.0002 #>  treat:female   1   6   1.448  0.2741 #>  joint_tests(toy.cov)   # female is regarded as a 2-level factor by default #>  model term   df1 df2 F.ratio p.value #>  treat          1   6 404.601  <.0001 #>  female         1   6  65.291  0.0002 #>  treat:female   1   6   1.448  0.2741 #>   ## Treat 'female' as a numeric covariate (via cov.keep = 0) ## ... then tests depend on where we center things  # Center around the mean joint_tests(toy.cov, cov.keep = 0, cov.reduce = make.meanint(delta = 1)) #>  model term   df1 df2 F.ratio p.value #>  treat          1   6 401.865  <.0001 #>  female         1   6  65.291  0.0002 #>  treat:female   1   6   1.448  0.2741 #>  # Center around zero (like SAS's results for toy.cov) joint_tests(toy.cov, cov.keep = 0, cov.reduce = make.symmint(ctr = 0, delta = 1)) #>  model term   df1 df2 F.ratio p.value #>  treat          1   6 208.621  <.0001 #>  female         1   6  65.291  0.0002 #>  treat:female   1   6   1.448  0.2741 #>  # Center around 0.5 (like SAS's results for toy.fac) joint_tests(toy.cov, cov.keep = 0, cov.reduce = range) #>  model term   df1 df2 F.ratio p.value #>  treat          1   6 404.601  <.0001 #>  female         1   6  65.291  0.0002 #>  treat:female   1   6   1.448  0.2741 #>   ### Example with empty cells and confounded effects low3 <- unlist(attr(ubds, \"cells\")[1:3])  ubds.lm <- lm(y ~ A*B*C, data = ubds, subset = -low3)  # Show overall joint tests by C: ref_grid(ubds.lm, by = \"C\") |> contrast(\"consec\") |> test(joint = TRUE) #>  C df1 df2 F.ratio p.value note #>  1   6  71   8.993  <.0001    e #>  2   7  71   9.763  <.0001    e #>  3   8  71   8.774  <.0001      #>  #> e: df1 reduced due to non-estimability   # Break each of the above into smaller components: joint_tests(ubds.lm, by = \"C\") #> C = 1: #>  model term   df1 df2 F.ratio p.value note #>  A:B            2  71   5.709  0.0050    e #>  (confounded)   4  71  10.635  <.0001      #>  #> C = 2: #>  model term   df1 df2 F.ratio p.value note #>  A              1  71  14.601  0.0003    e #>  B              1  71  24.059  <.0001    e #>  A:B            3  71   2.778  0.0474    e #>  (confounded)   2  71   8.656  0.0004      #>  #> C = 3: #>  model term   df1 df2 F.ratio p.value note #>  A              2  71   7.398  0.0012      #>  B              2  71  22.157  <.0001      #>  A:B            4  71   3.009  0.0237      #>  #> e: df1 reduced due to non-estimability"},{"path":"https://rvlenth.github.io/emmeans/reference/make.tran.html","id":null,"dir":"Reference","previous_headings":"","what":"Response-transformation extensions — make.tran","title":"Response-transformation extensions — make.tran","text":"make.tran function creates needed information perform transformations response variable, including inverting transformation estimating variances back-transformed predictions via delta method. make.tran similar make.link, covers additional transformations. result can used environment model fitted, tran argument update.emmGrid (given transformation already applied existing model).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/make.tran.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Response-transformation extensions — make.tran","text":"","code":"make.tran(type = c(\"genlog\", \"power\", \"boxcox\", \"sympower\", \"asin.sqrt\",   \"atanh\", \"bcnPower\", \"scale\"), alpha = 1, beta = 0, param, y, inner, ...)  inverse(y)"},{"path":"https://rvlenth.github.io/emmeans/reference/make.tran.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Response-transformation extensions — make.tran","text":"type name standard transformation supported stat::make.link, special transformation described Details. alpha, beta Numeric parameters needed special transformations. param non-missing, specifies either alpha c(alpha, beta) (provided backward compatibility). Also, reason, alpha length 1, taken param. y numeric response variable used (required) type = \"scale\",  scale(y) determines alpha beta. inner another transformation. See section compound transformations ... Additional arguments passed functions/methods","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/make.tran.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Response-transformation extensions — make.tran","text":"list least elements returned  make.link. linkfun component transformation   . functions associated environment    parameter values defined. inverse returns reciprocal argument. allows   \"inverse\" link auto-detected response transformation.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/make.tran.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Response-transformation extensions — make.tran","text":"genlog transformation technically unneeded,   response transformation form log(y + c) now auto-detected    ref_grid. modify certain make.link results transformations   restriction valid prediction values, reasonable   inverse predictions obtained, matter . example,   sqrt transformation used predicted value negative,   inverse transformation zero rather square prediction.   side effect possible one confidence   limits, even standard error, zero.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/make.tran.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Response-transformation extensions — make.tran","text":"make.tran function returns suitable list functions several popular transformations. Besides usable update, user may use list enclosing environment fitting model , case transformation auto-detected special name linkfun (transformation ) used response transformation call. See examples . primary purpose make.tran support transformations require additional parameters, specified alpha beta; onse shown argument-matching list. However, standard transformations supported stats::make.link also supported. following discussion ones requiring parameters,  use \\(\\alpha\\) \\(\\beta\\) denote alpha beta, \\(y\\) denote response variable. type argument specifies following transformations: \"genlog\" Generalized logarithmic transformation: \\(\\log_\\beta(y +   \\alpha)\\), \\(y > -\\alpha\\).   \\(\\beta = 0\\) (default), use \\(\\log_e(y + \\alpha)\\) \"power\" Power transformation: \\((y-\\beta)^\\alpha\\), \\(y > \\beta\\).   \\(\\alpha = 0\\), \\(\\log(y-\\beta)\\) used instead. \"boxcox\" Box-Cox transformation (unscaled geometric   mean): \\(((y - \\beta)^\\alpha - 1) / \\alpha\\), \\(y > \\beta\\).    \\(\\alpha = 0\\), \\(\\log(y - \\beta)\\)   used. \"sympower\" symmetrized power transformation whole real   line:   \\(|y - \\beta|^\\alpha\\cdot sign(y - \\beta)\\). restrictions \\(y\\),   require \\(\\alpha > 0\\) order transformation monotone   continuous. \"asin.sqrt\" Arcsin-square-root transformation:   \\(\\sin^{-1}(y/\\alpha)^{1/2}\\). Typically, alpha either 1 (default) 100. \"atanh\" Arctanh transformation:   \\(\\tanh^{-1}(y/\\alpha)\\). Typically, alpha either 1 (default) 100. \"bcnPower\" Box-Cox negatives allowed, described    bcnPower function car package. defined Box-Cox   transformation \\((z^\\alpha - 1) / \\alpha\\) variable \\(z = y + (y^2+\\beta^2)^{1/2}\\).    Note requires parameters beta > 0. \"scale\" one little different others,   alpha beta ignored; instead, determined calling    scale(y, ...). user give y response variable   model fitted scaled version. Note \"power\", \"boxcox\", \"sympower\" transformations,  argument beta specifies location shift.  \"genpower\" transformation, beta specifies base logarithm -- however, quirkily, default beta = 0 taken natural logarithm. example, make.tran(0.5, 10) sets \\(\\log_{10}(y + \\frac12)\\) transformation. \"bcnPower\" transformation, beta must specified positive value. purposes back-transformation, sqrt(y) + sqrt(y+1) transformation treated exactly way 2*sqrt(y), regarded estimates \\(2\\sqrt\\mu\\).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/make.tran.html","id":"cases-where-make-tran-may-not-be-needed","dir":"Reference","previous_headings":"","what":"Cases where make.tran may not be needed","title":"Response-transformation extensions — make.tran","text":"standard transformations parameters, usually need use make.tran; just name transformation needed. functions emmeans, ref_grid, related ones automatically detect response transformations recognized examining model formula. log, log2, log10, log1p, sqrt, logit, probit, cauchit, cloglog; well (response variable y) asin(sqrt(y)), asinh(sqrt(y)), atanh(y), sqrt(y) + sqrt(y+1).  addition, constant multiple (e.g., 2*sqrt(y)) auto-detected appropriately scaled (see also tran.mult argument update.emmGrid). additional transformations may specified character strings auto-detected: \"identity\", \"1/mu^2\", \"inverse\", \"reciprocal\", \"log10\", \"log2\", \"asin.sqrt\", \"asinh.sqrt\", \"atanh\".","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/make.tran.html","id":"compound-transformations","dir":"Reference","previous_headings":"","what":"Compound transformations","title":"Response-transformation extensions — make.tran","text":"transformation function another function can created specifying inner function. example, transformation \\(1/\\sqrt{y}\\) can created either make.tran(\"inverse\", inner = \"sqrt\") make.tran(\"power\", -0.5). principle, transformations can compounded depth. Also, type \"scale\", y replaced  inner$linkfun(y), variable scaled.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/make.tran.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Response-transformation extensions — make.tran","text":"","code":"# Fit a model using an oddball transformation: bctran <- make.tran(\"boxcox\", 0.368) warp.bc <- with(bctran,      lm(linkfun(breaks) ~ wool * tension, data = warpbreaks)) # Obtain back-transformed LS means:     emmeans(warp.bc, ~ tension | wool, type = \"response\") #> wool = A: #>  tension response   SE df lower.CL upper.CL #>  L           42.4 4.48 48     34.0     52.0 #>  M           23.1 3.05 48     17.5     29.8 #>  H           23.3 3.07 48     17.7     30.0 #>  #> wool = B: #>  tension response   SE df lower.CL upper.CL #>  L           27.2 3.38 48     20.9     34.6 #>  M           27.9 3.44 48     21.5     35.3 #>  H           18.4 2.65 48     13.6     24.3 #>  #> Confidence level used: 0.95  #> Intervals are back-transformed from the Box-Cox (lambda = 0.368) scale   ### Using a scaled response... # Case where it is auto-detected: mod <- lm(scale(yield[, 1]) ~ Variety, data = MOats) emmeans(mod, \"Variety\", type = \"response\") #>  Variety     response   SE df lower.CL upper.CL #>  Golden Rain     80.0 7.96 15     63.0     97.0 #>  Marvellous      86.7 7.96 15     69.7    103.6 #>  Victory         71.5 7.96 15     54.5     88.5 #>  #> Confidence level used: 0.95  #> Intervals are back-transformed from the scale(79.4, 19.4) scale   # Case where scaling is not auto-detected -- and what to do about it: copt <- options(contrasts = c(\"contr.sum\", \"contr.poly\")) mod.aov <- aov(scale(yield[, 1]) ~ Variety + Error(Block), data = MOats) emm.aov <- suppressWarnings(emmeans(mod.aov, \"Variety\", type = \"response\")) #> NOTE: Unable to recover scale() parameters. See '? make.tran'  # Scaling was not retrieved, but we can do: emm.aov <- update(emm.aov, tran = make.tran(\"scale\", y = MOats$yield[, 1])) emmeans(emm.aov, \"Variety\", type = \"response\") #>  Variety     response   SE  df lower.CL upper.CL #>  Golden Rain     80.0 7.96 9.8     62.2     97.8 #>  Marvellous      86.7 7.96 9.8     68.9    104.5 #>  Victory         71.5 7.96 9.8     53.7     89.3 #>  #> Warning: EMMs are biased unless design is perfectly balanced  #> Confidence level used: 0.95  #> Intervals are back-transformed from the scale(79.4, 19.4) scale   ### Compound transformations # The following amount to the same thing: t1 <- make.tran(\"inverse\", inner = \"sqrt\") t2 <- make.tran(\"power\", -0.5)  options(copt)   if (FALSE) { ### An existing model 'mod' was fitted with a y^(2/3) transformation...   ptran = make.tran(\"power\", 2/3)   emmeans(mod, \"treatment\", tran = ptran) }  pigs.lm <- lm(inverse(conc) ~ source + factor(percent), data = pigs) emmeans(pigs.lm, \"source\", type = \"response\") #>  source response    SE df lower.CL upper.CL #>  fish       29.7 0.816 23     28.1     31.5 #>  soy        39.0 1.436 23     36.2     42.2 #>  skim       43.8 1.903 23     40.1     48.1 #>  #> Results are averaged over the levels of: percent  #> Confidence level used: 0.95  #> Intervals are back-transformed from the inverse scale"},{"path":"https://rvlenth.github.io/emmeans/reference/manip-factors.html","id":null,"dir":"Reference","previous_headings":"","what":"Manipulate factors in a reference grid — comb_facs","title":"Manipulate factors in a reference grid — comb_facs","text":"functions manipulate levels factors comprising reference grid combining factor levels, splitting factor's levels  combinations newly-defined factors, creating grouping factor  factor(s) levels nested, permuting order levels factor","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/manip-factors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manipulate factors in a reference grid — comb_facs","text":"","code":"comb_facs(object, facs, newname = paste(facs, collapse = \".\"),   drop = FALSE, ...)  split_fac(object, fac, newfacs, ...)  add_grouping(object, newname, refname, newlevs, ...)  permute_levels(object, fac, pos)"},{"path":"https://rvlenth.github.io/emmeans/reference/manip-factors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manipulate factors in a reference grid — comb_facs","text":"object object class emmGrid facs Character vector. names factors combine newname Character name grouping factor add (different existing factor grid) drop Logical value. TRUE, levels new factor  dropped occurrences newly reconstructed object  weight zero. FALSE, levels retained.  (argument ignored .wgt. column object@grid.) ... arguments passed methods fac name factor part grid object newfacs named list names new factors levels. names must already exist object, product lengths levels must equal number levels fac. refname Character name(s) reference factor(s) newlevs Character vector factor length (combined) levels  refname. grouping factor newname unique values newlevs levels. order levels newlevs order level combinations produced  expand.grid applied levels refname -- , first factor's levels change fastest last one's vary slowest. pos Integer vector consisting permutation sequence 1:k, k number levels fac. determines position level fac occupy levels permuted; thus, levels fac ,B,C,D, pos = c(3,1,2,4),  permuted levels B,C,,D.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/manip-factors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Manipulate factors in a reference grid — comb_facs","text":"modified object class emmGrid","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/manip-factors.html","id":"the-comb-facs-function","dir":"Reference","previous_headings":"","what":"The comb_facs function","title":"Manipulate factors in a reference grid — comb_facs","text":"comb_facs combines levels factors single factor reference grid (similar interaction). new factor replaces factors comprise . Additional note: choice whether drop levels can make profound difference. goal combine factors use joint_tests, advise  drop = TRUE might change weights used deriving marginal means. combining factors nested structure, dropping unused cases can considerably reduce  storage required.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/manip-factors.html","id":"the-split-fac-function","dir":"Reference","previous_headings":"","what":"The split_fac function","title":"Manipulate factors in a reference grid — comb_facs","text":"levels newfacs expanded via expand.grid combinations levels, factor fac replaced  factor combinations. Unlike add_grouping, creates crossed,  rather nested structure. Note order factor combinations systematic levels first factor newfacs varying  fastest; factor combinations assigned respectively levels fac displayed str(object).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/manip-factors.html","id":"the-add-grouping-function","dir":"Reference","previous_headings":"","what":"The add_grouping function","title":"Manipulate factors in a reference grid — comb_facs","text":"function adds grouping factor existing reference grid  emmGrid object, levels one existing factors (call reference factors) mapped smaller number levels new grouping factor. reference factors nested  new grouping factor named newname, new nesting structure refname %% newname. facilitates obtaining marginal means grouping factor,  contrasts thereof. Additional notes: default, levels newname ordered   alphabetically. dictate different ordering levels, supply    newlevs factor levels desired order. refname specifies one factor, can   fundamentally (permanently) change meant levels   individual factors. instance, gwrg example ,   two levels wool nested prod; implies   now regard four different kinds wool. Similarly,   five different tensions (L, M, H prod 1, L, M prod 2).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/manip-factors.html","id":"the-permute-levels-function","dir":"Reference","previous_headings":"","what":"The permute_levels function","title":"Manipulate factors in a reference grid — comb_facs","text":"function permutes levels fac. returned object factors, variables, levels fac permuted.  order columns object@grid may altered. NOTE: fac must nested another factor. permute_levels  throws error fac nested. NOTE: Permuting levels numeric predictor tricky. example, want display new ordering levels emmip(), must add arguments style = \"factor\" nesting.order = TRUE.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/manip-factors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manipulate factors in a reference grid — comb_facs","text":"","code":"mtcars.lm <- lm(mpg ~ factor(vs)+factor(cyl)*factor(gear), data = mtcars) (v.c.g <- ref_grid(mtcars.lm)) #>  vs cyl gear prediction    SE df #>   0   4    3       21.7 4.416 23 #>   1   4    3       21.5 3.420 23 #>   0   6    3       19.9 3.694 23 #>   1   6    3       19.8 2.418 23 #>   0   8    3       15.1 0.987 23 #>   1   8    3       14.8 2.962 23 #>   0   4    4       27.1 3.043 23 #>   1   4    4       26.9 1.209 23 #>   0   6    4       19.9 2.208 23 #>   1   6    4       19.6 2.208 23 #>   0   8    4     nonEst    NA NA #>   1   8    4     nonEst    NA NA #>   0   4    5       28.3 2.793 23 #>   1   4    5       28.1 2.793 23 #>   0   6    5       19.7 3.420 23 #>   1   6    5       19.5 4.416 23 #>   0   8    5       15.4 2.418 23 #>   1   8    5       15.2 3.694 23 #>  (v.cg <- comb_facs(v.c.g, c(\"cyl\", \"gear\"))) #>  vs cyl.gear prediction    SE df #>   0 4:3            21.7 4.416 23 #>   1 4:3            21.5 3.420 23 #>   0 6:3            19.9 3.694 23 #>   1 6:3            19.8 2.418 23 #>   0 8:3            15.1 0.987 23 #>   1 8:3            14.8 2.962 23 #>   0 4:4            27.1 3.043 23 #>   1 4:4            26.9 1.209 23 #>   0 6:4            19.9 2.208 23 #>   1 6:4            19.6 2.208 23 #>   0 8:4          nonEst    NA NA #>   1 8:4          nonEst    NA NA #>   0 4:5            28.3 2.793 23 #>   1 4:5            28.1 2.793 23 #>   0 6:5            19.7 3.420 23 #>   1 6:5            19.5 4.416 23 #>   0 8:5            15.4 2.418 23 #>   1 8:5            15.2 3.694 23 #>     # One use is obtaining a single test for the joint contributions of two factors: joint_tests(v.c.g) #>  model term   df1 df2 F.ratio p.value note #>  vs             1  23   0.005  0.9435      #>  cyl            1  23   6.570  0.0174    e #>  gear           1  23   0.755  0.3939    e #>  cyl:gear       3  23   0.681  0.5725    e #>  (confounded)   2  23  26.980  <.0001      #>  #> e: df1 reduced due to non-estimability   joint_tests(v.cg) #>  model term df1 df2 F.ratio p.value note #>  vs           1  23   0.005  0.9435      #>  cyl.gear     7  23   4.402  0.0031    e #>  #> e: df1 reduced due to non-estimability   # undo the 'comb_facs' operation: split_fac(v.cg, \"cyl.gear\", list(cyl = c(4, 6, 8), gear = 3:5)) #>  vs cyl gear cyl.gear prediction    SE df #>   0   4    3 4:3            21.7 4.416 23 #>   1   4    3 4:3            21.5 3.420 23 #>   0   6    3 6:3            19.9 3.694 23 #>   1   6    3 6:3            19.8 2.418 23 #>   0   8    3 8:3            15.1 0.987 23 #>   1   8    3 8:3            14.8 2.962 23 #>   0   4    4 4:4            27.1 3.043 23 #>   1   4    4 4:4            26.9 1.209 23 #>   0   6    4 6:4            19.9 2.208 23 #>   1   6    4 6:4            19.6 2.208 23 #>   0   8    4 8:4          nonEst    NA NA #>   1   8    4 8:4          nonEst    NA NA #>   0   4    5 4:5            28.3 2.793 23 #>   1   4    5 4:5            28.1 2.793 23 #>   0   6    5 6:5            19.7 3.420 23 #>   1   6    5 6:5            19.5 4.416 23 #>   0   8    5 8:5            15.4 2.418 23 #>   1   8    5 8:5            15.2 3.694 23 #>   IS.glm <- glm(count ~ spray, data = InsectSprays, family = poisson) IS.emm <- emmeans(IS.glm, \"spray\") IS.new <- split_fac(IS.emm, \"spray\", list(A = 1:2, B = c(\"low\", \"med\", \"hi\"))) str(IS.new) #> 'emmGrid' object with variables: #>     A = 1, 2 #>     B = low, med, hi #> Transformation: \"log\"   fiber.lm <- lm(strength ~ diameter + machine, data = fiber) ( frg <- ref_grid(fiber.lm) ) #>  diameter machine prediction    SE df #>      24.1 A             40.4 0.724 11 #>      24.1 B             41.4 0.744 11 #>      24.1 C             38.8 0.788 11 #>   # Suppose the machines are two different brands brands <- factor(c(\"FiberPro\", \"FiberPro\", \"Acme\"), levels = c(\"FiberPro\", \"Acme\")) ( gfrg <- add_grouping(frg, \"brand\", \"machine\", brands) ) #>  diameter machine brand    prediction    SE df #>      24.1 A       FiberPro       40.4 0.724 11 #>      24.1 B       FiberPro       41.4 0.744 11 #>      24.1 C       Acme           38.8 0.788 11 #>   emmeans(gfrg, \"machine\") #>  machine brand    emmean    SE df lower.CL upper.CL #>  A       FiberPro   40.4 0.724 11     38.8     42.0 #>  B       FiberPro   41.4 0.744 11     39.8     43.1 #>  C       Acme       38.8 0.788 11     37.1     40.5 #>  #> Confidence level used: 0.95   emmeans(gfrg, \"brand\") #>  brand    emmean    SE df lower.CL upper.CL #>  FiberPro   40.9 0.531 11     39.7     42.1 #>  Acme       38.8 0.788 11     37.1     40.5 #>  #> Results are averaged over the levels of: machine  #> Confidence level used: 0.95   ### More than one reference factor warp.lm <- lm(breaks ~ wool * tension, data = warpbreaks) gwrg <- add_grouping(ref_grid(warp.lm),      \"prod\",  c(\"tension\", \"wool\"),  c(2, 1, 1,  1, 2, 1))         # level combinations:         LA MA HA  LB MB HB  emmeans(gwrg, ~ wool * tension)   # some NAs due to impossible combinations #>  wool tension prod emmean   SE df lower.CL upper.CL #>  A    L       1    nonEst   NA NA       NA       NA #>  B    L       1      28.2 3.65 48     20.9     35.6 #>  A    M       1      24.0 3.65 48     16.7     31.3 #>  B    M       1    nonEst   NA NA       NA       NA #>  A    H       1      24.6 3.65 48     17.2     31.9 #>  B    H       1      18.8 3.65 48     11.4     26.1 #>  A    L       2      44.6 3.65 48     37.2     51.9 #>  B    L       2    nonEst   NA NA       NA       NA #>  A    M       2    nonEst   NA NA       NA       NA #>  B    M       2      28.8 3.65 48     21.4     36.1 #>  #> Confidence level used: 0.95   emmeans(gwrg, \"prod\") #>  prod emmean   SE df lower.CL upper.CL #>  1      24.6 1.92 48     20.8     28.5 #>  2      36.7 2.58 48     31.5     41.9 #>  #> Results are averaged over the levels of: wool, tension  #> Confidence level used: 0.95   str(v.c.g) #> 'emmGrid' object with variables: #>     vs = 0, 1 #>     cyl = 4, 6, 8 #>     gear = 3, 4, 5 #> Some things are non-estimable (null space dim = 1) str(permute_levels(v.c.g, \"cyl\", c(2,3,1))) #> 'emmGrid' object with variables: #>     vs = 0, 1 #>     cyl = 8, 4, 6 #>     gear = 3, 4, 5 #> Some things are non-estimable (null space dim = 1)"},{"path":"https://rvlenth.github.io/emmeans/reference/mcmc-support.html","id":null,"dir":"Reference","previous_headings":"","what":"Support for MCMC-based estimation — as.mcmc.emmGrid","title":"Support for MCMC-based estimation — as.mcmc.emmGrid","text":"model fitted using Markov chain Monte Carlo (MCMC) methods,  reference grid contains post.beta slot. functions  transform posterior samples posterior samples EMMs related contrasts. can summarized plotted using, e.g., functions coda package.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/mcmc-support.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Support for MCMC-based estimation — as.mcmc.emmGrid","text":"","code":"# S3 method for emmGrid as.mcmc(x, names = TRUE, sep.chains = TRUE, likelihood,   NE.include = FALSE, ...)  # S3 method for emm_list as.mcmc(x, which = 1, ...)  # S3 method for emmGrid as.mcmc.list(x, names = TRUE, ...)  # S3 method for emm_list as.mcmc.list(x, which = 1, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/mcmc-support.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Support for MCMC-based estimation — as.mcmc.emmGrid","text":"x object class emmGrid names Logical scalar vector specifying whether variable names appended levels column labels .mcmc .mcmc.list result -- e.g., column names treat treat B versus  just B. one variable involved, elements names used cyclically. sep.chains Logical value. TRUE, one MCMC chain available, mcmc.list object returned .mcmc, separate EMMs posteriors chain. likelihood Character value function. given, simulations made  corresponding posterior predictive distribution. given, obtain posterior distribution parameters object. See Prediction section . NE.include Logical value. TRUE, non-estimable columns kept returned columns NA values (may create errors warnings subsequent analyses using, say, coda). FALSE, non-estimable columns dropped, warning issued. (non-estimable, error thrown.) ... arguments passed methods item emm_list use","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/mcmc-support.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Support for MCMC-based estimation — as.mcmc.emmGrid","text":"object class mcmc mcmc.list.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/mcmc-support.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Support for MCMC-based estimation — as.mcmc.emmGrid","text":"object's post.beta slot non-trivial, .mcmc return mcmc mcmc.list object can summarized plotted using methods coda package. functions, post.beta transformed post-multiplying t(linfct), creating sample posterior distribution LS means. .mcmc, sep.chains TRUE fact one chain, mcmc.list returned chain's results. .mcmc.list method guaranteed return mcmc.list, even comprises just one chain.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/mcmc-support.html","id":"prediction","dir":"Reference","previous_headings":"","what":"Prediction","title":"Support for MCMC-based estimation — as.mcmc.emmGrid","text":"likelihood specified, used simulate values posterior predictive distribution corresponding given likelihood posterior distribution parameter values. Denote likelihood  function \\(f(y|\\theta,\\phi)\\), \\(y\\) response, \\(\\theta\\) parameter estimated object, \\(\\phi\\) comprises zero additional parameters specified. likelihood  function, function take first argument vector  \\(\\theta\\) values (corresponding one row object@grid). \\(\\phi\\) values specified additional named function arguments, passed likelihood via .... function  simulate values \\(y\\). standard likelihoods available specifying likelihood character value. : \"normal\" normal distribution mean \\(\\theta\\)   standard deviation specified additional argument sigma \"binomial\" binomial distribution success probability      \\(theta\\), number trials specified trials \"poisson\" Poisson distribution mean \\(theta\\)      (additional parameters) \"gamma\" gamma distribution scale parameter \\(\\theta\\)     shape parameter specified shape","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/mcmc-support.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Support for MCMC-based estimation — as.mcmc.emmGrid","text":"","code":"if(requireNamespace(\"coda\"))      emm_example(\"as.mcmc-coda\") #>  #> --- Running code from 'system.file(\"extexamples\", \"as.mcmc-coda.R\", package = \"emmeans\")' #>  #> > cbpp.rg <- do.call(emmobj, readRDS(system.file(\"extdata\",  #> +     \"cbpplist\", package = \"emmeans\"))) #>  #> > pred.incidence <- coda::as.mcmc(regrid(cbpp.rg), likelihood = \"binomial\",  #> +     trials = 20) #>  #> > summary(pred.incidence) #>  #> Iterations = 1:250 #> Thinning interval = 1  #> Number of chains = 2  #> Sample size per chain = 250  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                                 Mean    SD Naive SE Time-series SE #> size 15.0357142857143 period 1 3.866 1.889  0.08447        0.09115 #> size 15.0357142857143 period 2 1.716 1.325  0.05924        0.05930 #> size 15.0357142857143 period 3 1.436 1.290  0.05771        0.08159 #> size 15.0357142857143 period 4 1.082 1.059  0.04736        0.04728 #>  #> 2. Quantiles for each variable: #>  #>                                2.5% 25% 50% 75% 97.5% #> size 15.0357142857143 period 1    1   3   4   5     8 #> size 15.0357142857143 period 2    0   1   2   2     5 #> size 15.0357142857143 period 3    0   0   1   2     4 #> size 15.0357142857143 period 4    0   0   1   2     4 #>  #>      # Use emm_example(\"as.mcmc-coda\", list = TRUE) # to see just the code"},{"path":"https://rvlenth.github.io/emmeans/reference/MOats.html","id":null,"dir":"Reference","previous_headings":"","what":"Oats data in multivariate form — MOats","title":"Oats data in multivariate form — MOats","text":"Oats dataset provided nlme package, rearranged one multivariate observation per plot.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/MOats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Oats data in multivariate form — MOats","text":"","code":"MOats"},{"path":"https://rvlenth.github.io/emmeans/reference/MOats.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Oats data in multivariate form — MOats","text":"data frame 18 observations 3 variables Variety factor levels Golden Rain,     Marvellous, Victory Block ordered factor levels VI < V <     III < IV < II < yield matrix 4 columns, giving yields     nitrogen concentrations 0, .2, .4, .6.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/MOats.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Oats data in multivariate form — MOats","text":"dataset Oats nlme package.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/MOats.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Oats data in multivariate form — MOats","text":"data arise split-plot experiment reported Yates (1935) used example Pinheiro Bates (2000) texts. Six blocks divided three whole plots, randomly assigned three varieties oats. whole plots divided 4 split plots randomized four concentrations nitrogen.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/MOats.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Oats data in multivariate form — MOats","text":"Pinheiro, J. C. Bates D. M. (2000) Mixed-Effects Models S S-PLUS, Springer, New York. (Appendix .15) Yates, F. (1935) Complex experiments, Journal Royal Statistical Society Suppl. 2, 181-247","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/MOats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Oats data in multivariate form — MOats","text":"","code":"MOats.lm <- lm (yield ~ Block + Variety, data = MOats) MOats.rg <- ref_grid (MOats.lm, mult.name = \"nitro\") emmeans(MOats.rg, ~ nitro | Variety) #> Variety = Golden Rain: #>  nitro emmean   SE df lower.CL upper.CL #>  0       80.0 5.54 10     67.7     92.3 #>  0.2     98.5 6.60 10     83.8    113.2 #>  0.4    114.7 8.70 10     95.3    134.0 #>  0.6    124.8 7.30 10    108.6    141.1 #>  #> Variety = Marvellous: #>  nitro emmean   SE df lower.CL upper.CL #>  0       86.7 5.54 10     74.3     99.0 #>  0.2    108.5 6.60 10     93.8    123.2 #>  0.4    117.2 8.70 10     97.8    136.5 #>  0.6    126.8 7.30 10    110.6    143.1 #>  #> Variety = Victory: #>  nitro emmean   SE df lower.CL upper.CL #>  0       71.5 5.54 10     59.2     83.8 #>  0.2     89.7 6.60 10     75.0    104.4 #>  0.4    110.8 8.70 10     91.5    130.2 #>  0.6    118.5 7.30 10    102.2    134.8 #>  #> Results are averaged over the levels of: Block  #> Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/reference/models.html","id":null,"dir":"Reference","previous_headings":"","what":"Models supported in emmeans — models","title":"Models supported in emmeans — models","text":"Documentation models moved vignette. access , use vignette(\"models\", \"emmeans\").","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/mvcontrast.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate contrasts — mvcontrast","title":"Multivariate contrasts — mvcontrast","text":"function displays tests multivariate comparisons contrasts. contrasts constructed level variable mult.name, multivariate test vector estimates equal null (zero default). F statistic degrees freedom determined via Hotelling distribution. , \\(m\\) error degrees freedom multivariate dimensionality \\(d\\), resulting \\(F\\) statistic degrees freedom \\((d, m - d + 1)\\) shown Hotelling (1931).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/mvcontrast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate contrasts — mvcontrast","text":"","code":"mvcontrast(object, method = \"eff\", mult.name = object@roles$multresp,   null = 0, by = object@misc$by.vars, adjust = c(\"sidak\",   p.adjust.methods), show.ests = FALSE, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/mvcontrast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate contrasts — mvcontrast","text":"object object class emmGrid method contrast method, per contrast.emmGrid mult.name Character vector nNames factors whose levels define multivariate means contrast. model multivariate response, used. Otherwise, mult.name must specified. null Scalar conformable vector null-hypothesis values test variable(s). include primary variables contrasted. convenience, variable nulled-result primary factors contrasted. adjust Character value multiplicity adjustment method (\"none\" adjustment). available adjustment methods limited contrast, default adjustment returned via method ignored. show.ests Logical flag determining whether multivariate means  displayed ... Additional arguments passed contrast","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/mvcontrast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate contrasts — mvcontrast","text":"object class summary_emm containing multivariate   test results; list estimates tests show.ests TRUE. test results include Hotelling \\(T^2\\) statistic,  \\(F\\) ratios, degrees freedom, \\(P\\) values.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/mvcontrast.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Multivariate contrasts — mvcontrast","text":"interactions among primary mult.name factors absent, covariance multivariate means singular; situation accommodated, result reduced degrees freedom message displayed. abnormal conditions non-estimable results, estimates shown NA. designed primarily testing contrasts, multivariate tests mean vector can implemented via method = \"identity\") (see examples).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/mvcontrast.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Multivariate contrasts — mvcontrast","text":"Hotelling, Harold (1931) \"generalization Student's ratio\",    Annals Mathematical Statistics 2(3), 360–378. doi:10.1214/aoms/1177732979","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/mvcontrast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multivariate contrasts — mvcontrast","text":"","code":"MOats.lm <- lm(yield ~ Variety + Block, data = MOats) MOats.emm <- emmeans(MOats.lm, ~ Variety | rep.meas) mvcontrast(MOats.emm, \"consec\", show.ests = TRUE)  # mult.name defaults to rep.meas #> $estimates #> contrast = Marvellous - Golden Rain: #>  rep.meas    estimate    SE df t.ratio p.value #>  rep.meas0       6.67  7.84 10   0.851  0.4148 #>  rep.meas0.2    10.00  9.34 10   1.071  0.3093 #>  rep.meas0.4     2.50 12.30 10   0.203  0.8430 #>  rep.meas0.6     2.00 10.33 10   0.194  0.8503 #>  #> contrast = Victory - Marvellous: #>  rep.meas    estimate    SE df t.ratio p.value #>  rep.meas0     -15.17  7.84 10  -1.936  0.0817 #>  rep.meas0.2   -18.83  9.34 10  -2.017  0.0713 #>  rep.meas0.4    -6.33 12.30 10  -0.515  0.6177 #>  rep.meas0.6    -8.33 10.33 10  -0.807  0.4385 #>  #> Results are averaged over the levels of: Block  #>  #> $tests #>  contrast                 T.square df1 df2 F.ratio p.value #>  Marvellous - Golden Rain    3.082   4   7   0.539  0.9174 #>  Victory - Marvellous        9.181   4   7   1.607  0.4726 #>  #> P value adjustment: sidak  #>   # Test each mean against a specified null vector mvcontrast(MOats.emm, \"identity\", name = \"Variety\",             null = c(80, 100, 120, 140), adjust = \"none\") #>  Variety     T.square df1 df2 F.ratio p.value #>  Golden Rain   10.001   4   7   1.750  0.2430 #>  Marvellous    26.628   4   7   4.660  0.0377 #>  Victory       10.232   4   7   1.791  0.2352 #>  # (Note 'name' is passed to contrast() and overrides default name \"contrast\")  # 'mult.name' need not refer to a multivariate response mvcontrast(MOats.emm, \"trt.vs.ctrl1\", mult.name = \"Variety\") #>  contrast                T.square df1 df2 F.ratio p.value #>  rep.meas0.2 - rep.meas0   21.498   3   8   5.733  0.0634 #>  rep.meas0.4 - rep.meas0   37.578   3   8  10.021  0.0131 #>  rep.meas0.6 - rep.meas0  104.700   3   8  27.920  0.0004 #>  #> P value adjustment: sidak"},{"path":"https://rvlenth.github.io/emmeans/reference/neuralgia.html","id":null,"dir":"Reference","previous_headings":"","what":"Neuralgia data — neuralgia","title":"Neuralgia data — neuralgia","text":"data arise study analgesic effects treatments elderly patients neuralgia. Two treatments placebo compared.  response variable whether patient reported pain . Researchers recorded age gender 60 patients along duration complaint treatment began.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/neuralgia.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neuralgia data — neuralgia","text":"","code":"neuralgia"},{"path":"https://rvlenth.github.io/emmeans/reference/neuralgia.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Neuralgia data — neuralgia","text":"data frame 60 observations 5 variables: Treatment Factor 3 levels , B, P.     latter placebo Sex Factor two levels F M Age Numeric covariate -- patient's age years Duration Numeric covariate -- duration condition     beginning treatment Pain Binary response factor levels Yes","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/neuralgia.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Neuralgia data — neuralgia","text":"Cai, Weijie (2014) Making Comparisons Fair: LS-Means Unify    Analysis Linear Models, SAS Institute, Inc. Technical paper 142-2014,   page 12,    http://support.sas.com/resources/papers/proceedings14/SAS060-2014.pdf","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/neuralgia.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Neuralgia data — neuralgia","text":"","code":"# Model and analysis shown in the SAS report: neuralgia.glm <- glm(Pain ~ Treatment * Sex + Age, family = binomial(),    data = neuralgia)  pairs(emmeans(neuralgia.glm, ~ Treatment, at = list(Sex = \"F\")),      reverse = TRUE, type = \"response\", adjust = \"bonferroni\") #> NOTE: Results may be misleading due to involvement in interactions #>  contrast odds.ratio     SE  df null z.ratio p.value #>  B / A         0.398  0.648 Inf    1  -0.566  1.0000 #>  P / A        16.892 22.309 Inf    1   2.141  0.0969 #>  P / B        42.492 63.447 Inf    1   2.511  0.0361 #>  #> P value adjustment: bonferroni method for 3 tests  #> Tests are performed on the log odds ratio scale"},{"path":"https://rvlenth.github.io/emmeans/reference/nutrition.html","id":null,"dir":"Reference","previous_headings":"","what":"Nutrition data — nutrition","title":"Nutrition data — nutrition","text":"observational dataset involves three factors, several factor  combinations missing. used case study Milliken Johnson, Chapter 17, p.202. (may also find second edition, p.278.)","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/nutrition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nutrition data — nutrition","text":"","code":"nutrition"},{"path":"https://rvlenth.github.io/emmeans/reference/nutrition.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Nutrition data — nutrition","text":"data frame 107 observations 4 variables: age factor levels 1, 2, 3,     4. Mother's age group. group factor levels FoodStamps, NoAid.     Whether family receives food stamp assistance. race factor levels Black, Hispanic,     White. Mother's race. gain numeric vector (response variable). Gain score     (posttest minus pretest) knowledge nutrition.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/nutrition.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Nutrition data — nutrition","text":"Milliken, G. . Johnson, D. E. (1984) Analysis Messy Data -- Volume : Designed Experiments.  Van Nostrand, ISBN 0-534-02713-7.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/nutrition.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nutrition data — nutrition","text":"survey conducted home economists ``study much lower-socioeconomic-level mothers knew nutrition judge effect training program designed increase knowledge nutrition.'' messy dataset several empty cells.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/nutrition.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nutrition data — nutrition","text":"","code":"nutr.aov <- aov(gain ~ (group + age + race)^2, data = nutrition)  # Summarize predictions for age group 3 nutr.emm <- emmeans(nutr.aov, ~ race * group, at = list(age=\"3\"))                     emmip(nutr.emm, race ~ group)   # Hispanics seem exceptional; but this doesn't test out due to very sparse data pairs(nutr.emm, by = \"group\") #> group = FoodStamps: #>  contrast         estimate   SE df t.ratio p.value #>  Black - Hispanic     7.50 5.97 92   1.255  0.4241 #>  Black - White        2.08 2.84 92   0.733  0.7447 #>  Hispanic - White    -5.42 5.43 92  -0.998  0.5799 #>  #> group = NoAid: #>  contrast         estimate   SE df t.ratio p.value #>  Black - Hispanic    -6.17 4.36 92  -1.413  0.3383 #>  Black - White       -3.47 2.49 92  -1.394  0.3484 #>  Hispanic - White     2.70 3.96 92   0.681  0.7750 #>  #> P value adjustment: tukey method for comparing a family of 3 estimates  pairs(nutr.emm, by = \"race\") #> race = Black: #>  contrast           estimate   SE df t.ratio p.value #>  FoodStamps - NoAid    11.17 3.45 92   3.237  0.0017 #>  #> race = Hispanic: #>  contrast           estimate   SE df t.ratio p.value #>  FoodStamps - NoAid    -2.50 6.55 92  -0.382  0.7034 #>  #> race = White: #>  contrast           estimate   SE df t.ratio p.value #>  FoodStamps - NoAid     5.62 1.53 92   3.666  0.0004 #>"},{"path":"https://rvlenth.github.io/emmeans/reference/oranges.html","id":null,"dir":"Reference","previous_headings":"","what":"Sales of oranges — oranges","title":"Sales of oranges — oranges","text":"example dataset sales oranges two factors, two covariates, two responses. one observation per factor combination.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/oranges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sales of oranges — oranges","text":"","code":"oranges"},{"path":"https://rvlenth.github.io/emmeans/reference/oranges.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sales of oranges — oranges","text":"data frame 36 observations 6 variables: store factor levels 1 2 3     4 5 6. store observed. day factor levels 1 2 3     4 5 6. day observation taken (    store). price1 numeric vector. Price variety 1. price2 numeric vector. Price variety 2. sales1 numeric vector. Sales (per customer) variety 1. sales2 numeric vector. Sales (per customer) variety 2.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/oranges.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sales of oranges — oranges","text":"() available SAS sample dataset.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/oranges.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sales of oranges — oranges","text":"Littell, R., Stroup W., Freund, R. (2002) SAS Linear Models (4th edition). SAS Institute. ISBN 1-59047-023-0.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/oranges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sales of oranges — oranges","text":"","code":"# Example on p.244 of Littell et al. oranges.lm <- lm(sales1 ~ price1*day, data = oranges) emmeans(oranges.lm, \"day\") #> NOTE: Results may be misleading due to involvement in interactions #>  day emmean   SE df lower.CL upper.CL #>  1     7.38 2.01 24     3.23     11.5 #>  2     6.55 1.92 24     2.58     10.5 #>  3    14.03 1.92 24    10.07     18.0 #>  4     8.40 1.91 24     4.46     12.3 #>  5    16.65 2.47 24    11.55     21.7 #>  6    10.51 1.92 24     6.55     14.5 #>  #> Confidence level used: 0.95   # Example on p.246 of Littell et al. emmeans(oranges.lm, \"day\", at = list(price1 = 0)) #> NOTE: Results may be misleading due to involvement in interactions #>  day emmean   SE df lower.CL upper.CL #>  1     18.7 14.4 24   -11.07     48.4 #>  2     38.5 15.1 24     7.30     69.7 #>  3     45.3 26.2 24    -8.66     99.3 #>  4     49.1 16.6 24    14.87     83.4 #>  5     77.9 27.5 24    21.14    134.7 #>  6     73.3 13.5 24    45.44    101.1 #>  #> Confidence level used: 0.95   # A more sensible model to consider, IMHO (see vignette(\"interactions\")) org.mlm <- lm(cbind(sales1, sales2) ~ price1 * price2 + day + store,                data = oranges)"},{"path":"https://rvlenth.github.io/emmeans/reference/pigs.html","id":null,"dir":"Reference","previous_headings":"","what":"Effects of dietary protein on free plasma leucine concentration in pigs — pigs","title":"Effects of dietary protein on free plasma leucine concentration in pigs — pigs","text":"two-factor experiment observations lost","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/pigs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Effects of dietary protein on free plasma leucine concentration in pigs — pigs","text":"","code":"pigs"},{"path":"https://rvlenth.github.io/emmeans/reference/pigs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Effects of dietary protein on free plasma leucine concentration in pigs — pigs","text":"data frame 29 observations 3 variables: source Source protein diet (factor 3 levels:      fish meal, soybean meal, dried skim milk) percent Protein percentage diet (numeric 4 values:     9, 12, 15, 18) conc Concentration free plasma leucine, mcg/ml","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/pigs.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Effects of dietary protein on free plasma leucine concentration in pigs — pigs","text":"Windels HF (1964) PhD thesis, Univ. Minnesota. (Reported   Problem 10.8 Oehlert G (2000) First Course Design   Analysis Experiments, licensed Creative Commons,   http://users.stat.umn.edu/~gary/Book.html.) Observations 7, 22, 23,   31, 33, 35 omitted, creating notable imbalance.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/pigs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Effects of dietary protein on free plasma leucine concentration in pigs — pigs","text":"","code":"pigs.lm <- lm(inverse(conc) ~ source + factor(percent), data = pigs)   emmeans(pigs.lm, \"source\") #>  source emmean       SE df lower.CL upper.CL #>  fish   0.0337 0.000926 23   0.0318   0.0356 #>  soy    0.0257 0.000945 23   0.0237   0.0276 #>  skim   0.0229 0.000994 23   0.0208   0.0249 #>  #> Results are averaged over the levels of: percent  #> Results are given on the inverse (not the response) scale.  #> Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/reference/plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot an emmGrid or summary_emm object — plot.emmGrid","title":"Plot an emmGrid or summary_emm object — plot.emmGrid","text":"Methods provided plot EMMs side--side CIs, optionally display    “comparison arrows” displaying pairwise comparisons.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot an emmGrid or summary_emm object — plot.emmGrid","text":"","code":"# S3 method for emmGrid plot(x, y, type, CIs = TRUE, PIs = FALSE,   comparisons = FALSE, colors = c(\"black\", \"blue\", \"blue\", \"red\"),   alpha = 0.05, adjust = \"tukey\", int.adjust = \"none\", intervals, ...)  # S3 method for summary_emm plot(x, y, horizontal = TRUE, CIs = TRUE, xlab, ylab,   layout, scale = NULL, colors = c(\"black\", \"blue\", \"blue\", \"red\"),   intervals, plotit = TRUE, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot an emmGrid or summary_emm object — plot.emmGrid","text":"x Object class emmGrid summary_emm y (Required ignored) type Character value specifying type prediction desired (matching \"linear.predictor\", \"link\", \"response\"). See details summary.emmGrid. addition, user may specify type = \"scale\", case transformed scale (e.g., log scale) displayed based transformation link function used. Additional customization scale available including arguments ggplot2::scale_x_continuous ... . CIs Logical value. TRUE, confidence intervals plotted estimate. PIs Logical value. TRUE, prediction intervals plotted estimate. object Bayesian model, requires ... arguments include frequentist = TRUE sigma = (value). Note PIs option available summary_emm objects -- emmGrid objects. Also, prediction intervals available engine = \"lattice\". comparisons Logical value. TRUE, “comparison arrows” added plot, way degree arrows overlap reflects much possible significance comparison two estimates. (warning issued done.) Note comparison arrows available `summary_emm` objects. colors Character vector color names use estimates, CIs, PIs,  comparison arrows, respectively. CIs PIs rendered transparency, colors recycled length less four; plot elements visible even single color specified. alpha significance level use constructing comparison arrows adjust Character value: Multiplicity adjustment method comparison arrows . int.adjust Character value: Multiplicity adjustment method plotted confidence intervals . intervals specified, used set CIs. previous argument name CIs provided backward compatibility. ... Additional arguments passed update.emmGrid,  summary.emmGrid, predict.emmGrid, dotplot horizontal Logical value specifying whether intervals plotted horizontally vertically xlab Character label horizontal axis ylab Character label vertical axis layout Numeric value passed dotplot engine == \"lattice\". scale Object class trans (scales package) specify nonlinear scale. used lieu type = \"scale\" plotting summary_emm object created type = \"response\". ignored types summaries. plotit Logical value. TRUE, graphical object returned; FALSE, data.frame returned containing values used construct plot.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot an emmGrid or summary_emm object — plot.emmGrid","text":"plotit = TRUE, graphical object returned. plotit = FALSE, data.frame table   EMMs plotted. latter case, estimate plotted   named .emmean, factors involved names   object. Confidence limits named lower.CL  upper.CL, prediction limits named lpl upl,   comparison-arrow limits named lcmpl ucmpl.   also variable named pri.fac contains factor    combinations among variables.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/plot.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Plot an emmGrid or summary_emm object — plot.emmGrid","text":"order play nice plotting functions, variable names syntactically correct (e.g., contain spaces) altered using make.names.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot an emmGrid or summary_emm object — plot.emmGrid","text":"variables force, plot divided separate panels. \"summary_emm\" objects, ... arguments plot passed dotplot, whereas \"emmGrid\" objects, object updated using ... summarizing plotting. plots comparisons = TRUE, resulting arrows approximate, cases may fail accurately reflect pairwise comparisons estimates -- especially estimates large small standard errors intermingled just wrong way. Note maximum minimum estimates arrows one direction, since need compare anything higher lower, respectively. See vignette(\"xplanations\", \"emmeans\") details derived. adjust int.adjust supplied, default  internal adjust setting saved pairs(x) x  respectively (see update.emmGrid).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot an emmGrid or summary_emm object — plot.emmGrid","text":"","code":"warp.lm <- lm(breaks ~ wool * tension, data = warpbreaks) warp.emm <- emmeans(warp.lm, ~ tension | wool) plot(warp.emm)  plot(warp.emm, by = NULL, comparisons = TRUE, adjust = \"mvt\",       horizontal = FALSE, colors = \"darkgreen\")   ### Using a transformed scale pigs.lm <- lm(log(conc + 2) ~ source * factor(percent), data = pigs) pigs.emm <- emmeans(pigs.lm, ~ percent | source) plot(pigs.emm, type = \"scale\", breaks = seq(20, 100, by = 10))   # Based on a summary.  # To get a transformed axis, must specify 'scale'; but it does not necessarily # have to be the same as the actual response transformation pigs.ci <- confint(pigs.emm, type = \"response\") plot(pigs.ci, scale = scales::log10_trans())"},{"path":"https://rvlenth.github.io/emmeans/reference/pwpm.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise P-value matrix (plus other statistics) — pwpm","title":"Pairwise P-value matrix (plus other statistics) — pwpm","text":"function presents results emmeans pairwise comparisons thereof compact way. displays matrix (matrices) estimates, pairwise differences, P values. user may opt exclude via arguments means, diffs, pvals, respectively. control direction pairwise differences, use reverse; control appears upper lower triangle(s), use flip. Optional arguments passed contrast.emmGrid / summary.emmGrid, making possible control estimates  tests displayed.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/pwpm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise P-value matrix (plus other statistics) — pwpm","text":"","code":"pwpm(emm, by, reverse = FALSE, pvals = TRUE, means = TRUE,   diffs = TRUE, flip = FALSE, digits, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/pwpm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise P-value matrix (plus other statistics) — pwpm","text":"emm emmGrid object Character vector variable(s) grid condition . create different matrices, one level level-combination. missing, set emm@misc$.vars. Grid factors primary factors: whose levels level combinations compared pairwise. reverse Logical value passed pairs.emmGrid. Thus, FALSE specifies \"pairwise\" comparisons  (earlier vs. later), TRUE specifies \"revpairwise\" comparisons (later vs. earlier). pvals Logical value. TRUE, pairwise differences  EMMs included matrix according flip. means Logical value. TRUE, estimated marginal means (EMMs) emm included matrix diagonal(s). diffs Logical value. TRUE, pairwise differences  EMMs included matrix according flip. flip Logical value determines P values differences  placed. FALSE places P values upper triangle differences lower, TRUE just opposite. digits Integer. Number digits display. missing, optimal number digits determined. ... Additional arguments passed contrast.emmGrid  summary.emmGrid. include method , pairwise comparisons always used.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/pwpm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise P-value matrix (plus other statistics) — pwpm","text":"matrix `list` matrices, one `` level.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/pwpm.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Pairwise P-value matrix (plus other statistics) — pwpm","text":"emm result Bayesian analysis, pwpm   based frequentist analysis","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/pwpm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise P-value matrix (plus other statistics) — pwpm","text":"","code":"warp.lm <- lm(breaks ~ wool * tension, data = warpbreaks) warp.emm <- emmeans(warp.lm, ~ tension | wool)  pwpm(warp.emm) #>  #> wool = A #>        L      M      H #> L [44.6] 0.0007 0.0009 #> M 20.556 [24.0] 0.9936 #> H 20.000 -0.556 [24.6] #>  #> wool = B #>        L      M      H #> L [28.2] 0.9936 0.1704 #> M -0.556 [28.8] 0.1389 #> H  9.444 10.000 [18.8] #>  #> Row and column labels: tension #> Upper triangle: P values   adjust = \"tukey\" #> Diagonal: [Estimates] (emmean)  #> Lower triangle: Comparisons (estimate)   earlier vs. later  # use dot options to specify noninferiority tests pwpm(warp.emm, by = NULL, side = \">\", delta = 5, adjust = \"none\") #>        L A    M A    H A    L B    M B    H B #> L A [44.6] <.0001 <.0001 <.0001 <.0001 <.0001 #> M A 20.556 [24.0] 0.1965 0.4404 0.4829 0.0266 #> H A 20.000 -0.556 [24.6] 0.3986 0.4404 0.0210 #> L B 16.333 -4.222 -3.667 [28.2] 0.1965 0.0037 #> M B 15.778 -4.778 -4.222 -0.556 [28.8] 0.0027 #> H B 25.778  5.222  5.778  9.444 10.000 [18.8] #>  #> Row and column labels: tension:wool #> Upper triangle: P values   side = \">\"  delta = 5 #> Diagonal: [Estimates] (emmean)  #> Lower triangle: Comparisons (estimate)   earlier vs. later"},{"path":"https://rvlenth.github.io/emmeans/reference/pwpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise P-value plot — pwpp","title":"Pairwise P-value plot — pwpp","text":"Constructs plot P values associated pairwise comparisons  estimated marginal means.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/pwpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise P-value plot — pwpp","text":"","code":"pwpp(emm, method = \"pairwise\", by, sort = TRUE, values = TRUE,   rows = \".\", xlab, ylab, xsub = \"\", plim = numeric(0), add.space = 0,   aes, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/pwpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise P-value plot — pwpp","text":"emm emmGrid object method Character list. Passed contrast, defines  contrasts displayed. contrast method may used, provided contrast includes one coefficient 1, one coefficient -1, rest 0. , calling contrast(object, method) produces set comparisons, one estimate minus another estimate. Character vector variable(s) grid condition . create different panels, one level level-combination. Grid factors primary factors:  whose levels level combinations compared pairwise. sort Logical value. TRUE, levels factor combinations ordered marginal means. FALSE, appear order based existing ordering factor levels involved. Note levels ordered way panels, many cases implies means particular panel ordered even sort = TRUE. values Logical value. TRUE, values EMMs included plot. several side--side panels due variable(s), labels showing values start stealing lot space plotting area; cases, may desirable specify FALSE use rows panels vertically stacked. rows Character vector variable(s) used define rows panel layout. variables included  rows define columns array panels. \".\" indicates one row used, panels stacked side--side. xlab Character label use place default P-value axis. ylab Character label use place default primary-factor axis. xsub Character label used caption lower right plot. plim numeric vector value(s) 0 1. included among observed p values range tick marks includes least range plim. Choosing plim = c(0,1) ensure widest possible range. add.space Numeric value adjust amount space used value labels. Positioning value labels tricky, depends many panels physical size plotting region. parameter allows user adjust position. Changing one unit shift position one character width (right positive, left negative). Note interacts aes$label . aes optional named list lists. Entries considered point,  segment, label, contents passed respective ggplot2::geom_xxx() functions. affect rendering points,  line segments joining , value labels.  Defaults point = list(size = 2), segment = list(), label = list(size = 2.5). ... Additional arguments passed contrast summary.emmGrid,  well geom_segment geom_label","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/pwpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pairwise P-value plot — pwpp","text":"Factor levels (combinations thereof) plotted vertical scale, P values plotted horizontal scale. P value plotted twice -- vertical positions corresponding levels compared -- connected line segment. Thus, easy visualize P values small large, levels compared. addition, factor levels color-coded, points half-line segments appear color level. P-value scale nonlinear, stretch-smaller P values compress larger ones. P values smaller 0.0004 altered plotted way makes    distinguishable one another. xlab, ylab, xsub provided, reasonable labels created. xsub used note special features; e.g., equivalence thresholds one-sided tests.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/pwpp.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Pairwise P-value plot — pwpp","text":"emm result Bayesian analysis, plot based   summaries frequentist = TRUE. ggplot2 scales packages must installed order    pwpp work. Additional plot aesthetics available adding returned object;   see examples","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/pwpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise P-value plot — pwpp","text":"","code":"pigs.lm <- lm(log(conc) ~ source * factor(percent), data = pigs) emm = emmeans(pigs.lm, ~ percent | source) pwpp(emm)  pwpp(emm, method = \"trt.vs.ctrl1\", type = \"response\", side = \">\") #> Note: adjust = \"dunnettx\" was changed to \"sidak\" #> because \"dunnettx\" is not appropriate for one-sided inferences   # custom aesthetics: my.aes <- list(point = list(shape = \"square\"),                 segment = list(linetype = \"dashed\", color = \"red\"),                label = list(family = \"serif\", fontface = \"italic\")) my.pal <- c(\"darkgreen\", \"blue\", \"magenta\", \"orange\") pwpp(emm, aes = my.aes) + ggplot2::scale_color_manual(values = my.pal)"},{"path":"https://rvlenth.github.io/emmeans/reference/qdrg.html","id":null,"dir":"Reference","previous_headings":"","what":"Quick and dirty reference grid — qdrg","title":"Quick and dirty reference grid — qdrg","text":"function may make possible compute reference grid model  object otherwise supported.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/qdrg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quick and dirty reference grid — qdrg","text":"","code":"qdrg(formula, data, coef, vcov, df, mcmc, object, subset, weights, contrasts,   link, qr, ordinal, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/qdrg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quick and dirty reference grid — qdrg","text":"formula Formula fixed effects data Dataset containing variables model coef Fixed-effect regression coefficients (must conform formula) vcov Variance-covariance matrix fixed effects df Error degrees freedom mcmc Posterior sample fixed-effect coefficients object Optional model object. rarely works!;  provided, try set  arguments based expectation `object` similar structure `lm` objects. See Details. subset Subset data used fitting model weights Weights used fitting model contrasts List contrasts specified fitting model link Link function (character list) used, generalized linear model. (Note: response transformations auto-detected formula) qr QR decomposition model matrix; used NAs coef. ordinal list elements dim mode. ordinal$dim (integer) number levels ordinal response.  ordinal provided, intercept terms modified appropriate predicting  ordinal response, described vignette(\"models\"), Section O, using ordinal$mode mode argument (provided, \"latent\" assumed). (modes supported except `scale`) work, expect first ordinal$dim - 1 elements coef estimated threshold parameters, followed coefficients linear predictor. ... Optional arguments passed ref_grid","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/qdrg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quick and dirty reference grid — qdrg","text":"emmGrid object constructed arguments","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/qdrg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quick and dirty reference grid — qdrg","text":"Usually, need provide either object; formula, coef, vcov, data, perhaps parameters. usually fairly straightforward figure get model object; see documentation model class fitted. Sometimes one quantities contains extra parameters, , may need subset make everything conformable. given formula data, can find needed via colnames(model.matrix(formula, data)). (However, ordinal model, expect first ordinal.dim - 1 coefficients replace (Intercept). multivariate model, expect coef  matrix row names, vcov many rows columns total number elements coef.) model object follows fairly closely conventions lm glmobject, may able get providing model object, perhaps parameters override defaults. object specified, used detailed try obtain  arguments. user ensure defaults shown indeed work.  default values arguments follows: formula: formula(object) data: recover_data.lm(object) tried, error thrown,     also check object$data. coef: coef(object) vcov: vcov(object) df: Set Inf available df.residual(object) mcmc: object$sample subset: NULL (observations data used) contrasts: object$contrasts functions qdrg emmobj close cousins, produce emmGrid objects. starting summary statistics existing grid, emmobj useful, qdrg useful starting fitted model.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/qdrg.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Quick and dirty reference grid — qdrg","text":"backwards compatibility, argument ordinal.dim invisibly  supported part ..., present, sets  ordinal = list(dim = ordinal.dim, mode = \"latent\")","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/qdrg.html","id":"rank-deficiencies","dir":"Reference","previous_headings":"","what":"Rank deficiencies","title":"Quick and dirty reference grid — qdrg","text":"Different model-fitting packages take different approaches model matrix singular, qdrg tries reconcile comparing linear functions created formula coefs vcov. may use estimability package determine quantities estimable. reconciling work properly, coef named vcov dimnames. disable name-matching action, remove names coef, e.g., calling unname(). reconciliation attempted multivariate-response cases. details estimability, see documentation estimability package.","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/qdrg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quick and dirty reference grid — qdrg","text":"","code":"# In these examples, use emm_example(..., list = TRUE) # to see just the code  if (require(biglm, quietly = TRUE))      emm_example(\"qdrg-biglm\") #>  #> --- Running code from 'system.file(\"extexamples\", \"qdrg-biglm.R\", package = \"emmeans\")' #>  #> > bigmod <- biglm(log(conc) ~ source + factor(percent),  #> +     data = pigs) #>  #> > rg1 <- qdrg(log(conc) ~ source + factor(percent),  #> +     data = pigs, coef = coef(bigmod), vcov = vcov(bigmod), df = bigmod$df.residual) #>  #> > emmeans(rg1, \"source\", type = \"response\") #>  source response   SE  df asymp.LCL asymp.UCL #>  fish       29.8 1.09 Inf      27.7      32.0 #>  soy        39.1 1.47 Inf      36.4      42.1 #>  skim       44.6 1.75 Inf      41.2      48.1 #>  #> Results are averaged over the levels of: percent  #> Confidence level used: 0.95  #> Intervals are back-transformed from the log scale  #>       if(require(coda, quietly = TRUE) && require(lme4, quietly = TRUE))      emm_example(\"qdrg-coda\") #>  #> Attaching package: 'lme4' #> The following object is masked from 'package:nlme': #>  #>     lmList #>  #> --- Running code from 'system.file(\"extexamples\", \"qdrg-coda.R\", package = \"emmeans\")' #>  #> > post <- readRDS(system.file(\"extdata\", \"cbpplist\",  #> +     package = \"emmeans\"))$post.beta #>  #> > rg2 <- qdrg(~size + period, data = lme4::cbpp, mcmc = post,  #> +     link = \"logit\") #>  #> > summary(rg2, type = \"response\") #>  size period response lower.HPD upper.HPD #>    15 1        0.1930    0.1214     0.288 #>    15 2        0.0836    0.0398     0.137 #>    15 3        0.0748    0.0369     0.129 #>    15 4        0.0489    0.0138     0.101 #>  #> Point estimate displayed: median  #> Results are back-transformed from the logit scale  #> HPD interval probability: 0.95  #>       if(require(ordinal, quietly = TRUE))      emm_example(\"qdrg-ordinal\") #>  #> --- Running code from 'system.file(\"extexamples\", \"qdrg-ordinal.R\", package = \"emmeans\")' #>  #> > wine.clm <- clm(rating ~ temp * contact, data = wine) #>  #> > ref_grid(wine.clm) #> 'emmGrid' object with variables: #>     temp = cold, warm #>     contact = no, yes #>  #> > qdrg(object = wine.clm, ordinal.dim = 5) #> 'emmGrid' object with variables: #>     temp = cold, warm #>     contact = no, yes #>"},{"path":"https://rvlenth.github.io/emmeans/reference/rbind.emmGrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine or subset emmGrid objects — rbind.emmGrid","title":"Combine or subset emmGrid objects — rbind.emmGrid","text":"functions provide methods rbind [ may used combine emmGrid objects together, extract subset cases. primary reason  obtain multiplicity-adjusted results smaller larger families tests confidence intervals.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/rbind.emmGrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine or subset emmGrid objects — rbind.emmGrid","text":"","code":"# S3 method for emmGrid rbind(..., deparse.level = 1, adjust = \"bonferroni\")  # S3 method for emmGrid +(e1, e2)  # S3 method for emmGrid [(x, i, adjust, drop.levels = TRUE, ...)  # S3 method for emmGrid head(x, n = 6, ...)  # S3 method for emmGrid tail(x, n = 6, ...)  # S3 method for emmGrid subset(x, subset, ...)  # S3 method for emm_list rbind(..., which, adjust = \"bonferroni\")  # S3 method for summary_emm rbind(..., which)  force_regular(object)"},{"path":"https://rvlenth.github.io/emmeans/reference/rbind.emmGrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine or subset emmGrid objects — rbind.emmGrid","text":"... rbind, object(s) class emmGrid summary_emm. others, additional arguments passed methods deparse.level (required used) adjust Character value passed update.emmGrid e1, e2, x, object Objects class emmGrid Integer vector indexes drop.levels Logical value. TRUE, \"levels\" slot returned object updated hold predictor levels actually occur n integer number entries include (exclude negative) subset logical expression indicating rows grid keep Integer vector subset elements use; missing, combined","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/rbind.emmGrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine or subset emmGrid objects — rbind.emmGrid","text":"revised object class emmGrid result e1 + e2 rbind(e1, e2) rbind method emm_list objects simply combines  emmGrid objects comprising first element .... Note returned object yet summarized, adjust parameters apply combined emmGrid. rbind method summary_emm objects (list thereof) returns single summary_emm object. combined object preserves adjusted P values confidence limits original summaries, since quantities already computed. force_regular adds extra (invisible) rows emmGrid object   make regular grid (combinations factors). regular structure    needed emmeans. object can become irregular , example,   subsetting rows, obtaining contrasts nested structure.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/rbind.emmGrid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Combine or subset emmGrid objects — rbind.emmGrid","text":"rbind throws error incompatibilities   objects' coefficients, covariance structures, etc.    allowed different factors; missing level '.'   added factors needed. functions generally reset .vars NULL; want keep “” variables, follow-update.emmGrid.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/rbind.emmGrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine or subset emmGrid objects — rbind.emmGrid","text":"","code":"warp.lm <- lm(breaks ~ wool * tension, data = warpbreaks) warp.rg <- ref_grid(warp.lm)  # Do all pairwise comparisons within rows or within columns,  # all considered as one faily of tests: w.t <- pairs(emmeans(warp.rg, ~ wool | tension)) t.w <- pairs(emmeans(warp.rg, ~ tension | wool)) rbind(w.t, t.w, adjust = \"mvt\") #>  tension wool contrast estimate   SE df t.ratio p.value #>  L       .    A - B      16.333 5.16 48   3.167  0.0206 #>  M       .    A - B      -4.778 5.16 48  -0.926  0.9119 #>  H       .    A - B       5.778 5.16 48   1.120  0.8258 #>  .       A    L - M      20.556 5.16 48   3.986  0.0019 #>  .       A    L - H      20.000 5.16 48   3.878  0.0026 #>  .       A    M - H      -0.556 5.16 48  -0.108  1.0000 #>  .       B    L - M      -0.556 5.16 48  -0.108  1.0000 #>  .       B    L - H       9.444 5.16 48   1.831  0.3793 #>  .       B    M - H      10.000 5.16 48   1.939  0.3193 #>  #> P value adjustment: mvt method for 9 tests  update(w.t + t.w, adjust = \"fdr\")  ## same as above except for adjustment #>  tension wool contrast estimate   SE df t.ratio p.value #>  L       .    A - B      16.333 5.16 48   3.167  0.0080 #>  M       .    A - B      -4.778 5.16 48  -0.926  0.4614 #>  H       .    A - B       5.778 5.16 48   1.120  0.4022 #>  .       A    L - M      20.556 5.16 48   3.986  0.0014 #>  .       A    L - H      20.000 5.16 48   3.878  0.0014 #>  .       A    M - H      -0.556 5.16 48  -0.108  0.9147 #>  .       B    L - M      -0.556 5.16 48  -0.108  0.9147 #>  .       B    L - H       9.444 5.16 48   1.831  0.1319 #>  .       B    M - H      10.000 5.16 48   1.939  0.1314 #>  #> P value adjustment: fdr method for 9 tests   # Show only 3 of the 6 cases summary(warp.rg[c(2, 4, 5)]) #>  wool tension prediction   SE df #>  B    L             28.2 3.65 48 #>  B    M             28.8 3.65 48 #>  A    H             24.6 3.65 48 #>   # After-the-fact 'at' specification subset(warp.rg, wool == \"A\")  ## or warp.rg |> subset(wool == \"A\") #>  wool tension prediction   SE df #>  A    L             44.6 3.65 48 #>  A    M             24.0 3.65 48 #>  A    H             24.6 3.65 48 #>    ### Working with 'emm_list' objects mod <- lm(conc ~ source + factor(percent), data = pigs) all <- emmeans(mod, list(src = pairwise ~ source, pct = consec ~ percent)) rbind(all, which = c(2, 4), adjust = \"mvt\") #>  src.contrast pct.contrast          estimate   SE df t.ratio p.value #>  fish - soy   .                        -9.47 2.33 23  -4.059  0.0028 #>  fish - skim  .                       -15.58 2.39 23  -6.526  <.0001 #>  soy - skim   .                        -6.11 2.34 23  -2.613  0.0783 #>  .            percent12 - percent9      6.36 2.47 23   2.570  0.0853 #>  .            percent15 - percent12     1.96 2.57 23   0.763  0.9398 #>  .            percent18 - percent15     3.31 3.04 23   1.088  0.7944 #>  #> Results are averaged over some or all of the levels of: percent, source  #> P value adjustment: mvt method for 6 tests   ### Irregular object tmp <- warp.rg[-1] ## emmeans(tmp, \"tension\")   # will fail because tmp is irregular emmeans(force_regular(tmp), \"tension\")   # will show some results #> Warning: emmeans() results may be corrupted by removal of a nesting structure #> NOTE: Results may be misleading due to involvement in interactions #>  tension emmean   SE df lower.CL upper.CL #>  L       nonEst   NA NA       NA       NA #>  M         26.4 2.58 48     21.2     31.6 #>  H         21.7 2.58 48     16.5     26.9 #>  #> Results are averaged over the levels of: wool  #> Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a reference grid from a fitted model — ref_grid","title":"Create a reference grid from a fitted model — ref_grid","text":"Using fitted model object, determine reference grid estimated marginal means defined. resulting ref_grid object encapsulates information needed calculate EMMs make inferences .","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a reference grid from a fitted model — ref_grid","text":"","code":"ref_grid(object, at, cov.reduce = mean,   cov.keep = get_emm_option(\"cov.keep\"), mult.names, mult.levs,   options = get_emm_option(\"ref_grid\"), data, df, type, regrid, nesting,   offset, sigma, counterfactuals, wt.counter, avg.counter = TRUE,   nuisance = character(0), non.nuisance, wt.nuis = \"equal\",   rg.limit = get_emm_option(\"rg.limit\"), ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a reference grid from a fitted model — ref_grid","text":"object object produced supported model-fitting function, lm. Many models supported. See vignette(\"models\", \"emmeans\"). Optional named list levels corresponding variables cov.reduce function, logical value, formula; named list . covariate specified cov.keep reduced according specifications. See section “Using cov.reduce cov.keep”. cov.keep Character vector: names covariates reduced; treated factors used weighting calculations. cov.keep may also include integer value(s), , maximum used set threshold covariate many unique values automatically included cov.keep. mult.names Character value: name(s) give pseudo-factor(s) whose levels delineate elements multivariate response. provided, overrides default name(s) used class(object) multivariate response (e.g., default \"rep.meas\" \"mlm\" objects). mult.levs named list levels dimensions multivariate response. one element, combinations levels used, expand.grid order. (total) number levels must match number dimensions. mult.name specified, argument ignored. options non-NULL, named list arguments pass update.emmGrid, just object constructed. data data.frame use obtain information predictors (e.g. factor levels). missing, recover_data used attempt reconstruct data. See note recover_data important precaution. df Numeric value. equivalent specifying options(df = df). See update.emmGrid. type Character value. provided, saved \"predict.type\" setting. See update.emmGrid section prediction types transformations. regrid Character, logical, list. non-missing, reference grid reconstructed via regrid argument transform = regrid. See section prediction types transformations. Note: argument named transform version 1.7.2 earlier. compatibility old code, transform still accepted found among ...,  long match tran. nesting model nested fixed effects, may specified via character vector named list specifying nesting structure. Specifying nesting overrides nesting structure automatically detected. See section Recovering Overriding  Model Information. offset Numeric scalar value (vector, first element used). may used add offset, override offsets based model. common usage specify offset = 0 Poisson regression model, predictions reference grid become rates relative offset specified model. sigma Numeric value use subsequent predictions back-transformation bias adjustments. specified, use sigma(object), available, NULL otherwise. Note: applies family \"gaussian\"; families, sigma set NA overridden. counterfactuals, wt.counter, avg.counter counterfactuals specifies character names counterfactual factors. non-missing, reference grid created consisting combinations counterfactual levels constructed factor .obs.. level observation dataset. default, grid re-gridded response transformation averaged .obs.. (default, equal weights, vector weights may specified wt.counter; must length equal number observations dataset). avg.counter set FALSE, averaging disabled. See section counterfactuals. nuisance, non.nuisance, wt.nuis nuisance vector predictor names, predictors omitted reference grid. Instead, result  averaged levels factors, either  equal proportional weights specified wt.nuis (see  weights argument emmeans). factors  nuisance must interact factors, even nuisance factors. Specifying nuisance factors can save considerable storage computation time, help avoid exceeding maximum reference-grid size (get_emm_option(\"rg.limit\")). rg.limit Integer limit number reference-grid rows allow (checked multivariate responses included). ... Optional arguments passed summary.emmGrid, emm_basis, recover_data, params, vcov. (see Covariance matrix ), options mode specific model types (see vignette(\"models\", \"emmeans\")).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a reference grid from a fitted model — ref_grid","text":"object S4 class \"emmGrid\" (see  emmGrid-class). objects encapsulate everything needed   calculations inferences estimated marginal means, contain   nothing depends model-fitting procedure.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a reference grid from a fitted model — ref_grid","text":"users, ref_grid function important arguments effect arguments emmeans related functions, functions pass ... arguments ref_grid. reference grid consists combinations independent variables predictions made. Estimated marginal means defined predictions, marginal averages thereof. grid determined first reconstructing data used fitting model (see recover_data), using data.frame provided data. default reference grid determined observed levels factors, ordered unique values character-valued predictors, results cov.reduce numeric predictors. may overridden using . See also section recovering/overriding model information.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Create a reference grid from a fitted model — ref_grid","text":"system default cov.keep causes models   containing indicator variables handled differently   emmeans version 1.4.1 earlier. replicate older   analyses, change default via    emm_options(cov.keep = character(0)). earlier versions emmeans offer covnest argument.   now obsolete; covnest specified, harmlessly   ignored. Cases needed now handled appropriately via   code associated cov.keep.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"using-cov-reduce-and-cov-keep","dir":"Reference","previous_headings":"","what":"Using cov.reduce and cov.keep","title":"Create a reference grid from a fitted model — ref_grid","text":"cov.keep argument available emmeans versions   1.4.1 earlier. covariates named list treated   factors: unique levels kept reference grid. user   may also specify integer value, case covariate   number unique values implicitly included cov.keep.   default cov.keep set retrieved via    emm_options framework, system default \"2\",   meaning covariates two unique values automatically   treated two-level factors. See also Note backward compatibility. subtle distinction including covariate cov.keep   specifying values manually : Covariates included    cov.keep treated factors purposes weighting,   specifying levels include covariate weighting.   See mtcars.lm example illustration. cov.reduce may function,   logical value, formula, named list .   single function, applied covariate.   logical TRUE, mean used. logical   FALSE, equivalent including covariates   cov.keep. Use cov.reduce = FALSE inadvisable   can result huge reference grid; far better use   cov.keep. formula (must two-sided), model fitted   formula using lm; reference grid, response   variable set results predict model,   reference grid newdata. (done   reference grid determined.) formula appropriate think   experimental conditions affect covariate well response. allow situations simple lm() call described   adequate, formula form ext ~ fcnname also supported,   left-hand side may ext, extern,   external (must predictor name)   right-hand side name existing function. function called   one argument, data frame columns variable   reference grid. function expected use frame new data   used obtain predictions one models; return   named list data frame replacement values one   covariates. cov.reduce named list, criteria used   determine covariates named list. (However, formula   elements need named, names determined   formulas' left-hand sides.) unresolved covariates reduced using   \"mean\". cov.reduce cov.keep specification covariate    also named ignored.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"interdependent-covariates","dir":"Reference","previous_headings":"","what":"Interdependent covariates","title":"Create a reference grid from a fitted model — ref_grid","text":"Care must taken covariate values   depend one another. example, polynomial model fitted   using predictors x, x2 (equal x^2), x3   (equal x^3), reference grid default set x2   x3 means, inconsistent. user instead   use argument set square cube   mean(x). Better yet, fit model using formula involving   poly(x, 3) (x^2) (x^3);   x appearing covariate; set mean,   model matrix correct corresponding quadratic cubic terms.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"matrix-covariates","dir":"Reference","previous_headings":"","what":"Matrix covariates","title":"Create a reference grid from a fitted model — ref_grid","text":"Support covariates appear dataset   matrices limited. matrix one column,   treated like ordinary covariate. Otherwise, one column,   column reduced single reference value -- result   applying cov.reduce column (averaged together   produces one value); may specify values ;   treated variables reference grid, except   purposes obtaining predictions.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"recovering-or-overriding-model-information","dir":"Reference","previous_headings":"","what":"Recovering or overriding model information","title":"Create a reference grid from a fitted model — ref_grid","text":"Ability support   particular class object depends existence   recover_data emm_basis methods -- see   extending-emmeans details. call   methods(\"recover_data\") help identify . Data. certain models, (e.g., results   glmer.nb), possible identify original   dataset. cases, can work around setting data   equal dataset used fitting model, suitable subset.   complete cases data used, may necessary   exclude unused variables. Using data can also help save   computing, especially dataset large. case, data   must represent factor levels used fitting model.   used alternative . (Note:   pattern NAs caused one factor levels excluded   fitting model, data also exclude levels.) Covariance matrix. default, variance-covariance matrix   fixed effects obtained object, usually via   vcov method. However, user may override via   vcov. argument, specifying matrix function. matrix,   must square dimension parameter order fixed   effects. function, must return suitable matrix called   arguments (object, ...). careful possible    unintended conflicts arguments ...; example,    sandwich::vcovHAC() optional arguments adjust weights   may intended emmeans() also passed vcov.(). Nested factors. nesting structure affects marginal   averaging emmeans done separately level   (combination thereof) grouping factors. ref_grid tries   discern factors nested factors, always   obvious, misses , user must specify structure via   nesting; later using update.emmGrid.   nesting argument may character vector, named list,    NULL.   list, name name single factor   grid, entry character vector name(s) grouping   factor(s). nested may also character value form   \"factor1 %% (factor2*factor3)\" (parentheses optional).   one specification, may appended   separated commas, separate elements character vector.   example, specifications equivalent: nesting = list(state =   \"country\", city = c(\"state\", \"country\"), nesting = \"state %%   country, city %% (state*country)\", nesting = c(\"state %%   country\", \"city %% state*country\").","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"predictors-with-subscripts-and-data-set-references","dir":"Reference","previous_headings":"","what":"Predictors with subscripts and data-set references","title":"Create a reference grid from a fitted model — ref_grid","text":"fitted   model contains subscripts explicit references data sets,   reference grid may optionally post-processed simplify variable   names, depending simplify.names option (see   emm_options), default TRUE. example,   model formula data1$resp ~ data1$trt + data2[[3]] +   data2[[\"cov\"]], simplified predictor names (use, e.g.,   specs emmeans) trt,   data2[[3]], cov. Numerical subscripts simplified;   variables simplified names coincide,   data2$trt also model. Please note simplification performed   reference grid constructed. Thus, non-simplified names must used   argument (e.g., = list(`data2[\"cov\"]` = 2:4). want names simplified, use emm_options(simplify.names =   FALSE).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"prediction-types-and-transformations","dir":"Reference","previous_headings":"","what":"Prediction types and transformations","title":"Create a reference grid from a fitted model — ref_grid","text":"Transformations can exist link function generalized linear model,    response transformation, even . many cases, auto-detected,   example model formula form sqrt(y) ~ .... Even transformations   containing multiplicative additive constants, 2*sqrt(y + pi) ~ ...,   auto-detected. response transformation y + 1 ~ ...   auto-detected, (y + 1) ~ ... interpreted identity(y + 1) ~ ....   warning issued gets complicated.   Complex transformations like Box-Cox transformation auto-detected; see    help page make.tran information advanced methods. subtle difference   specifying type = \"response\" regrid =   \"response\". summary statistics grid ,   subsequent use emmeans yield different results   response transformation link function. type =   \"response\", EMMs computed averaging together predictions   linear-predictor scale back-transforming response   scale; regrid = \"response\", predictions   already response scale EMMs arithmetic means   response-scale predictions. add possibilities,   geometric means response-scale predictions obtainable via   regrid = \"log\", type = \"response\". See also help page    regrid. Order--processing issues:    regrid argument, present, acted immediately reference    grid constructed, ... arguments may used   update object end. Thus, code like   ref_grid(mod, tran = \"sqrt\", regrid = \"response\") work correctly   intention specify response transformation, re-grid    done processes tran = \"sqrt\". get intended   result,   regrid(ref_grid(mod, tran = \"sqrt\"), transform = \"response\").","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"counterfactuals","dir":"Reference","previous_headings":"","what":"Counterfactuals","title":"Create a reference grid from a fitted model — ref_grid","text":"counterfactuals specified, rows entire dataset   become factor reference grid, reference levels   confined named counterfactuals. type analysis   (called G-computation), substitute combination counterfactual   levels entire dataset. Thus, predictions grid   observation counterfactual levels.   make sense, require assumption exchangeability levels. default, grid converted response scale (unless otherwise   specified regrid) averaged observations dataset.   Averaging can disabled setting avg.counter = FALSE,   warned resulting reference grid potentially huge --   number observations dataset times number counterfactual    combinations, times number multivariate levels. counterfactuals code still fairly rudimentary guarantee   always work, cases nested models. Sometimes, error   can averted specifying avg.counter = FALSE.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"optional-side-effect","dir":"Reference","previous_headings":"","what":"Optional side effect","title":"Create a reference grid from a fitted model — ref_grid","text":"save.ref_grid option set   TRUE (see emm_options),   recent result ref_grid, whether   called directly indirectly via emmeans,   emtrends, function calls one ,   saved user's environment .Last.ref_grid. facilitates   checking reference grid used, reusing reference grid   calculations. automatic saving disabled default,   may enabled via emm_options(save.ref_grid = TRUE).","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/ref_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a reference grid from a fitted model — ref_grid","text":"","code":"fiber.lm <- lm(strength ~ machine*diameter, data = fiber) ref_grid(fiber.lm) #>  machine diameter prediction    SE df #>  A           24.1       40.2 0.777  9 #>  B           24.1       41.6 0.858  9 #>  C           24.1       38.5 0.966  9 #>   ref_grid(fiber.lm, at = list(diameter = c(15, 25))) #>  machine diameter prediction    SE df #>  A             15       30.1 2.113  9 #>  B             15       33.8 2.573  9 #>  C             15       30.6 1.492  9 #>  A             25       41.2 0.750  9 #>  B             25       42.3 0.782  9 #>  C             25       39.3 1.089  9 #>   if (FALSE) { # We could substitute the sandwich estimator vcovHAC(fiber.lm) # as follows: summary(ref_grid(fiber.lm, vcov. = sandwich::vcovHAC)) }  # If we thought that the machines affect the diameters # (admittedly not plausible in this example), then we should use: ref_grid(fiber.lm, cov.reduce = diameter ~ machine) #>  machine diameter prediction    SE df #>  A           25.2       41.4 0.749  9 #>  B           26.0       43.2 0.749  9 #>  C           21.2       36.0 0.749  9 #>   ### Model with indicator variables as predictors: mtcars.lm <- lm(mpg ~ disp + wt + vs * am, data = mtcars) (rg.default <- ref_grid(mtcars.lm)) #>  disp   wt vs am prediction   SE df #>   231 3.22  0  0       19.1 1.26 26 #>   231 3.22  1  0       20.0 1.18 26 #>   231 3.22  0  1       18.4 1.14 26 #>   231 3.22  1  1       23.3 1.54 26 #>  (rg.nokeep <- ref_grid(mtcars.lm, cov.keep = character(0))) #>  disp   wt    vs    am prediction    SE df #>   231 3.22 0.438 0.406       19.9 0.484 26 #>  (rg.at <- ref_grid(mtcars.lm, at = list(vs = 0:1, am = 0:1))) #>  disp   wt vs am prediction   SE df #>   231 3.22  0  0       19.1 1.26 26 #>   231 3.22  1  0       20.0 1.18 26 #>   231 3.22  0  1       18.4 1.14 26 #>   231 3.22  1  1       23.3 1.54 26 #>   # Two of these have the same grid but different weights: rg.default@grid #>       disp      wt vs am .wgt. #> 1 230.7219 3.21725  0  0    12 #> 2 230.7219 3.21725  1  0     7 #> 3 230.7219 3.21725  0  1     6 #> 4 230.7219 3.21725  1  1     7 rg.at@grid #>       disp      wt vs am .wgt. #> 1 230.7219 3.21725  0  0     1 #> 2 230.7219 3.21725  1  0     1 #> 3 230.7219 3.21725  0  1     1 #> 4 230.7219 3.21725  1  1     1  ### Using cov.reduce formulas... # Above suggests we can vary disp indep. of other factors - unrealistic rg.alt <- ref_grid(mtcars.lm, at = list(wt = c(2.5, 3, 3.5)),     cov.reduce = disp ~ vs * wt) rg.alt@grid #>        disp  wt vs am .wgt. #> 1  185.6376 2.5  0  0    12 #> 2  236.7553 3.0  0  0    12 #> 3  287.8730 3.5  0  0    12 #> 4  125.1602 2.5  1  0     7 #> 5  157.9451 3.0  1  0     7 #> 6  190.7300 3.5  1  0     7 #> 7  185.6376 2.5  0  1     6 #> 8  236.7553 3.0  0  1     6 #> 9  287.8730 3.5  0  1     6 #> 10 125.1602 2.5  1  1     7 #> 11 157.9451 3.0  1  1     7 #> 12 190.7300 3.5  1  1     7  # Alternative to above where we model sqrt(disp) disp.mod <- lm(sqrt(disp) ~ vs * wt, data = mtcars) disp.fun <- function(dat)     list(disp = predict(disp.mod, newdata = dat)^2) rg.alt2 <- ref_grid(mtcars.lm, at = list(wt = c(2.5, 3, 3.5)),     cov.reduce = external ~ disp.fun) #> Error in get(as.character(dep.x[[xnm]][[3]]), inherits = TRUE): object 'disp.fun' not found rg.alt2@grid #> Error in eval(expr, envir, enclos): object 'rg.alt2' not found   # Multivariate example MOats.lm = lm(yield ~ Block + Variety, data = MOats) ref_grid(MOats.lm, mult.names = \"nitro\") #>  Block Variety     nitro prediction    SE df #>  VI    Golden Rain 0           80.3  9.05 10 #>  V     Golden Rain 0           68.9  9.05 10 #>  III   Golden Rain 0           72.9  9.05 10 #>  IV    Golden Rain 0           69.9  9.05 10 #>  II    Golden Rain 0           76.3  9.05 10 #>  I     Golden Rain 0          111.6  9.05 10 #>  VI    Marvellous  0           86.9  9.05 10 #>  V     Marvellous  0           75.6  9.05 10 #>  III   Marvellous  0           79.6  9.05 10 #>  IV    Marvellous  0           76.6  9.05 10 #>  II    Marvellous  0           82.9  9.05 10 #>  I     Marvellous  0          118.3  9.05 10 #>  VI    Victory     0           71.8  9.05 10 #>  V     Victory     0           60.4  9.05 10 #>  III   Victory     0           64.4  9.05 10 #>  IV    Victory     0           61.4  9.05 10 #>  II    Victory     0           67.8  9.05 10 #>  I     Victory     0          103.1  9.05 10 #>  VI    Golden Rain 0.2         84.6 10.78 10 #>  V     Golden Rain 0.2         80.3 10.78 10 #>  III   Golden Rain 0.2         97.9 10.78 10 #>  IV    Golden Rain 0.2         93.3 10.78 10 #>  II    Golden Rain 0.2        107.3 10.78 10 #>  I     Golden Rain 0.2        127.6 10.78 10 #>  VI    Marvellous  0.2         94.6 10.78 10 #>  V     Marvellous  0.2         90.3 10.78 10 #>  III   Marvellous  0.2        107.9 10.78 10 #>  IV    Marvellous  0.2        103.3 10.78 10 #>  II    Marvellous  0.2        117.3 10.78 10 #>  I     Marvellous  0.2        137.6 10.78 10 #>  VI    Victory     0.2         75.8 10.78 10 #>  V     Victory     0.2         71.4 10.78 10 #>  III   Victory     0.2         89.1 10.78 10 #>  IV    Victory     0.2         84.4 10.78 10 #>  II    Victory     0.2         98.4 10.78 10 #>  I     Victory     0.2        118.8 10.78 10 #>  VI    Golden Rain 0.4        108.1 14.20 10 #>  V     Golden Rain 0.4        101.4 14.20 10 #>  III   Golden Rain 0.4        111.4 14.20 10 #>  IV    Golden Rain 0.4        106.1 14.20 10 #>  II    Golden Rain 0.4        115.1 14.20 10 #>  I     Golden Rain 0.4        145.8 14.20 10 #>  VI    Marvellous  0.4        110.6 14.20 10 #>  V     Marvellous  0.4        103.9 14.20 10 #>  III   Marvellous  0.4        113.9 14.20 10 #>  IV    Marvellous  0.4        108.6 14.20 10 #>  II    Marvellous  0.4        117.6 14.20 10 #>  I     Marvellous  0.4        148.3 14.20 10 #>  VI    Victory     0.4        104.3 14.20 10 #>  V     Victory     0.4         97.6 14.20 10 #>  III   Victory     0.4        107.6 14.20 10 #>  IV    Victory     0.4        102.3 14.20 10 #>  II    Victory     0.4        111.3 14.20 10 #>  I     Victory     0.4        141.9 14.20 10 #>  VI    Golden Rain 0.6        114.1 11.93 10 #>  V     Golden Rain 0.6        115.1 11.93 10 #>  III   Golden Rain 0.6        103.4 11.93 10 #>  IV    Golden Rain 0.6        125.4 11.93 10 #>  II    Golden Rain 0.6        132.4 11.93 10 #>  I     Golden Rain 0.6        158.4 11.93 10 #>  VI    Marvellous  0.6        116.1 11.93 10 #>  V     Marvellous  0.6        117.1 11.93 10 #>  III   Marvellous  0.6        105.4 11.93 10 #>  IV    Marvellous  0.6        127.4 11.93 10 #>  II    Marvellous  0.6        134.4 11.93 10 #>  I     Marvellous  0.6        160.4 11.93 10 #>  VI    Victory     0.6        107.8 11.93 10 #>  V     Victory     0.6        108.8 11.93 10 #>  III   Victory     0.6         97.1 11.93 10 #>  IV    Victory     0.6        119.1 11.93 10 #>  II    Victory     0.6        126.1 11.93 10 #>  I     Victory     0.6        152.1 11.93 10 #>  # Silly illustration of how to use 'mult.levs' to make comb's of two factors ref_grid(MOats.lm, mult.levs = list(T=LETTERS[1:2], U=letters[1:2])) #>  Block Variety     T U prediction    SE df #>  VI    Golden Rain A a       80.3  9.05 10 #>  V     Golden Rain A a       68.9  9.05 10 #>  III   Golden Rain A a       72.9  9.05 10 #>  IV    Golden Rain A a       69.9  9.05 10 #>  II    Golden Rain A a       76.3  9.05 10 #>  I     Golden Rain A a      111.6  9.05 10 #>  VI    Marvellous  A a       86.9  9.05 10 #>  V     Marvellous  A a       75.6  9.05 10 #>  III   Marvellous  A a       79.6  9.05 10 #>  IV    Marvellous  A a       76.6  9.05 10 #>  II    Marvellous  A a       82.9  9.05 10 #>  I     Marvellous  A a      118.3  9.05 10 #>  VI    Victory     A a       71.8  9.05 10 #>  V     Victory     A a       60.4  9.05 10 #>  III   Victory     A a       64.4  9.05 10 #>  IV    Victory     A a       61.4  9.05 10 #>  II    Victory     A a       67.8  9.05 10 #>  I     Victory     A a      103.1  9.05 10 #>  VI    Golden Rain B a       84.6 10.78 10 #>  V     Golden Rain B a       80.3 10.78 10 #>  III   Golden Rain B a       97.9 10.78 10 #>  IV    Golden Rain B a       93.3 10.78 10 #>  II    Golden Rain B a      107.3 10.78 10 #>  I     Golden Rain B a      127.6 10.78 10 #>  VI    Marvellous  B a       94.6 10.78 10 #>  V     Marvellous  B a       90.3 10.78 10 #>  III   Marvellous  B a      107.9 10.78 10 #>  IV    Marvellous  B a      103.3 10.78 10 #>  II    Marvellous  B a      117.3 10.78 10 #>  I     Marvellous  B a      137.6 10.78 10 #>  VI    Victory     B a       75.8 10.78 10 #>  V     Victory     B a       71.4 10.78 10 #>  III   Victory     B a       89.1 10.78 10 #>  IV    Victory     B a       84.4 10.78 10 #>  II    Victory     B a       98.4 10.78 10 #>  I     Victory     B a      118.8 10.78 10 #>  VI    Golden Rain A b      108.1 14.20 10 #>  V     Golden Rain A b      101.4 14.20 10 #>  III   Golden Rain A b      111.4 14.20 10 #>  IV    Golden Rain A b      106.1 14.20 10 #>  II    Golden Rain A b      115.1 14.20 10 #>  I     Golden Rain A b      145.8 14.20 10 #>  VI    Marvellous  A b      110.6 14.20 10 #>  V     Marvellous  A b      103.9 14.20 10 #>  III   Marvellous  A b      113.9 14.20 10 #>  IV    Marvellous  A b      108.6 14.20 10 #>  II    Marvellous  A b      117.6 14.20 10 #>  I     Marvellous  A b      148.3 14.20 10 #>  VI    Victory     A b      104.3 14.20 10 #>  V     Victory     A b       97.6 14.20 10 #>  III   Victory     A b      107.6 14.20 10 #>  IV    Victory     A b      102.3 14.20 10 #>  II    Victory     A b      111.3 14.20 10 #>  I     Victory     A b      141.9 14.20 10 #>  VI    Golden Rain B b      114.1 11.93 10 #>  V     Golden Rain B b      115.1 11.93 10 #>  III   Golden Rain B b      103.4 11.93 10 #>  IV    Golden Rain B b      125.4 11.93 10 #>  II    Golden Rain B b      132.4 11.93 10 #>  I     Golden Rain B b      158.4 11.93 10 #>  VI    Marvellous  B b      116.1 11.93 10 #>  V     Marvellous  B b      117.1 11.93 10 #>  III   Marvellous  B b      105.4 11.93 10 #>  IV    Marvellous  B b      127.4 11.93 10 #>  II    Marvellous  B b      134.4 11.93 10 #>  I     Marvellous  B b      160.4 11.93 10 #>  VI    Victory     B b      107.8 11.93 10 #>  V     Victory     B b      108.8 11.93 10 #>  III   Victory     B b       97.1 11.93 10 #>  IV    Victory     B b      119.1 11.93 10 #>  II    Victory     B b      126.1 11.93 10 #>  I     Victory     B b      152.1 11.93 10 #>   # Comparing estimates with and without counterfactuals neuralgia.glm <- glm(Pain ~ Treatment + Sex + Age + Duration,                       family = binomial(), data = neuralgia) emmeans(neuralgia.glm, \"Treatment\", type = \"response\") #>  Treatment  prob     SE  df asymp.LCL asymp.UCL #>  A         0.196 0.1055 Inf    0.0617     0.475 #>  B         0.126 0.0822 Inf    0.0323     0.384 #>  P         0.855 0.0852 Inf    0.6053     0.958 #>  #> Results are averaged over the levels of: Sex  #> Confidence level used: 0.95  #> Intervals are back-transformed from the logit scale   emmeans(neuralgia.glm, \"Treatment\", counterfactuals = \"Treatment\") #>  Treatment  prob     SE  df asymp.LCL asymp.UCL #>  A         0.283 0.0811 Inf    0.1243     0.442 #>  B         0.221 0.0710 Inf    0.0813     0.360 #>  P         0.754 0.0814 Inf    0.5944     0.914 #>  #> Results are averaged over the levels of: .obs.no.  #> Confidence level used: 0.95    # Using 'params' require(\"splines\") #> Loading required package: splines my.knots = c(2.5, 3, 3.5) mod = lm(Sepal.Length ~ Species * ns(Sepal.Width, knots = my.knots), data = iris) ## my.knots is not a predictor, so need to name it in 'params' ref_grid(mod, params = \"my.knots\")  #>  Species    Sepal.Width prediction     SE  df #>  setosa            3.06       4.71 0.1098 135 #>  versicolor        3.06       6.30 0.1074 135 #>  virginica         3.06       6.73 0.0909 135 #>"},{"path":"https://rvlenth.github.io/emmeans/reference/regrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconstruct a reference grid with a new transformation or simulations — regrid","title":"Reconstruct a reference grid with a new transformation or simulations — regrid","text":"typical use function cause EMMs computed different scale, e.g., back-transformed scale rather  linear-predictor scale. words, want back-transformed  results, want average back-transform,  back-transform average?","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/regrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconstruct a reference grid with a new transformation or simulations — regrid","text":"","code":"regrid(object, transform = c(\"response\", \"mu\", \"unlink\", \"none\", \"pass\",   links), inv.link.lbl = \"response\", predict.type,   bias.adjust = get_emm_option(\"back.bias.adj\"), sigma, N.sim,   sim = mvtnorm::rmvnorm, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/regrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconstruct a reference grid with a new transformation or simulations — regrid","text":"object object class emmGrid transform Character, list, logical value. \"response\", \"mu\", TRUE, inverse transformation applied estimates grid (link function response transformation, \"mu\" back-transforms link part); \"none\" FALSE, object re-gridded bhat slot contains predict(object) linfct slot identity. internal transformation information preserved. transform = \"pass\", object re-gridded way (may useful conjunction N.sim). transform character value links (set valid arguments make.link function, excepting \"identity\"), transform list form returned make.links make.tran, results formulated response transformed link function. inv.link.lbl Character value. applies transform  links, used label predictions subsequently summarized type = \"response\". predict.type Character value. provided, returned object updated given type use default summary.emmGrid (see update.emmGrid).  may useful , example, one specifies transform = \"log\" desires summaries produced default response scale. bias.adjust Logical value whether adjust bias back-transforming (transform = \"response\"). requires valid value  sigma exist object specified. sigma Error SD assumed bias correction ( transform = \"response\" transformation effect). specified, object@misc$sigma used, warning issued found. N.sim Integer value. specified object based  frequentist model (.e., posterior sample), fake  posterior sample generated using function sim. sim function three arguments (names assumed). N.sim supplied frequentist model, function called respective arguments N.sim, object@bhat, object@V. default multivariate normal distribution. ... Ignored.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/regrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconstruct a reference grid with a new transformation or simulations — regrid","text":"emmGrid object requested changes","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/regrid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reconstruct a reference grid with a new transformation or simulations — regrid","text":"regrid function reparameterizes existing ref.grid linfct slot identity matrix bhat slot consists estimates grid points. transform TRUE, inverse transform applied estimates. Outwardly, transform = \"response\", result summary.emmGrid applying regrid identical summary original object using type=\"response\". subsequent EMMs contrasts conducted new scale -- reason function exists. function may also used simulate sample regression coefficients frequentist model subsequent use though Bayesian model. , specify value N.sim sample simulated using function sim. grid may processed accordance arguments; transform = \"pass\", simply returned change addition simulated sample.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/regrid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Reconstruct a reference grid with a new transformation or simulations — regrid","text":"Another way use regrid supply regrid    argument ref_grid (either directly indirectly via   emmeans), case value passed regrid   transform. often simpler approach reference   grid already constructed.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/regrid.html","id":"degrees-of-freedom","dir":"Reference","previous_headings":"","what":"Degrees of freedom","title":"Reconstruct a reference grid with a new transformation or simulations — regrid","text":"cases degrees freedom depended linear function estimated (e.g., Satterthwaite method), d.f. reference grid saved, kind “containment” method substituted returned object, whereby calculated d.f. new linear function minimum d.f. among nonzero coefficients. kind ad hoc method, can -estimate degrees freedom cases. annotation displayed subsequent summary results stating  degrees--freedom method inherited previous method time re-gridding.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/regrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reconstruct a reference grid with a new transformation or simulations — regrid","text":"","code":"pigs.lm <- lm(log(conc) ~ source + factor(percent), data = pigs) rg <- ref_grid(pigs.lm)  # This will yield EMMs as GEOMETRIC means of concentrations: (emm1 <- emmeans(rg, \"source\", type = \"response\")) #>  source response   SE df lower.CL upper.CL #>  fish       29.8 1.09 23     27.6     32.1 #>  soy        39.1 1.47 23     36.2     42.3 #>  skim       44.6 1.75 23     41.1     48.3 #>  #> Results are averaged over the levels of: percent  #> Confidence level used: 0.95  #> Intervals are back-transformed from the log scale  pairs(emm1) ## We obtain RATIOS #>  contrast    ratio     SE df null t.ratio p.value #>  fish / soy  0.761 0.0403 23    1  -5.153  0.0001 #>  fish / skim 0.669 0.0362 23    1  -7.428  <.0001 #>  soy / skim  0.879 0.0466 23    1  -2.442  0.0570 #>  #> Results are averaged over the levels of: percent  #> P value adjustment: tukey method for comparing a family of 3 estimates  #> Tests are performed on the log scale   # This will yield EMMs as ARITHMETIC means of concentrations: (emm2 <- emmeans(regrid(rg, transform = \"response\"), \"source\")) #>  source response   SE df lower.CL upper.CL #>  fish       30.0 1.10 23     27.7     32.2 #>  soy        39.4 1.49 23     36.3     42.5 #>  skim       44.8 1.79 23     41.1     48.5 #>  #> Results are averaged over the levels of: percent  #> Confidence level used: 0.95  pairs(emm2)  ## We obtain DIFFERENCES #>  contrast    estimate   SE df t.ratio p.value #>  fish - soy     -9.40 1.86 23  -5.051  0.0001 #>  fish - skim   -14.84 2.10 23  -7.071  <.0001 #>  soy - skim     -5.44 2.25 23  -2.424  0.0591 #>  #> Results are averaged over the levels of: percent  #> P value adjustment: tukey method for comparing a family of 3 estimates  # Same result, useful if we hadn't already created 'rg' # emm2 <- emmeans(pigs.lm, \"source\", regrid = \"response\")  # Simulate a sample of regression coefficients set.seed(2.71828) rgb <- regrid(rg, N.sim = 200, transform = \"pass\") #> Simulating a sample of size 200 of regression coefficients. emmeans(rgb, \"source\", type = \"response\")  ## similar to emm1 #>  source response lower.HPD upper.HPD #>  fish       29.8      27.7      31.9 #>  soy        39.3      36.5      41.8 #>  skim       44.7      41.7      48.3 #>  #> Results are averaged over the levels of: percent  #> Point estimate displayed: median  #> Results are back-transformed from the log scale  #> HPD interval probability: 0.95"},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"primary methods obtaining numerical tabular results emmGrid object. summary.emmGrid general function summarizing emmGrid objects. also serves print method objects; convenience, summary() arguments may included calls functions emmeans contrast construct emmGrid objects. Note default, summaries Bayesian models diverted hpd.summary.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"","code":"# S3 method for emmGrid summary(object, infer, level, adjust, by,   cross.adjust = \"none\", type, df, calc, null, delta, side, frequentist,   bias.adjust = get_emm_option(\"back.bias.adj\"), sigma, ...)  # S3 method for emmGrid confint(object, parm, level = 0.95, ...)  test(object, null, ...)  # S3 method for emmGrid test(object, null = 0, joint = FALSE, verbose = FALSE,   rows, by, status = FALSE, ...)  # S3 method for emmGrid predict(object, type, interval = c(\"none\", \"confidence\",   \"prediction\"), level = 0.95,   bias.adjust = get_emm_option(\"back.bias.adj\"), sigma, ...)  # S3 method for emmGrid as.data.frame(x, row.names = NULL, optional,   check.names = TRUE, destroy.annotations = FALSE, ...)  # S3 method for summary_emm [(x, ..., as.df = FALSE)"},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"object object class \"emmGrid\" (see emmGrid-class) infer vector one two logical values. first determines whether confidence intervals displayed, second determines whether t tests P values displayed. one value provided, used . level Numerical value 0 1. Confidence level confidence intervals, infer[1] TRUE. adjust Character value naming method used adjust \\(p\\) values confidence limits; adjust comparison arrows plot. See P-value adjustments section . Character name(s) variables use grouping separate  tables. affects family tests considered adjusted P values. cross.adjust Character: \\(p\\)-value adjustment method  additionally apply across  groups. See section P-value adjustments details. type Character: type prediction desired. effect known transformation link function. \"response\"  specifies inverse transformation applied. \"mu\" ( equivalently, \"unlink\") usually \"response\", case model link function response  transformation, link part back-transformed. valid values  \"link\", \"lp\", \"linear.predictor\"; equivalent, request results shown linear predictor, back-transformation. default \"link\", unless  \"predict.type\" option force; see emm_options, also section transformations links. df Numeric. non-missing, constant number degrees freedom use constructing confidence intervals P values (NA specifies asymptotic results). calc Named list character value(s) formula(s). expressions char evaluated appended summary, just df column. expression may include names df summary, additional names  object@grid (.wgt. .offset.), earlier elements calc. null Numeric. Null hypothesis value(s), linear-predictor scale, estimates tested. May single value used , numeric vector length equal number tests family (.e., group displayed table). delta Numeric value (linear-predictor scale). zero, ordinary tests significance performed. positive, specifies threshold testing equivalence (using TOST two-one-sided-test method), non-inferiority, non-superiority, depending side. See Details test statistics defined. side Numeric character value specifying whether test left-tailed (-1, \"-\", \"<\", \"left\", \"nonsuperiority\"); right-tailed (1, \"+\", \">\", \"right\", \"noninferiority\"); two-sided (0, 2, \"!=\", \"two-sided\", \"\", \"equivalence\", \"=\"). See special section details. frequentist Ignored except Bayesian model fitted. missing FALSE, object passed hpd.summary. Otherwise,  logical value TRUE return frequentist summary. bias.adjust Logical value whether adjust bias back-transforming (type = \"response\"). requires valid value  sigma exist object specified. sigma Error SD assumed bias correction ( type = \"response\" transformation effect), constructing prediction intervals. specified, object@misc$sigma used, warning issued found valid. Note: sigma may vector, careful correctly corresponds (perhaps recycling) order reference grid. ... Optional arguments scheffe.rank  (see “P-value adjustments”).  confint.emmGrid,  predict.emmGrid,  test.emmGrid, arguments passed summary.emmGrid. parm (Required argument confint methods, used) joint Logical value. FALSE, arguments passed  summary.emmGrid infer=c(FALSE, TRUE). joint =  TRUE, joint test hypothesis L beta = null performed, L  object@linfct beta vector fixed effects estimated  object@betahat. either F test  chi-square (Wald) test depending whether degrees freedom  available. See also joint_tests. verbose Logical value. TRUE joint = TRUE, table effects tested printed. rows Integer values. rows L tested joint test. missing, rows L used. missing, variables ignored. status logical. TRUE, note column showing status flags (rank deficiencies estimability issues) displayed even  empty. FALSE, column included  issues. interval Type interval desired (partial matching allowed):  \"none\" intervals,   otherwise confidence prediction intervals given arguments,    via confint.emmGrid.    Note: prediction intervals available   unless model family \"gaussian\". x object given class row.names passed .data.frame optional required argument, ignored .data.frame.emmGrid check.names passed data.frame destroy.annotations Logical value. FALSE, object class summary_emm returned (inherits data.frame), displayed, details like confidence levels, P-value adjustments,  transformations, etc. also shown. unlike result summary, number digits displayed obtained getOption(\"digits\") rather using optimal digits algorithm usually use. Thus, formatted like  regular data frame, annotations groupings still intact. TRUE (recommended), “plain vanilla” data frame  returned, based row.names check.names. .df Logical value. x[..., .df = TRUE], result object coerced data.frame subscripting  applied. .df = FALSE, result returned summary_emm object possible.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"summary.emmGrid, confint.emmGrid,  test.emmGrid return object class \"summary_emm\",   extension data.frame special print method displays custom formatting. models fitted using   MCMC methods, call diverted hpd.summary ( prob set level, specified); one may   alternatively use general MCMC summarization tools    results .mcmc. predict returns vector predictions row object@grid. .data.frame method returns object inherits    \"data.frame\".","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"confint.emmGrid equivalent summary.emmGrid  infer = c(TRUE, FALSE). function test.emmGrid, called  joint = FALSE, equivalent summary.emmGrid infer = c(FALSE, TRUE). joint = TRUE, test.emmGrid calculates Wald test hypothesis linfct %*% bhat = null, linfct bhat refer slots object (possibly subsetted according rows). error thrown row linfct non-estimable. permissible rows linfct linearly dependent, long null == 0, case reduced set  contrasts tested. Linear dependence nonzero null cause  error. returned object additional \"est.fcns\" attribute, list linear functions associated joint test.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"testing transformation /link force,   null /delta values specified must always   scale linear predictor, regardless setting `type`.   type = \"response\", null value displayed summary table    back-transformed value supplied user.   displayed delta changed, (often)   natural way back-transform . type = \"response\", bias.adj = TRUE,   null value displayed output back-transformed   bias-adjusted, leading rather non-intuitive-looking null value.   However, since tests performed link scale,   response value *P* value 1 obtained. default show method emmGrid objects (  exception newly created reference grids) print(summary()).   Thus, ordinary usage emmeans ,   unnecessary call summary unless need   specify default options. data frame needed, summary, confint,   test serve need. .data.frame routes   summary default; calling destroy.annotations = TRUE   recommended exactly reason.   want see digits output, use   print(summary(object), digits = ...); always want   see digits, use emm_options(opt.digits = FALSE).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"defaults","dir":"Reference","previous_headings":"","what":"Defaults","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"misc slot object may contain default values   , calc, infer, level, adjust,    type, null, side, delta.    defaults vary depending   code created object. update method may   used change defaults. addition, options set using    emm_options(summary = ...) trump stored object's    misc slot.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"transformations-and-links","dir":"Reference","previous_headings":"","what":"Transformations and links","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"type = \"response\", transformation assumed can found   object@misc$tran, label, summary   object@misc$inv.lbl. \\(t\\) \\(z\\) tests still performed   scale linear predictor, inverse-transformed one.   Similarly, confidence intervals computed linear-predictor scale,   inverse-transformed.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"bias-adjustment-when-back-transforming","dir":"Reference","previous_headings":"","what":"Bias adjustment when back-transforming","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"bias.adjust TRUE, back-transformed estimates   adjusted adding    \\(0.5 h''(u)\\sigma^2\\), \\(h\\) inverse transformation   \\(u\\) linear predictor. based second-order Taylor   expansion. better exact adjustments certain specific   cases, may incorporated future updates. Note: certain models, e.g., non-gaussian families,   sigma initialized NA, default, bias adjustment   skipped warning issued. may override specifying   value sigma. However, ordinary generalized linear models,   bias adjustment inappropriate try . GEEs GLMMs,   probably use sigma(model), instead create   appropriate value using estimated random effects, e.g., VarCorr(model).   example provided “transformations” vignette.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"p-value-adjustments","dir":"Reference","previous_headings":"","what":"P-value adjustments","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"adjust argument specifies multiplicity adjustment tests   confidence intervals. adjustment always applied separately   table sub-table see printed output (see   rbind.emmGrid combine tables). non-estimable   cases group, cases excluded determining   adjustment; means different adjustments different groups. valid values adjust follows: \"tukey\" Uses Studentized range distribution number     means family. (Available two-sided cases .) \"scheffe\" Computes \\(p\\) values \\(F\\)     distribution, according Scheffe critical value     \\(\\sqrt{rF(\\alpha; r, d)}\\), \\(d\\)     error degrees freedom \\(r\\) rank set linear     functions consideration. default, value r     computed object@linfct group; however,     user specifies argument matching scheffe.rank, value     used instead. Ordinarily, \\(k\\) means involved,     \\(r = k - 1\\) full set contrasts involving \\(k\\) means,     \\(r = k\\) means . (Scheffe adjustment available     two-sided cases .) \"sidak\" Makes adjustments estimates independent     (conservative adjustment many cases). \"bonferroni\" Multiplies \\(p\\) values, divides significance     levels number estimates. conservative adjustment. \"dunnettx\" Uses ownad hoc approximation      Dunnett distribution family estimates pairwise     correlations \\(0.5\\) (true comparing treatments     control equal sample sizes). accuracy approximation     improves number simultaneous estimates, much faster     \"mvt\". (Available two-sided cases .) \"mvt\" Uses multivariate \\(t\\) distribution assess     probability critical value maximum \\(k\\) estimates.     method produces \\(p\\) values intervals default     summary confint methods results     .glht. context pairwise comparisons comparisons     control, produces “exact” Tukey Dunnett adjustments,     respectively. However, algorithm (mvtnorm package) uses     Monte Carlo method, results exactly repeatable unless     random-number seed used (see set.seed). family     size increases, required computation time become noticeable even     intolerable, making \"tukey\", \"dunnettx\", others     attractive. \"none\" Makes adjustments \\(p\\) values.  tests, confidence intervals, Bonferroni-inequality-based adjustment   methods p.adjust also available (currently,   include \"holm\", \"hochberg\", \"hommel\",   \"bonferroni\", \"BH\", \"\", \"fdr\",   \"none\"). p.adjust.methods method   \"bonferroni\" \"none\" specified confidence limits,   straight Bonferroni adjustment used instead. Also, adjustment method   appropriate (e.g., using \"tukey\" one-sided tests,   results pairwise comparisons), appropriate method   (usually \"sidak\") substituted. cases, confidence \\(p\\)-value adjustments approximate   -- especially degrees freedom standard errors vary greatly   within family tests. \"mvt\" method always correct   one-step adjustment, can slow. One may use   .glht methods multcomp package obtain   non-conservative multi-step adjustments tests. Warning: Non-estimable cases included family adjustments   applied. may wish subset object using [] operator   work around problem. cross.adjust argument way specifying multiplicity   adjustment across groups (otherwise default, group   treated separate family regards multiplicity adjustments).   applies \\(p\\) values. Valid options one   p.adjust.methods \"sidak\". argument ignored unless   \"none\", one group,   size. conditions, first use   adjust determine within-group adjusted \\(p\\) values.   Imagine group's adjusted \\(p\\) values arranged side--side   columns, thus forming matrix number columns equal   number groups. use cross.adjust method   adjust adjusted \\(p\\) values row matrix. Note   overall Bonferroni (Sidak) adjustment obtainable   specifying adjust cross.adjust   \"bonferroni\" (\"sidak\"). However, less conservative (  yet conservative) overall adjustments available possible   use “exact” within-group method (e.g., adjust = \"tukey\"   pairwise comparisons) cross.adjust conservative   adjustment. [cross.adjust methods \"none\",    \"bonferroni\", \"sidak\" seem advisable,    p.adjust methods available can make sense .]","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"tests-of-significance-nonsuperiority-noninferiority-or-equivalence","dir":"Reference","previous_headings":"","what":"Tests of significance, nonsuperiority, noninferiority, or equivalence","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"delta = 0, test statistics usual tests significance.   form    (estimate - null)/SE. Notationally: Significance \\(H_0: \\theta = \\theta_0\\)  versus         \\(H_1: \\theta < \\theta_0\\) (left-sided),       \\(H_1 \\theta > \\theta_0\\) (right-sided),       \\(H_1: \\theta \\ne \\theta_0\\) (two-sided)       test statistic       \\(t = (Q - \\theta_0)/SE\\)        \\(Q\\) estimate \\(\\theta\\);       left, right, two-sided \\(p\\) values produced,        depending side. delta positive, test statistic depends side   follows. Left-sided (nonsuperiority) \\(H_0: \\theta \\ge \\theta_0 + \\delta\\)     versus \\(H_1: \\theta < \\theta_0 + \\delta\\)      \\(t = (Q - \\theta_0 - \\delta)/SE\\)      \\(p\\) value lower-tail probability. Right-sided (noninferiority) \\(H_0: \\theta \\le \\theta_0 - \\delta\\)     versus \\(H_1: \\theta > \\theta_0 - \\delta\\)      \\(t = (Q - \\theta_0 + \\delta)/SE\\)     \\(p\\) value upper-tail probability. Two-sided (equivalence) \\(H_0: |\\theta - \\theta_0| \\ge \\delta\\)     versus \\(H_1: |\\theta - \\theta_0| < \\delta\\)     \\(t = (|Q - \\theta_0| - \\delta)/SE\\)     \\(p\\) value lower-tail probability.     Note \\(t\\) maximum \\(t_{nonsup}\\) \\(-t_{noninf}\\).      equivalent choosing less      significant result two-one-sided-test (TOST) procedure.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"non-estimable-cases","dir":"Reference","previous_headings":"","what":"Non-estimable cases","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"model rank-deficient, row x object's   linfct slot checked estimability. sum(x*bhat)   found non-estimable, string NonEst displayed   estimate, associated statistics set NA.    estimability check performed   using orthonormal basis N nbasis slot null   space rows model matrix. Estimability fails   \\(||Nx||^2 / ||x||^2\\) exceeds tol, default   1e-8. may change via emm_options setting   estble.tol desired value. See warning non-estimable cases still included   determining family size P-value adjustments.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"warning-about-potential-misuse-of-p-values","dir":"Reference","previous_headings":"","what":"Warning about potential misuse of P values","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"statistical scientific community argue   term “statistical significance” completely abandoned,   criteria “p < 0.05” never used assess   importance effect. practices can misleading prone abuse.   See “basics” vignette   discussion.","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/summary.emmGrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summaries, predictions, intervals, and tests for emmGrid objects — summary.emmGrid","text":"","code":"warp.lm <- lm(breaks ~ wool * tension, data = warpbreaks) warp.emm <- emmeans(warp.lm, ~ tension | wool) warp.emm    # implicitly runs 'summary' #> wool = A: #>  tension emmean   SE df lower.CL upper.CL #>  L         44.6 3.65 48     37.2     51.9 #>  M         24.0 3.65 48     16.7     31.3 #>  H         24.6 3.65 48     17.2     31.9 #>  #> wool = B: #>  tension emmean   SE df lower.CL upper.CL #>  L         28.2 3.65 48     20.9     35.6 #>  M         28.8 3.65 48     21.4     36.1 #>  H         18.8 3.65 48     11.4     26.1 #>  #> Confidence level used: 0.95   confint(warp.emm, by = NULL, level = .90) #>  tension wool emmean   SE df lower.CL upper.CL #>  L       A      44.6 3.65 48     38.4     50.7 #>  M       A      24.0 3.65 48     17.9     30.1 #>  H       A      24.6 3.65 48     18.4     30.7 #>  L       B      28.2 3.65 48     22.1     34.3 #>  M       B      28.8 3.65 48     22.7     34.9 #>  H       B      18.8 3.65 48     12.7     24.9 #>  #> Confidence level used: 0.9   # -------------------------------------------------------------- pigs.lm <- lm(log(conc) ~ source + factor(percent), data = pigs) pigs.emm <- emmeans(pigs.lm, \"percent\", type = \"response\") summary(pigs.emm)    # (inherits type = \"response\") #>  percent response   SE df lower.CL upper.CL #>        9     31.4 1.28 23     28.8     34.1 #>       12     37.5 1.44 23     34.7     40.6 #>       15     39.0 1.70 23     35.6     42.7 #>       18     42.3 2.24 23     37.9     47.2 #>  #> Results are averaged over the levels of: source  #> Confidence level used: 0.95  #> Intervals are back-transformed from the log scale  summary(pigs.emm, calc = c(n = \".wgt.\"))  # Show sample size #>  percent response   SE df n lower.CL upper.CL #>        9     31.4 1.28 23 8     28.8     34.1 #>       12     37.5 1.44 23 9     34.7     40.6 #>       15     39.0 1.70 23 7     35.6     42.7 #>       18     42.3 2.24 23 5     37.9     47.2 #>  #> Results are averaged over the levels of: source  #> Confidence level used: 0.95  #> Intervals are back-transformed from the log scale   # For which percents is EMM non-inferior to 35, based on a 10% threshold? # Note the test is done on the log scale even though we have type = \"response\" test(pigs.emm, null = log(35), delta = log(1.10), side = \">\") #>  percent response   SE df null t.ratio p.value #>        9     31.4 1.28 23   35  -0.360  0.6390 #>       12     37.5 1.44 23   35   4.295  0.0001 #>       15     39.0 1.70 23   35   4.635  0.0001 #>       18     42.3 2.24 23   35   5.384  <.0001 #>  #> Results are averaged over the levels of: source  #> Statistics are tests of noninferiority with a threshold of 0.09531  #> P values are right-tailed  #> Tests are performed on the log scale   con <- contrast(pigs.emm, \"consec\") test(con) #>  contrast              ratio     SE df null t.ratio p.value #>  percent12 / percent9   1.20 0.0671 23    1   3.202  0.0109 #>  percent15 / percent12  1.04 0.0604 23    1   0.650  0.8613 #>  percent18 / percent15  1.09 0.0750 23    1   1.194  0.5200 #>  #> Results are averaged over the levels of: source  #> P value adjustment: mvt method for 3 tests  #> Tests are performed on the log scale   test(con, joint = TRUE) #>  df1 df2 F.ratio p.value #>    3  23   7.981  0.0008 #>   # default Scheffe adjustment - rank = 3 summary(con, infer = c(TRUE, TRUE), adjust = \"scheffe\") #>  contrast              ratio     SE df lower.CL upper.CL null t.ratio p.value #>  percent12 / percent9   1.20 0.0671 23    1.011     1.42    1   3.202  0.0343 #>  percent15 / percent12  1.04 0.0604 23    0.872     1.24    1   0.650  0.9344 #>  percent18 / percent15  1.09 0.0750 23    0.882     1.34    1   1.194  0.7027 #>  #> Results are averaged over the levels of: source  #> Confidence level used: 0.95  #> Conf-level adjustment: scheffe method with rank 3  #> Intervals are back-transformed from the log scale  #> P value adjustment: scheffe method with rank 3  #> Tests are performed on the log scale   # Consider as some of many possible contrasts among the six cell means summary(con, infer = c(TRUE, TRUE), adjust = \"scheffe\", scheffe.rank = 5) #>  contrast              ratio     SE df lower.CL upper.CL null t.ratio p.value #>  percent12 / percent9   1.20 0.0671 23    0.976     1.47    1   3.202  0.1090 #>  percent15 / percent12  1.04 0.0604 23    0.841     1.28    1   0.650  0.9940 #>  percent18 / percent15  1.09 0.0750 23    0.845     1.40    1   1.194  0.9165 #>  #> Results are averaged over the levels of: source  #> Confidence level used: 0.95  #> Conf-level adjustment: scheffe method with rank 5  #> Intervals are back-transformed from the log scale  #> P value adjustment: scheffe method with rank 5  #> Tests are performed on the log scale   # Show estimates to more digits print(test(con), digits = 7) #>  contrast                 ratio         SE df null t.ratio p.value #>  percent12 / percent9  1.196684 0.06710564 23    1   3.202  0.0110 #>  percent15 / percent12 1.038570 0.06042501 23    1   0.650  0.8613 #>  percent18 / percent15 1.085945 0.07499759 23    1   1.194  0.5201 #>  #> Results are averaged over the levels of: source  #> P value adjustment: mvt method for 3 tests  #> Tests are performed on the log scale   # -------------------------------------------------------------- # Cross-adjusting P values prs <- pairs(warp.emm)   # pairwise comparisons of tension, by wool test(prs, adjust = \"tukey\", cross.adjust = \"bonferroni\") #> wool = A: #>  contrast estimate   SE df t.ratio p.value #>  L - M      20.556 5.16 48   3.986  0.0013 #>  L - H      20.000 5.16 48   3.878  0.0018 #>  M - H      -0.556 5.16 48  -0.108  1.0000 #>  #> wool = B: #>  contrast estimate   SE df t.ratio p.value #>  L - M      -0.556 5.16 48  -0.108  1.0000 #>  L - H       9.444 5.16 48   1.831  0.3407 #>  M - H      10.000 5.16 48   1.939  0.2777 #>  #> P value adjustment: tukey method for comparing a family of 3 estimates  #> Cross-group P-value adjustment: bonferroni   # Same comparisons taken as one big family (more conservative) test(prs, adjust = \"bonferroni\", by = NULL) #>  contrast wool estimate   SE df t.ratio p.value #>  L - M    A      20.556 5.16 48   3.986  0.0014 #>  L - H    A      20.000 5.16 48   3.878  0.0019 #>  M - H    A      -0.556 5.16 48  -0.108  1.0000 #>  L - M    B      -0.556 5.16 48  -0.108  1.0000 #>  L - H    B       9.444 5.16 48   1.831  0.4396 #>  M - H    B      10.000 5.16 48   1.939  0.3504 #>  #> P value adjustment: bonferroni method for 6 tests"},{"path":"https://rvlenth.github.io/emmeans/reference/ubds.html","id":null,"dir":"Reference","previous_headings":"","what":"Unbalanced dataset — ubds","title":"Unbalanced dataset — ubds","text":"simulated unbalanced dataset three factors two numeric variables. true relationships among variables. dataset can useful testing illustrating messy-data situations. missing data, least one observation every  factor combination; however, \"cells\" attribute makes simple construct subsets empty cells.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ubds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unbalanced dataset — ubds","text":"","code":"ubds"},{"path":"https://rvlenth.github.io/emmeans/reference/ubds.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Unbalanced dataset — ubds","text":"data frame 100 observations, 5 variables,   special \"cells\" attribute: Factor levels 1, 2, 3 B Factor levels 1, 2, 3 C Factor levels 1, 2, 3 x numeric variable y numeric variable addition, attr(ubds, \"cells\") consists named list length 27 row numbers combination , B, C. example,  attr(ubds, \"cells\")[[\"213\"]] row numbers corresponding levels == 2, B == 1, C == 3. entries ordered length, first entry cell lowest frequency.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/ubds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unbalanced dataset — ubds","text":"","code":"# Omit the three lowest-frequency cells  low3 <- unlist(attr(ubds, \"cells\")[1:3])   messy.lm <- lm(y ~ (x + A + B + C)^3, data = ubds, subset = -low3)"},{"path":"https://rvlenth.github.io/emmeans/reference/untidy.html","id":null,"dir":"Reference","previous_headings":"","what":"Dare to be un-","title":"Dare to be un-","text":"Users use emmeans functions part pipeline -- post-process  results way -- likely missing important information.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/untidy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dare to be un-","text":"best bet display actual results without post-processing. emmeans relatives summary  print methods display annotations may helpful explaining . just pipe results next step, annotations stripped away never see . Statistical analysis just workflow; discipline involves care interpreting intermediate results, thinking moving .","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/untidy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dare to be un-","text":"","code":"neur.glm <- glm(Pain ~ Treatment + Sex + Age, family = binomial(),             data = neuralgia)              ### The actual results with annotations (e.g. ests are on logit scale): emmeans(neur.glm, \"Treatment\") #>  Treatment emmean    SE  df asymp.LCL asymp.UCL #>  A          -1.40 0.664 Inf    -2.699   -0.0951 #>  B          -1.94 0.744 Inf    -3.403   -0.4867 #>  P           1.78 0.683 Inf     0.444    3.1198 #>  #> Results are averaged over the levels of: Sex  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95   ### Post-processed results lose the annotations if(requireNamespace(\"tibble\")) {     emmeans(neur.glm, \"Treatment\") |> tibble::as_tibble() } #> # A tibble: 3 × 6 #>   Treatment emmean    SE    df asymp.LCL asymp.UCL #>   <fct>      <dbl> <dbl> <dbl>     <dbl>     <dbl> #> 1 A          -1.40 0.664   Inf    -2.70    -0.0951 #> 2 B          -1.94 0.744   Inf    -3.40    -0.487  #> 3 P           1.78 0.683   Inf     0.444    3.12"},{"path":"https://rvlenth.github.io/emmeans/reference/update.emmGrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Update an emmGrid object — update.emmGrid","title":"Update an emmGrid object — update.emmGrid","text":"Objects class emmGrid contain several settings affect things arguments pass summary.emmGrid.  update method allows safer management settings direct modification slots.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/update.emmGrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update an emmGrid object — update.emmGrid","text":"","code":"# S3 method for emmGrid update(object, ..., silent = FALSE)  # S3 method for emmGrid levels(x) <- value  # S3 method for summary_emm update(object, by.vars, mesg, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/update.emmGrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update an emmGrid object — update.emmGrid","text":"object emmGrid object ... Options set. must match list known options (see Details) silent Logical value. FALSE (default), message displayed options matched. TRUE, messages shown. x emmGrid object value list replacement levels. See documentation update.emmGrid levels argument,  well section “Replaciong levels” .vars, mesg Attributes can altered update.summary_emm","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/update.emmGrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update an emmGrid object — update.emmGrid","text":"updated emmGrid object. levels<- replaces levels object -place.   See section replacing levels details.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/update.emmGrid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Update an emmGrid object — update.emmGrid","text":"makes sense, option set update persist  future results based object. options disabled well. example, calc option nulled-contrast called, probably make sense  calculations contrast results, fact variable(s) needed may even still exist. factor(percent).","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/update.emmGrid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Update an emmGrid object — update.emmGrid","text":"names ... partially matched valid, match found, adds replaces current setting. valid names tran, tran2 (list character) specifies transformation , inverted, determines results displayed summary.emmGrid, predict.emmGrid, emmip type=\"response\". value may name standard transformation make.link additional ones supported name, \"log2\"; , custom transformation, list containing least functions linkinv (inverse transformation) mu.eta (derivative thereof). make.tran function returns lists number popular transformations. See help page make.tran details well information additional named transformations supported. tran2 just like tran except second transformation (.e., response transformation generalized linear model). tran.mult Multiple tran. example, response transformation 2*sqrt(y) (sqrt(y) + sqrt(y + 1), matter), tran = \"sqrt\" tran.mult = 2. absent, multiple 1 assumed. tran.offset Additive constant transformation applied. example, response transformation log(y + pi) tran.offset  = pi. value present, offset 0 assumed. estName (character) column label used displaying predictions EMMs. inv.lbl (character)) column label use predictions EMMs type=\"response\". .vars (character) vector NULL) variables used grouping summary, also defining subfamilies call contrast. pri.vars (character vector) names grid variables .vars. Thus, combinations levels used columns table produced summary.emmGrid. alpha (numeric) default significance level tests, summary.emmGrid well plot.emmGrid CIs = TRUE. cautious methods depend specifying alpha prone abuse. See discussion vignette(\"basics\", \"emmeans\"). adjust (character)) default adjust argument summary.emmGrid. cross.adjust (character)) default cross.adjust argument summary.emmGrid (used adjusting groups). famSize (integer) number means involved family inferences; used Tukey adjustment infer (logical vector length 2) default value infer summary.emmGrid. level (numeric) default confidence level, level, summary.emmGrid. Note: must specify five letters  ‘level’ distinguish slot name ‘levels’. df (numeric) overrides default degrees freedom specified single value. calc (list) additional calculated columns. See summary.emmGrid. null (numeric) null hypothesis summary test (taken zero missing). side (numeric character) side specification summary test (taken zero missing). sigma (numeric) Error SD use predictions bias-adjusted back-transformations delta (numeric) delta specification summary test (taken zero missing). predict.type type (character) sets default method displaying predictions summary.emmGrid, predict.emmGrid, emmip. Valid values \"link\" (synonyms \"lp\" \"linear\"), \"response\". bias.adjust, frequentist (logical) used summary value arguments specified. estType (character) used internally determine  adjust methods appropriate. match one  c(\"prediction\", \"contrast\", \"pairs\"). example needed, Tukey adjustment used pairwise comparisons  (estType = \"pairs\"); estType string, Tukey adjustments allowed. avgd.(character) vector) names  variables whose levels averaged obtaining marginal averages  predictions, .e., estimated marginal means. Changing might produce  misleading printout, setting character(0) suppress  “averaged ” message summary. initMesg (character) string added beginning annotations appear summary.emmGrid display. methDesc (character) string may used creating names list emmGrid objects. nesting (Character named list) specifies nesting structure. See “Recovering overriding model information” documentation ref_grid. current nesting structure displayed str.emmGrid. levels named list new levels elements current emmGrid. list name(s) used new variable names, needed, list expanded using expand.grid. results replace current variable names levels. specification changes levels, grid, roles, misc slots updated emmGrid, resets pri.vars, .vars, adjust, famSize, avgd.. addition, nesting factors, may  altered; warning issued involves something mere name changes. Note: six letters levels needed order distinguish level. submodel formula character value specifying  submodel (requires feature supported underlying methods  model class). specified, linfct slot replaced  aliases specified sub-model. factors sub-model  appear model matrix ignored, interactions  main model, factors associate multivariate responses.  estimates displayed computed  sub-model fitted. (However, standard errors based error variance(s) full model.)  Note: formula refer predictor names, excluding function calls (factor poly) appear  original model formula. See example. character values allowed partially  match \"minimal\" \"type2\". \"minimal\", sub-model taken one involving surviving factors object (ones averaged omitted). Specifying \"type2\" \"minimal\" except highest-order term submodel retained, effects containing orthogonalized-. Thus, purely linear situation lm model, joint test modified object essence type-2 test car::Anova. objects generalized linear models, specifying submodel typically produce estimates type-2 tests obtained actually fitting separate model specifications. reason models fitted iterative-reweighting methods, whereas submodel calculations preserve final weights used fitting full model. (slot name) name matches element slotNames(object) levels, slot replaced  supplied value, required class (otherwise error occurs). user must careful replacing slots interrelated; example, lengths dimensions grid, linfct, bhat, V must conform.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/update.emmGrid.html","id":"replacing-levels","dir":"Reference","previous_headings":"","what":"Replacing levels","title":"Update an emmGrid object — update.emmGrid","text":"levels<- method uses update.emmGrid replace levels one factors. method allows selectively replacing levels just one factor (via subsetting operators), whereas  update(x, levels = list(...)) requires list factors levels. factors renamed, must replace levels include new names replacements. See examples.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/update.emmGrid.html","id":"method-for-summary-emm-objects","dir":"Reference","previous_headings":"","what":"Method for summary_emm objects","title":"Update an emmGrid object — update.emmGrid","text":"method exists can change way summary displayed, changing variables annotations.","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/update.emmGrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update an emmGrid object — update.emmGrid","text":"","code":"# Using an already-transformed response: pigs.lm <- lm(log(conc) ~ source * factor(percent), data = pigs)  # Reference grid that knows about the transformation # and asks to include the sample size in any summaries: pigs.rg <- update(ref_grid(pigs.lm), tran = \"log\",                      predict.type = \"response\",                     calc = c(n = ~.wgt.)) emmeans(pigs.rg, \"source\") #> NOTE: Results may be misleading due to involvement in interactions #>  source response   SE df  n lower.CL upper.CL #>  fish       29.9 1.12 17 10     27.6     32.3 #>  soy        38.9 1.60 17 10     35.7     42.4 #>  skim       46.1 1.97 17  9     42.1     50.4 #>  #> Results are averaged over the levels of: percent  #> Confidence level used: 0.95  #> Intervals are back-transformed from the log scale   # Obtain estimates for the additive model # [Note that the submodel refers to 'percent', not 'factor(percent)'] emmeans(pigs.rg, \"source\", submodel = ~ source + percent) #> NOTE: Results may be misleading due to involvement in interactions #>  source response   SE df  n lower.CL upper.CL #>  fish       29.8 1.10 17 10     27.6     32.2 #>  soy        39.1 1.48 17 10     36.1     42.4 #>  skim       44.6 1.77 17  9     41.0     48.5 #>  #> Results are averaged over the levels of: percent  #> submodel: ~ source + percent  #> Confidence level used: 0.95  #> Intervals are back-transformed from the log scale   # Type II ANOVA joint_tests(pigs.rg, submodel = \"type2\") #>  model term     df1 df2 F.ratio p.value #>  source           2  17  28.291  <.0001 #>  percent          3  17   7.827  0.0017 #>  source:percent   6  17   0.926  0.5011 #>   ## Changing levels of one factor newrg <- pigs.rg levels(newrg)$source <- 1:3 newrg #>  source percent response   SE df n #>       1       9     25.7 2.11 17 2 #>       2       9     34.4 2.31 17 3 #>       3       9     35.2 2.36 17 3 #>       1      12     30.9 2.07 17 3 #>       2      12     39.6 2.66 17 3 #>       3      12     43.2 2.90 17 3 #>       1      15     31.0 2.55 17 2 #>       2      15     39.2 2.63 17 3 #>       3      15     49.6 4.08 17 2 #>       1      18     32.3 2.17 17 3 #>       2      18     42.9 4.99 17 1 #>       3      18     59.8 6.95 17 1 #>   ## Unraveling a previously standardized covariate zd = scale(fiber$diameter) fibz.lm <- lm(strength ~ machine * zd, data = fiber) (fibz.rg <- ref_grid(fibz.lm, at = list(zd = -2:2)))   ### 2*SD range #>  machine zd prediction    SE df #>  A       -2       30.7 2.025  9 #>  B       -2       34.2 2.470  9 #>  C       -2       31.1 1.405  9 #>  A       -1       35.4 1.285  9 #>  B       -1       37.9 1.575  9 #>  C       -1       34.8 0.803  9 #>  A        0       40.2 0.777  9 #>  B        0       41.6 0.858  9 #>  C        0       38.5 0.966  9 #>  A        1       45.0 0.979  9 #>  B        1       45.3 0.929  9 #>  C        1       42.3 1.686  9 #>  A        2       49.8 1.648  9 #>  B        2       49.0 1.693  9 #>  C        2       46.0 2.523  9 #>  lev <- levels(fibz.rg) levels(fibz.rg) <- list (     machine = lev$machine,     diameter = with(attributes(zd),                      `scaled:center` + `scaled:scale` * lev$zd) ) fibz.rg #>  machine diameter prediction    SE df #>  A           15.5       30.7 2.025  9 #>  B           15.5       34.2 2.470  9 #>  C           15.5       31.1 1.405  9 #>  A           19.8       35.4 1.285  9 #>  B           19.8       37.9 1.575  9 #>  C           19.8       34.8 0.803  9 #>  A           24.1       40.2 0.777  9 #>  B           24.1       41.6 0.858  9 #>  C           24.1       38.5 0.966  9 #>  A           28.5       45.0 0.979  9 #>  B           28.5       45.3 0.929  9 #>  C           28.5       42.3 1.686  9 #>  A           32.8       49.8 1.648  9 #>  B           32.8       49.0 1.693  9 #>  C           32.8       46.0 2.523  9 #>   ### Compactify results with a by variable update(joint_tests(pigs.rg, by = \"source\"), by = NULL) #>  model term source df1 df2 F.ratio p.value #>  percent    fish     3  17   1.712  0.2023 #>  percent    soy      3  17   1.290  0.3097 #>  percent    skim     3  17   6.676  0.0035 #>"},{"path":"https://rvlenth.github.io/emmeans/reference/wrappers.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrappers for alternative naming of EMMs — lsmeans","title":"Wrappers for alternative naming of EMMs — lsmeans","text":"wrappers emmeans related functions provide backward compatibility, users may prefer use terminology “estimated marginal means” -- namely  “least-squares means”. functions also provide functionality formerly provided lsmeans package, now just front-end emmeans.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/wrappers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrappers for alternative naming of EMMs — lsmeans","text":"","code":"lsmeans(...)  lstrends(...)  lsmip(...)  lsm(...)  lsmobj(...)  lsm.options(...)  get.lsm.option(x, default = emm_defaults[[x]])"},{"path":"https://rvlenth.github.io/emmeans/reference/wrappers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrappers for alternative naming of EMMs — lsmeans","text":"... Arguments passed corresponding emxxxx function x Character name desired option default default value return x found","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/wrappers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrappers for alternative naming of EMMs — lsmeans","text":"result call emxxxx, suitably modified. get.lsm.option lsm.options remap options   corresponding options emmeans options system.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/wrappers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wrappers for alternative naming of EMMs — lsmeans","text":"function lsxxxx name, function named emxxxx called. estimator names  list items beginning “em” replaced “ls”  results returned","code":""},{"path":[]},{"path":"https://rvlenth.github.io/emmeans/reference/wrappers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrappers for alternative naming of EMMs — lsmeans","text":"","code":"pigs.lm <- lm(log(conc) ~ source + factor(percent), data = pigs) lsmeans(pigs.lm, \"source\") #>  source lsmean     SE df lower.CL upper.CL #>  fish     3.39 0.0367 23     3.32     3.47 #>  soy      3.67 0.0374 23     3.59     3.74 #>  skim     3.80 0.0394 23     3.72     3.88 #>  #> Results are averaged over the levels of: percent  #> Results are given on the log (not the response) scale.  #> Confidence level used: 0.95"},{"path":"https://rvlenth.github.io/emmeans/reference/xtable.emmGrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Using xtable for EMMs — xtable.emmGrid","title":"Using xtable for EMMs — xtable.emmGrid","text":"methods provide support xtable package, enabling  polished presentations tabular output emmeans functions.","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/xtable.emmGrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Using xtable for EMMs — xtable.emmGrid","text":"","code":"# S3 method for emmGrid xtable(x, caption = NULL, label = NULL, align = NULL,   digits = 4, display = NULL, auto = FALSE, ...)  # S3 method for summary_emm xtable(x, caption = NULL, label = NULL,   align = NULL, digits = 4, display = NULL, auto = FALSE, ...)  # S3 method for xtable_emm print(x, type = getOption(\"xtable.type\", \"latex\"),   include.rownames = FALSE, sanitize.message.function = footnotesize, ...)"},{"path":"https://rvlenth.github.io/emmeans/reference/xtable.emmGrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Using xtable for EMMs — xtable.emmGrid","text":"x Object class emmGrid caption Passed xtableList label Passed xtableList align Passed xtableList digits Passed xtableList display Passed xtableList auto Passed xtableList ... Arguments passed summary.emmGrid type Passed print.xtable include.rownames Passed print.xtable sanitize.message.function Passed print.xtable","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/xtable.emmGrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Using xtable for EMMs — xtable.emmGrid","text":"xtable methods return xtable_emm object, print method print.xtable_emm .","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/xtable.emmGrid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Using xtable for EMMs — xtable.emmGrid","text":"methods actually use xtableList, ability display messages P-value adjustments. methods return object class \"xtable_emm\" -- extension \"xtableList\". Unlike xtable methods, number digits defaults 4; degrees freedom t ratios always formatted independently digits. print method uses print.xtableList, ... arguments passed .","code":""},{"path":"https://rvlenth.github.io/emmeans/reference/xtable.emmGrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Using xtable for EMMs — xtable.emmGrid","text":"","code":"if(requireNamespace(\"xtable\"))     emm_example(\"xtable\") #>  #> --- Running code from 'system.file(\"extexamples\", \"xtable.R\", package = \"emmeans\")' #>  #> > pigsint.lm <- lm(log(conc) ~ source * factor(percent),  #> +     data = pigs) #>  #> > pigsint.emm <- emmeans(pigsint.lm, ~percent | source) #>  #> > xtable::xtable(pigsint.emm, type = \"response\") #> % latex table generated in R 4.4.0 by xtable 1.8-4 package #> % Sat May 18 21:10:05 2024 #> \\begin{table}[ht] #> \\centering #> \\begin{tabular}{rrrrrr} #>   \\hline #> percent & response & SE & df & lower.CL & upper.CL \\\\  #>   \\hline #> \\multicolumn{6}{l}{source = fish}\\\\ #> 9.0000 & 25.6683 & 2.1101 & 17 & 21.5810 & 30.5296 \\\\  #>   12.0000 & 30.8799 & 2.0727 & 17 & 26.8025 & 35.5777 \\\\  #>   15.0000 & 31.0193 & 2.5500 & 17 & 26.0801 & 36.8941 \\\\  #>   18.0000 & 32.3072 & 2.1685 & 17 & 28.0413 & 37.2222 \\\\  #>    \\hline #> \\multicolumn{6}{l}{source = soy}\\\\ #> 9.0000 & 34.4135 & 2.3099 & 17 & 29.8695 & 39.6489 \\\\  #>   12.0000 & 39.6314 & 2.6601 & 17 & 34.3984 & 45.6606 \\\\  #>   15.0000 & 39.2286 & 2.6331 & 17 & 34.0487 & 45.1964 \\\\  #>   18.0000 & 42.9000 & 4.9874 & 17 & 33.5686 & 54.8254 \\\\  #>    \\hline #> \\multicolumn{6}{l}{source = skim}\\\\ #> 9.0000 & 35.1821 & 2.3615 & 17 & 30.5365 & 40.5343 \\\\  #>   12.0000 & 43.1574 & 2.8968 & 17 & 37.4588 & 49.7230 \\\\  #>   15.0000 & 49.6316 & 4.0800 & 17 & 41.7287 & 59.0314 \\\\  #>   18.0000 & 59.8000 & 6.9522 & 17 & 46.7926 & 76.4232 \\\\  #>    \\hline #> \\multicolumn{6}{l}{{\\footnotesize Confidence level used: 0.95}}\\\\ #>  #> \\multicolumn{6}{l}{{\\footnotesize Intervals are back-transformed from the log scale}}\\\\ #> \\end{tabular} #> \\end{table} #>      # Use emm_example(\"xtable\", list = TRUE) # to just list the code"},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-1102","dir":"Changelog","previous_headings":"","what":"emmeans 1.10.2","title":"emmeans 1.10.2","text":"update focused mostly trying clear confusion users distinction emmGrid objects summaries, since display identically; encouraging users bypass important annotations. Added startup message help(untidy) Added rbind method summary_emm objects (#480). Note summary_emm objects already estimates, P-values, etc. computed, rbinding preserves results. hand, rbinding emmGrid emm_list objects produce new emmGrid objects yet summarized adjust methods applied whole result. Created pkgdown site","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-1101","dir":"Changelog","previous_headings":"","what":"emmeans 1.10.1","title":"emmeans 1.10.1","text":"CRAN release: 2024-04-06 gls lme models, mode = \"satterthwaite\" mode =  \"appx-satterthwaite\" failed model fitted explicit data argument (#465) decided export .emmc functions, just make easier see use Added new contrast function wtcon.emmc(levs, wts, cmtype, ...) generates contrasts via multcomp::contrMat(wts, type = cmtype, ...) contrast() gains new argument wts can passed .emmc functions including eff.emmc, del.eff.emmc, wtcon.emmc. wts left missing, pass equal weights . specifywts = NA, retrieve weights object (potentially different     eachbygroup). Otherwise, fixedwts` used group. Added weights() method emmGrid objects Modification pwpp() play along contrast() changes variable via options (#472) wiggling around, now allow strata() factors included reference grid survival models. user decide sensible. (#429, #473)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-1100","dir":"Changelog","previous_headings":"","what":"emmeans 1.10.0","title":"emmeans 1.10.0","text":"CRAN release: 2024-01-23 Restored tau argument (now optional) rq models (#458) Fixed issue multivariate factor numeric levels may mismatch level even apparently valid (#458) Added cross.adjust legal arguments can passed via misc slot Robustified code cross.adjust Fixed masking vcov. glmgee support (#460) Fixed error xtable() method summary_emm objects Added inner argument make.tran() allow compound transform; e.g., make.tran(\"inverse\", inner = \"sqrt\") reciprocal sqrt (#462)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-190","dir":"Changelog","previous_headings":"","what":"emmeans 1.9.0","title":"emmeans 1.9.0","text":"CRAN release: 2023-12-18 Warning message prior weights sometimes unnecessary. now suppress prior weights equal. Fix MuMIn support subset argument (#455) Repair coding error nested models (#457) Added glmtoolbox::glmgee support (#454) qdrg() modified often don’t need specify data object specified. Support rq, rqs now incorporates tau values model pseudofactor (#458). tau argument deprecated ignored specified.","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-189","dir":"Changelog","previous_headings":"","what":"emmeans 1.8.9","title":"emmeans 1.8.9","text":"CRAN release: 2023-10-17 Added functions make.meanint() make.symmint() return functions compute symmetric intervals. old meanint() symmint() functions return symmetric intervals width 2 retained back-compatibility Small repairs multinom support works model response matrix counts (#439) Enhancements/fixes MuMIn support (#442) qdrg() replaced ordinal.dim argument ordinal, list elements dim mode – now fully supports modes available ordinal models (#444). (ordinal.dim still works backward compatibility.) Fix bookkeeping bug emtrends (#448) Fix averaging support certain predictor function calls (#449)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-188","dir":"Changelog","previous_headings":"","what":"emmeans 1.8.8","title":"emmeans 1.8.8","text":"CRAN release: 2023-08-17 Bug correction contrast tran list (#428) Bug correction suppress nuisance warning number prior weights 0 1 (indeed doesn’t match number rows data, also isn’t really issue) (Commit d921152 easystats) Bug correction strata() terms survival models (#429) Added risk-ratio probit example Transformations vignette. Multivariate levels mishandled specified order (#430) Fix flow error qdrg() didn’t always get V right Change adjustment methods non-estimable cases. Now always adapt family size include estimable ones. may change adjusted P values confidence limits obtained past versions, model rank-deficient. vcov.emmGrid() now returns elements object@misc$display == TRUE. also label dimensions provide sep argument creating labels.","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-187","dir":"Changelog","previous_headings":"","what":"emmeans 1.8.7","title":"emmeans 1.8.7","text":"CRAN release: 2023-06-23 Correction bug introduced version 1.8.4, tried provide offset argument way offset() term model formula. Unfortunately, change also caused wrong estimates computed offset involves nonlinear function log(), made whopping inconsistencies narrative offsets \"sophisticated\" vignette; apologize embarrassing errors. now provide kinds offset specifications, different ways explained new section \"xplanations\" vignette. “subtle difference” mentioned NEWS 1.8.4 longer applies. Change qdrg(). object specified, default df df.residual(object) rather object$df.residual, since df.residual() standard method. .mcmc() now uses get_emm_option(\"sep\") labeling factor combinations (#425).","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-186","dir":"Changelog","previous_headings":"","what":"emmeans 1.8.6","title":"emmeans 1.8.6","text":"CRAN release: 2023-05-11 Major fix emm_basis.averaging take care quirks models (#402, #409) Added decreasing argument cld.emmGrid() compatibility multcomp::cld.glht() others. Fix bug emtrends() data specified (semTools issue 119) … related tune-ref_grid() avoid issues repeat calls (#413) Tweak emm_list methods make user-friendly (#417) added pwts argument recover_data.call(), needed prior weights always come . provides reliable way passing prior weights recover_data() method","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-185","dir":"Changelog","previous_headings":"","what":"emmeans 1.8.5","title":"emmeans 1.8.5","text":"CRAN release: 2023-03-08 passing scale info emmip_ggplot() (#397) Changes .data.frame behavior. made forceful preserving annotations (.e., summary_emm behavior) users don’t blind potentially important information. Also, users seem force display data frame order see digits; now taking compromise approach: showing digits still summary_emm object annotations also displayed. Added Chisq value results test(..., joint = TRUE) joint_tests() df2 infinite (per request #400) basics vignette undergone major revision hope helps getting users oriented. starts discussing fact EMMs’ underpinnings experiments observational data, emphasizes process first getting good model. confidence-intervals vignette updated reflect example pigs used basics Bias adjustment: Bias adjustment disabled default non-Gaussian family models, warning issued. can enable bias adjustment providing valid sigma value; however, generalized linear models value sigma(model) often inappropriate bias adjustment, fact anyway. *, mixed models, calculate sigma based random effects. See vignette transformations. Prediction intervals: non-Gaussian models, predict(..., interval = \"prediction\") refuse work, option override. specifying PIs = TRUE plot() emmip(). calculations done prediction intervals valid Gaussian models. may predictions non-Gaussian models via simulating posterior predictive distribution Bayesian approach; see illustration “sophisticated” vignette. changes help reduce incidence users using package incorrectly GLMs, GLMMs, GEEs. ’s still issue Gaussian mixed models often wrong default sigma value associated , resulting incorrect PIs incorrect bias adjustments. figured might help prevent , probably involve making tedious modifications models’ emm_basis methods. Maybe future improvements made. Bug fix matching terms averaging objects (#402) Bug fix mira objects data required (#406)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-184","dir":"Changelog","previous_headings":"","what":"emmeans 1.8.4","title":"emmeans 1.8.4","text":"Fix scale() response transformation either center scale FALSE. also added support center() standardize() datawizard package response transformations, though mapped scale(). Citation correction (#391) Removed message contrasting transformed objects even confuses ! (added topic FAQs vignette instead) Added new exported function inverse available response transformation quietly deprecated previous I_bet() function, produced message confusing inexperienced users. Instead, tweaked functions/methods seem work way emm_list object (using first element) emmGrid object. removed functions convert_workspace() convert_scripts() intended clean existing code objects ancient version lsmeans. also completely removed several old functions codebase. Previously, just ignored . reliable dispatching recover_data() emm_basis() methods (#392) New permute_levels() function change order levels factor (#393) may alter results existing code models involving offsets: user discovered issue whereby offsets specified offset() model term accounted , specified offset = ... argument ignored. revised recover_data() ref_grid() code offsets specified either way (even ) treated way (include predictions unless overridden offset argument emmeans() ref_grid()). change creates subtle difference cases want offsets depend predictors: model formula y ~ trt + offset(), used specify cov.reduce = ~ trt, now need cov.reduce = .offset. ~ trt. latter work model y ~ trt, offset = . Recoded portions support functions zeroinfl hurdle objects. now use numerical differentiation delta method, comes lot cleaner. Per improved count-model support, now exporting documented two new functions hurdle.support() zi.support() may useful providing comparable support packages offer zero-inflated models. Efficiency improvements: Several places code multiply matrix diagonal matrix, replace equivalent code using sweep() function. time, many users latched idea emmeans(model, pairwise ~ treatment(s)) recipe using emmeans(). works okay just one factor, three factors, say, pairwise ~ fac1*fac2*fac3 gives every possible comparison among cell means; often, creates intractable amount output (e.g., 378 comparisons 3x3x3 case) – diagonal comparisons. now, user interactive mode, specifies contrasts direct emmeans() call (.e., sys.parent() == 0), one primary factor (including factors), 21 contrasts result (e.g. 7 levels compared pairwise), issue advisory warning message: “may generated contrasts really wanted…”. restrictions warning issued, affect reverse-dependent package checks .","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-183","dir":"Changelog","previous_headings":"","what":"emmeans 1.8.3","title":"emmeans 1.8.3","text":"CRAN release: 2022-12-06 Fix logic error regrid() (#287, revisited) Fix nbasis calculation ordinal models (#387) Bias-adjustment example added random slopes New addl.vars argument allows including variables (say, random slopes) reference grid. Removed dependence xtable package. xtable methods now dynamically registered. reduces number package dependencies 8 7 (version). Added alt text pictures vignettes (#389). makes materials accessible per guidelines A11Y project. Added \"atanh\" options make.tran() “named” response transformations auto-detected make.tran() replaces param argument alpha beta (param still supported backward compatibility) documentation revised hopes making everything clearer","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-182","dir":"Changelog","previous_headings":"","what":"emmeans 1.8.2","title":"emmeans 1.8.2","text":"CRAN release: 2022-10-27 Extended cld() can show findings rather non-findings, two different ways: Using delta, groupings based actual tests equivalence threshold delta; setting signif.sets = TRUE, means letter significantly different. also added vignette “Re-engineering CLDs”. Bug fix subtle error emtrends() (#133) Improved customization emmip() can specify color, linetype, symbol associated groupings; addition example produce black--white plot. Note: default appearance plots unchanged, plots existing code may altered used linearg, dotarg, etc. Allow vcov. coercible matrix, function yields result coercible matrix (#383) Robustness improvement \"appx-satterthwaite\" method (#384) Added counterfactuals argument ref_grid(), setting reference grid consisting stated factors constructed factor, .obs... (default) average grid covariate distribution. facilitates G-computation exchangeability assumption counterfactuals.","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-181","dir":"Changelog","previous_headings":"","what":"emmeans 1.8.1","title":"emmeans 1.8.1","text":"Fixed new bug summary() introduced #359 reported #364 Fixed .data.frame.emm_list() preserves annotations like .data.frame.emmGrid() Fix mgcv::gam support accommodate fancier smoothers accurately detect random terms (#365, #366, #369) Fix call summary() inside function (#367) Added delta argument hpd.summary(), thus allowing way assess equivalence Bayesian estimates (#370) Bug fix stanreg estimability code subset used model. emmip() plot.emmGrid() now appropriate things point.est frequentist appear among ... arguments, Bayesian models (note also, frequentist removed visible arguments plot.emmGrid). Bayesian models, emmip() plotted intervals regardless CIs; corrected Added head() tail() methods emmGrid objects [.summary_emm(), changed default .df = FALSE annotations still visible default. also preserves annotations head() tail() summaries New emm_example() function used tidy-certain help-file examples conditional external package Continued efforts prevent users hiding annotations need see. functions/methods summary(), confint(), test(), .data.frame() produce data frames annotations intact visible. Additional wrapping data.frame(), .data.frame(), etc. completely unnecessary, send questions bug reports code, regard willful ignorance refuse respond. See also news version 1.8.0.","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-180","dir":"Changelog","previous_headings":"","what":"emmeans 1.8.0","title":"emmeans 1.8.0","text":"CRAN release: 2022-08-05 Fixed minor bug lme support (#356) Added support svyolr objects survey package (#350) Improvements mgcv::gam support. Previously, random smoothers included. Thanks Maarten Jung observing helping identify . Sometimes incorrect computations rank deficient models \"est.fcns\" attribute actually estimable Results (confounded) entry joint_tests() now much better formulated robust. Added section related xplanations vignette Version dependency estimability (>= 1.4.1) due bug version 1.4 joint_tests(), changed default cov.reduce = range cov.reduce = meanint, meanint(x) returns mean(x) + c(-1, 1). centers covariate values around means, rather midranges, line default ref_grid(..., cov.reduce = mean). However, change default change results joint_tests() past experiences models covariates interact factors covariates. also added section covariates help joint_tests(), added another function symmint() use cov.reduce. print.summary_emm() now puts groups correct order rather order appearance. .data.frame method new argument destroy.annotations, defaults FALSE – case returns summary_emm object (inherits data.frame). see many users routinely wrap results .data.frame want access displayed results later steps. missed potentially useful annotations. Users used .data.frame see results lots digits instead use emm_options(opt.digits = FALSE). New R version dependency >= 4.1.0, allowing freedom use forward pipe operator |> features. Housecleaning: removed completely trend argument emmeans(), long since deprecated. removed wrappers implement pmmeans(), pmtrends(), etc. – believe nobody ever used.","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-175","dir":"Changelog","previous_headings":"","what":"emmeans 1.7.5","title":"emmeans 1.7.5","text":"CRAN release: 2022-06-22 Modified defaults several methods class emm_list, added complete documentation. also added hidden emm_list support several functions like add_grouping(), emmip(), emmeans() . changes, hope, help situations users create objects like emm <- emmeans(model, pairwise ~ treatment) experienced attuned distinction emmGrid emm_list objects. mechanism provide default  element emm_list use. message shown specifies element selected encourages user specify explicitly future via either [[ ]] argument; example, plot(emm[[1]]) plot(emm, = 1). object returned joint_tests() test(..., joint = TRUE) now \"est.fcns\" attribute, list linear functions associated joint test(s). joint_tests() results now possibly include (confounded) entry effects purely explained model term.f New cross.adjust argument summary.emmGrid() allows additional P-value adjustment across groups. Apparently, glm.nb support longer requires data (#355) documentation updated.","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-174","dir":"Changelog","previous_headings":"","what":"emmeans 1.7.4","title":"emmeans 1.7.4","text":"Added argument enhance.levels contrast() allows better labeling levels contrasted. example, now (default) factor treat numeric levels, comparisons levels like treat1 - treat2 rather 1 - 2. can request similar behavior non-numeric levels, specify factors. Two new functions comb_facs() split_fac() manipulating factors emmGrid. Added argument wts eff.emmc del.eff.emmc, allows weighted versions effect-style contrasts (#346) Made qdrg() robust accommodating various manifestations rank-deficient models. qdrg() now always uses df provided. Previously forced df = Inf link function provided. Fix df.error calculation gls (#347)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-173","dir":"Changelog","previous_headings":"","what":"emmeans 1.7.3","title":"emmeans 1.7.3","text":"CRAN release: 2022-03-27 argument change ref_grid(..., transform = ...) now ref_grid(..., regrid = ...) avoid confusing transform tran option (kind opposite). match transform don’t match tran, still work, message displayed advice use regrid instead. Repairs averaging support (#324). Previous versions potentially dead wrong except models created lm() (maybe bad ) Added argument emm() select list elements pass multcomp::glht() Support rank-deficient gls models (note nlme allows models gls, lme) Bug lqm / lqmm support (#340) minor corrections (e.g. #334)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-172","dir":"Changelog","previous_headings":"","what":"emmeans 1.7.2","title":"emmeans 1.7.2","text":"CRAN release: 2022-01-04 Improvements averaging support (#319) Fixed bug comparison arrows = NULL (#321) (bug subtle byproduct name-checking #305) Note fixes visible errors vignettes ver 1.7.1-1 Patch gamlss support (#323) Added withAutoprint() documentation examples require() clauses, see interactive-style results Correction logic error adjustment corrections summary.emmGrid (#31) Revised summary.emmGrid() response transformation link function, transformations followed type = \"response\". Previously, took lazy way used summary(regrid(object, transform = \"unlink\"), type = \"response\") (see #325) Fix force_regular() caused unintended warning (#326) Fixes issues emtrends() (#327)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-171","dir":"Changelog","previous_headings":"","what":"emmeans 1.7.1","title":"emmeans 1.7.1","text":"Support multinomial models mgcv::gam (#303) thanks Hannes Riebl plot.emmGrid() now forces names syntactically valid .data.frame.emmGrid(), changed optional argument check.names (defaulting TRUE), actually effect. default, result syntactically valid names; change, optional work right (argument `.data.frame.list()). Fix missing column names linfct emmeans() (#308) Added gnls support (#313, #314, thanks Fernando Miguez) Modified glm support df.residual used family gaussian gamma. Thus, e.g., match lm results model fitted Gaussian family. Previously ignored d.f. glm objects. New vignette example percentage differences graceful handling comparisons one mean; related FAQ","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-170","dir":"Changelog","previous_headings":"","what":"emmeans 1.7.0","title":"emmeans 1.7.0","text":"CRAN release: 2021-09-29","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"notable-changes-1-7-0","dir":"Changelog","previous_headings":"","what":"Notable changes","title":"emmeans 1.7.0","text":"New rg.limit option (argument ref_grid()) limit number rows reference grid (#282, #292). change affect existing code used work – fairly extreme situations. users report extreme performance issues can traced size reference grid billions, causing memory paged, etc. providing limit really necessary. default 10,000 rows. hope existing users don’t bump often. nuisance (non.nuisance) argument ref_grid() (see ) can help work around limit. New nuisance option ref_grid(), can specify names factors exclude reference grid (accommodating averaging) (#282, #292). must factors don’t interact anything, even nuisance factors. provides remedy excessive grid sizes. Changed order arguments something bit natural Default contrasts now object$contrasts object specified Detection multivariate situations Added ordinal.dim argument support ordinal models New force_regular() function adds invisible rows irregular emmGrid make regular (.e., covers factor combinations)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"bug-fixes-and-tweaks-1-7-0","dir":"Changelog","previous_headings":"","what":"Bug fixes and tweaks","title":"emmeans 1.7.0","text":"Removed dependency plyr package (#298) Fix bug regrid() nested structures (#287) Fix bug rbind() mishandled @grid$.offset. Major repairs clm clmm support fix issues related rank deficiency nested models, particularly mode = \"prob\" (#300) Allow type passed emmeans() object already emmGrid (incidentally noticed #287) Code prevent warning existing factor coerced factor model formula – see question Add documentation note add_grouping multiple reference factors (#291)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-163","dir":"Changelog","previous_headings":"","what":"emmeans 1.6.3","title":"emmeans 1.6.3","text":"CRAN release: 2021-08-20 Clarification documentation ref_grid(object, vcov. = ...) (#283) Fix emmtrends() covariate formulas (#284) Improved parts “Basics” vignette - removed “back story”, revised guidance P values models Allow > 1 reference factor add_grouping() (#286) Repairs contrast() avoid -nonEst results irregular nested structures","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-162","dir":"Changelog","previous_headings":"","what":"emmeans 1.6.2","title":"emmeans 1.6.2","text":"Fixed navigation error vignette index Discouraging message added cld() results. Also providing emm_list method emm_list objects. Added mvcontrast() function (#281) assoc vignette material Added update.summary_emm()","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-161","dir":"Changelog","previous_headings":"","what":"emmeans 1.6.1","title":"emmeans 1.6.1","text":"CRAN release: 2021-06-01 Fixed bug parsing response transformation (#274) Changed handling contrast() log2 log10 transformations handled just like log. (#273) Also disabled making ratios genlog seems ill-advised. Added support log1p transformation Improved detection cases Tukey adjustment []appropriate (#275) Added type = \"scale\" argument plot.emmGrid() emmip(). type = \"response\" except scale transformed (.e., log scale log transformation used). Since transformation used, appearance plot type = \"lp\", altered axis scale. Currently implemented engine = \"ggplot\". Fixed bug whereby Scheffe ignored one contrast, even though scheffe.rank > 1 specified. (#171) Added subset() method emmGrid objects Bug fixes mcmc mcmc.list objects (#278, #279) test() shows null whenever nonzero chosen scale (#280)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-160","dir":"Changelog","previous_headings":"","what":"emmeans 1.6.0","title":"emmeans 1.6.0","text":"CRAN release: 2021-04-24 version changes affect users, e.g., saving .Last.ref_grid, incremented sub-version number. Changed handling logit transformations contrast(), odds-ratio transformation persists subsequent contrast() calls e.g., interaction contrasts. also made contrast(..., type = ...) work correctly Bug fix p.adjust.methods work (#267) Support mblogit extended work mmblogit models (#268) (However, since, mclogit pkg incorporates interface) Added export option print.emmGrid() print.emm_summary() Changed default emm_options(save.ref_grid = FALSE). Years ago, seemed potentially useful save last reference grid, extra overhead, writes user’s global environment. option remains want . Added note advising using .data.frame (lose potentially important annotations), information/example see digits (guess ’m seeing users ). refinement nesting detection. model like y ~ :B detected %% B B %% , hence %% *B B %% *B due change 1.4.6. Now omit cases factors nested ! Expansion cov.reduce formulas allow use custom models predicting mediating covariates","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-155","dir":"Changelog","previous_headings":"","what":"emmeans 1.5.5","title":"emmeans 1.5.5","text":"multinom “correction” version 1.5.4 actually “incorrection.” right , made wrong! analyzing multinom models, use version 1.5.4 Repairs support mblogit models Bug fix survreg support (#258) – survreg() doesn’t handle missing factor levels way lm(). also affects results coxph(), AER::tobit(), … Addition note help auto.noise dataset, changing example vignette example noise/10 response variable. (Thanks speech hearing professor Stuart Rosen pointing issue e-mail comment.) Bug fix appx-satterthwaite mode gls/lme models (#263) Added mode = \"asymptotic\" gls/lme models. Added facetlab argument emmip_ggplot() user can control facets labeled (#261) Efficiency improvements joint_tests() (#265) Bug fixes joint_tests() interaction contrasts nested models (#266) Improvement multinom support suggested question","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-154","dir":"Changelog","previous_headings":"","what":"emmeans 1.5.4","title":"emmeans 1.5.4","text":"CRAN release: 2021-02-03 Fix bug rbind.emm_list() default Fix glitch recovering data gee models (#249) Support svyglm objects (#248) Better support lqm, lqmm, added support rq & rqs objects (quantreg package). User may pass summary boot arguments method, se, R, … (#250) Correction multinom objects (SEs previously incorrect) addition support related mclogit::mblogit objects. possible, users re-run pre-1.5.4 analyses multinomial modelsNote: correction wrong! using multinomial models, use version 1.5.4! Change less misleading messages documentation related N.sim argument regrid(). longer calling posterior sample really Bayesian method, just simulated set regression coefficients.","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-153","dir":"Changelog","previous_headings":"","what":"emmeans 1.5.3","title":"emmeans 1.5.3","text":"CRAN release: 2020-12-09 Per long-time threats, really removing CLD() . tried version 1.5.0, forced cave due downstream problems. Addition levels<- method maps update(... levels =) (#237) Fix cld() works nested cases (#239) Enable coef() method work contrasts nested models. makes possible pwpp() work (#239) Fixed coding error plot() occurs use `type = “response” fact transformation (reported StackOverflow) Added \"log10\" \"log2\" legal transformations regrid() Revised vignette example MCMC models, added example bayestestR Expanded support ordinal models link functions available ordinal (errors-ordinal installed link available stats::make.link()) Cleaned-emmip() route plot output rendering functions emmip_ggplot() emmip_lattice(). functions allow customization plot can also called independently. (later, maybe next update: plot.emmGrid(). name rendering functions?? – suggestions?) Cleaned code .emmc functions parenthesization levels get way ref, exclude, include arguments (#246) Fix bug emtrends() data specified (#247) Tries harder recover original data available object (#247). particular, sometimes available, e.g., $model slot lm object, long predictor transformations. provides little bit safety cases data removed altered. Tweaks rbind.emm_list() allow subsetting. (Also documentation & example)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-152","dir":"Changelog","previous_headings":"","what":"emmeans 1.5.2","title":"emmeans 1.5.2","text":"CRAN release: 2020-10-24 Change plot.emmGrid(... comparisons = TRUE) determine arrow bounds unnecessary-arrow deletions separately group. See also Stack Overflow posting emmeans() contrasts specified ignores adjust passes contrast() instead. Associated documentation improved (hope) Bug-fix missing cases plot(..., comparisons = TRUE) (#228) Robustified plot.emmGrid() comparison arrows work correctly back-transformations. (Previously used regrid() case, causing different CIs PIs depending comparisons) (#230) Bug fixes support stan_polr models. Bug fix incorrect (relatively harmless) warning several models (#234) Lower object size via removing unnecessary environment deps (#232) Repairs .list() .emmGrid() fully support nesting submodels.","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-151","dir":"Changelog","previous_headings":"","what":"emmeans 1.5.1","title":"emmeans 1.5.1","text":"CRAN release: 2020-09-18 Additional checking potential errors (e.g. memory overload) connected submodel support. Also, much memory-efficient code therein (#218, #219) new option enable.submodel user can switch submodel support unwanted save memory. multinom support N.sim option Modification internal dispatching recover_data emm_basis external package’s methods always found given priority whether registered (#220) Patches gamlss support. Smoothers supported aspects reliable. See CV posting Improvement auto-detection transformations (#223) Added aes argument pwpp() control rendering (#178) Fix situation plot.emmGrid() ordering factor levels change depending CIs PIs (#225)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-150","dir":"Changelog","previous_headings":"","what":"emmeans 1.5.0","title":"emmeans 1.5.0","text":"CRAN release: 2020-08-18 Changed help page joint_tests() reflect cov.keep (ver. 1.4.2) emm_options() gains disable argument use setting aside existing options. Useful reproducible bug reporting. emmeans() contr argument two-sided formula, now suppress several particular ... arguments passed contrast() apply construction EMMs (#214) control ... arguments passed methods CLD() deprecated version 1.3.4. LAST VERSION continue available. Users use multcomp::cld() instead, emmGrid method continue exist. Bug fix therein (#217) Enhancements mgcv::gam support (#216) New ubds dataset testing messy situations Added minimal support lqm lqmm models (#213) Interim support user-supplied contrasts stanreg models (#212)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-148","dir":"Changelog","previous_headings":"","what":"emmeans 1.4.8","title":"emmeans 1.4.8","text":"CRAN release: 2020-06-26 Bug fix smoother support stanreg objects (#202) Fix emmip() consistent one curve several, whether points displayed (style option) Added \"scale\" option make.tran() Auto-detection standardized response transformation Fix scoping issue emtrends() (#201) Bug fix #197 created new issue #206. now fixed. Non-existent reference levels trt.vs.ctrl.emmc() now throws error (#208) Added default linfct (identity) emmobj Provisions flexible consistent labeling/naming results. includes added emm_options \"sep\" \"parens\", parens argument contrast(). sep controls factor levels combined ploted contrasted, parens sets whether, , labels parenthesized contrast(). constructing contrasts contrasts, example, labels like - B - C - D now (- B) - (C - D), default. reproduce old labeling, `emm_options(sep = “,”, parens = “^”)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-147","dir":"Changelog","previous_headings":"","what":"emmeans 1.4.7","title":"emmeans 1.4.7","text":"CRAN release: 2020-05-25 Repairs pwpp() plays nice nonestimable cases Added \"xplanations\" vignette additional documentation methods used. (comparison arrows, starters) Touch-ups plot(), especially regarding comparison arrows Bug fix stanreg models (#196) Fixed error emmeans(obj, \"1\", = \"something\") (#197) eff_size() now supports emm_list objects $contrasts component, using contrasts. helps specify pairwise ~ treatment. Labels contrast() factor combinations groups wacky (#199) emtrends() screwed multivariate models (#200). Added new argument calc summary(). example, calc = c(n = ~.wgt.) add column sample sizes summary.","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-146","dir":"Changelog","previous_headings":"","what":"emmeans 1.4.6","title":"emmeans 1.4.6","text":"CRAN release: 2020-04-19 Improvements coxph support models strata emmeans() specs class list now passes offset trend arguments (#179) Added plim argument pwpp() allow controlling scale documentation using params (#180) Robustified support gls objects data incomplete (#181) Fixed bug joint_tests() test(..., joint = TRUE) can occur nontrivial @dffun() slots (#184) Improved support Satterthwaite-based methods gls (#185) renamed boot-satterthwaite appx-satterthwaite (#176) repairs nesting-related code (#186) Fix transform argument ref_grid() regrid() (#188) Added pwpm() function displaying estimates, pairwise comparisons, P values matrix form","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-145","dir":"Changelog","previous_headings":"","what":"emmeans 1.4.5","title":"emmeans 1.4.5","text":"CRAN release: 2020-03-04 Change ..vars() addresses #170 Addition hidden argument scheffe.rank summary.emmGrid() manually specify desired dimensionality Scheffe adjustment (#171) Provided ... included options calls emmeans() contrast(). allows passing summary() argument easily, e.g., emmeans(..., type = \"response\", bias.adjust = TRUE, infer = c(TRUE, TRUE)) (, wrap summary()) Added plotit argument plot.emmGrid() works similarly emmip(). Removed startup message behavior change 1.4.2; ’s long enough. Fixed bug character predictors inat` (#175)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-144","dir":"Changelog","previous_headings":"","what":"emmeans 1.4.4","title":"emmeans 1.4.4","text":"CRAN release: 2020-01-28 Fixed bug emmeans() associated non-factors Date (#162) Added nesting.order option emmip() (#163) New style argument emmip() allows plotting numeric scale robust detection response transformations (#166) Ensure pwpp() tick marks P-value axis (#167) Bug fix regrid() error estimates exceed bounds Bug fix auto-detecting nesting (#169) make less “enthusiastic” Fixes formula operations needed formula.tools:::.character.formula messes (thanks Berwin Turloch, UWA, alerting ) Making dqrg() visible documentation (’s often useful) Added methods emm_list objects, e.g. rbind() .data.frame(), .list(), .emm_list()","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-14301","dir":"Changelog","previous_headings":"","what":"emmeans 1.4.3.01","title":"emmeans 1.4.3.01","text":"CRAN release: 2019-11-28 Fixed bug post-grid support affects, e.g., ggeffects package (#161)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-143","dir":"Changelog","previous_headings":"","what":"emmeans 1.4.3","title":"emmeans 1.4.3","text":"CRAN release: 2019-11-26 Added \"bcnPower\" option make.tran() (per car::bcnPower()) Scoping correction emmtrends() (#153) Allow passing ... hook functions (need exposed #154) Addition regrid() whereby can fake response transformation – just \"log\" (inspired #154) Informative message pbkrtest lmerTest found (affects merMod objects) (#157) Change pwpp() make extremely small P values distinguishable","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-142","dir":"Changelog","previous_headings":"","what":"emmeans 1.4.2","title":"emmeans 1.4.2","text":"CRAN release: 2019-10-24 First argument emtrends() now object, model, avoid potential mis-matching latter optional mode argument emtrends() now uses robust efficient code whereby single reference grid constructed containing needed values var. old version fail, e.g., cases reference grid involves post-processing. (#145) Added scale argument contrast() Added new \"identity\" contrast method New eff_size() function Cohen effect sizes Expanded capabilities interaction contrasts (#146) New cov.keep argument ref_grid() specifying covariates treated just like factors (#148). side effect system default indicator variables covariates treat like 2-level factors. change results obtained analyses using earlier versions. replicate old analyses, set emm_options(cov.keep = character(0)). Added merMod-related options convenience arguments (#150) Bug fixes: regrid ignored offsets Bayesian models; emtrends() supply options misc arguments emm_basis() (#143)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-141","dir":"Changelog","previous_headings":"","what":"emmeans 1.4.1","title":"emmeans 1.4.1","text":"CRAN release: 2019-09-12 Added non-estimability infrastructure Bayesian models, stanreg particular (#114) Added max.degree argument emtrends() making possible obtain higher-order trends (#133). Plus minor tuneups, e.g., smaller default increment difference quotients Made emmeans() forgiving ’byvariables; e.g.,emmeans(model, ~ dose | treat, = “route”)find bothbyvariables whereas previously“route”` ignored. Temporary fix glitch gls support Satterthwaite isn’t always right. Attempt make annotations clearer consistent regarding degrees--freedom methods. Provisions whereby externally provided emm_basis() recover_data() methods used preference internal ones - package developers can provide improvements ’ve cobbled together. Tried produce informative message recover_data() fails Fixed bug contrast() identifying true contrasts (#134) Fixed bug plot.summary_emm() regarding CIs intervals (#137) Improved support response transformations. Models formulas like like log(y + 1) ~ ... 2*sqrt(y + 0.5) ~ ... now auto-detected. [may cause discrepancies examples past usages, , response transformation previously incorrectly interpreted.] Added ratios argument contrast() decide handle log logit Added message/annotation contrasts summarized type = \"response\" way back-transform (opted ratios = FALSE)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-14","dir":"Changelog","previous_headings":"","what":"emmeans 1.4","title":"emmeans 1.4","text":"CRAN release: 2019-08-01 Added courtesy function .emm_register() make easier packages register emmeans support methods Clarified “confidence intervals” vignette discussion infer, explaining Bayesian models handled differently (#128) Added PIs option plot.emmGrid() emmip() (#131). Also, plot.emmGrid(), intervals argument changed CIs sake consistency less confusion; intervals still supported backaward compatibility. plot.emmGrid gains colors argument can customize colors used. Bug fix glht support (#132 contributed Balsz Banfai) regrid gains sim N.sim arguments whereby can generate fake posterior sample frequentist model.","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-1351","dir":"Changelog","previous_headings":"","what":"emmeans 1.3.5.1","title":"emmeans 1.3.5.1","text":"CRAN release: 2019-06-26 Bug fix gls objects non-matrix apVar member (#119) Repairs faulty links 1.3.5 vignettes","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-135","dir":"Changelog","previous_headings":"","what":"emmeans 1.3.5","title":"emmeans 1.3.5","text":"CRAN release: 2019-06-10 Addition sigma argument ref_grid() (defaults sigma(object) available) Addition interval argument predict.emmGrid() Addition likelihood argument .mcmc allow simulating posterior predictive distribution Crude provisions bias adjustment back-transforming. really prediction, made possible availability sigma object steps lower profile cld() CLD() Family size Tukey adjustment wrong using exclude (#107) Provided direct passing info recover_data emm_basis Attempts broaden MCMCglmm support","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-134","dir":"Changelog","previous_headings":"","what":"emmeans 1.3.4","title":"emmeans 1.3.4","text":"CRAN release: 2019-04-21 Un-naming lot arguments .call(paste, ...) .call(order, ...), prevent problems factor names like method argument names functions (#94) Fix logic error summary.emmGrid() whereby transformations class list ignored. Enhancement update.emmGrid(..., levels = levs) whereby can easily relabel reference grid ensure grid roles slots stay consistent. Added vignette example. Clarified ordering rules used emmeans(). now ensure original order reference grid preserved. Previously, grid re-ordered numeric character levels occurred order, per order() Curbing use “statistical significance” language. includes additional vignette material plans deprecate CLD() due misleading display pairwise-comparison tests. Bug fix betareg objects, wrong terms component sometimes used. Correction logic error affected multiplicity adjustments variables present (#98). Addition pwpp() function plot P values comparisons Improvement summary(..., adjust = \"scheffe\"). now actually compute use rank matrix linear functions obtain F numerator d.f., rather trying guess likely correct value. Removal vignette transitioning lsmeans – ’s long enough time now.","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-133","dir":"Changelog","previous_headings":"","what":"emmeans 1.3.3","title":"emmeans 1.3.3","text":"CRAN release: 2019-03-02 Fix unintended consequence #71 caused incorrect ordering contrast() results later used emmeans(). first noticed ordinal models prob mode (#83). Improved checking conformability parameters – models rank deficiency handled way lm()’s NA convention Added basic support sommer::mmer, MuMIn::averaging, mice::mira objects Fix nnet::multinom support 2 outcomes (#19) Added Satterthwaite d.f. gls objects famSize now correct exclude include used contrast function (see #68) Stronger warnings possible bias aovList objects, part due popularity afex::aov_ez() uses models. Updates FAQs vignette","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-132","dir":"Changelog","previous_headings":"","what":"emmeans 1.3.2","title":"emmeans 1.3.2","text":"CRAN release: 2019-01-22 decided enable “optimal digits” display default. summaries, try show enough—much—precision estimates confidence intervals. don’t like want revert old (exaggerated precision) behavior, emm_options(opt.digits = FALSE) Added include argument .emmc functions (#67) Now allow character values ref, exclude, include .emmc functions (#68) Better handling matrix predictors (#66) Fixed -zealous choice pass ... arguments emmeans() two-sided formulas present Fix clm support model rank-deficient Fix regrid(..., transform = \"log\") error existing non-estimable cases (issue #65) Improvements brmsfit support (#43) Added support mgcv::gam mgcv::gamm models ..vcov() now passes ... clients Removed glmmADMB support. package appears dormant Fixed ordering bug nested models (#71) Support manova object longer requires data keyword (#72) Added support multivariate response aovlist models (#73) Documentation clarification (#76) Fix CLD fatal error sort = TRUE (#77) Fix issue weights incomplete cases lme objects (#75) Nested fixed-effects yielded NonEsts two factors nested factor(s) (#79)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-131","dir":"Changelog","previous_headings":"","what":"emmeans 1.3.1","title":"emmeans 1.3.1","text":"CRAN release: 2018-12-13 \"mvt\" adjustment ignored grouping contrast() mis-labeled estimates levels varied among groups (prominently happened CLD(..., details = TRUE)) Changed aovlist support re-fits model non-sum--zero contrasts used print.summary_emm() now cleans numeric columns zapsmall() robust handling nesting ref_grid() update(), addition covnest argument whether include covariates auto-detecting nesting Revision vignettes Fixed bug hpd.summary() handoff summary() Fixed bug ref_grid() ignored mult.levs Fixes emmeans passes ... shouldn’t CLD() now works MCMC models (uses frequentist summary) Addition opt.digits option","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-130","dir":"Changelog","previous_headings":"","what":"emmeans 1.3.0","title":"emmeans 1.3.0","text":"CRAN release: 2018-10-26 Deprecated functions like ref.grid() put final rest, longer support packages provide recover.data lsm.basis methods Courtesy exports .recover_data() .emm_basis() provide access extension developers available methods Streamlining stored example inst/extdata Fix ..vars() cause errors response variable function call character constants. Relabeling differences ratios appropriate regrid() (results match summary() labeling type = \"response\"). plot.emmGrid(..., comparisons = TRUE, type = \"response\") produced incorrect comparison arrows; now fixed","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-124","dir":"Changelog","previous_headings":"","what":"emmeans 1.2.4","title":"emmeans 1.2.4","text":"CRAN release: 2018-09-22 Support model formulas df$y ~ df$treat + df[[\"cov\"]]. failed previously two obscure reasons, now works correctly. New simplify.names option types models emm_options() arguments now returns options force, including defaults. makes consistent options() Bug fix emtrends(); produced incorrect results models offsets. Separated help pages update.emmGrid() emm_options() New qdrg() function (quick dirty reference grid) help unsupported model objects","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-123","dir":"Changelog","previous_headings":"","what":"emmeans 1.2.3","title":"emmeans 1.2.3","text":"CRAN release: 2018-07-18 S3 methods involving packages multcomp coda now dynamically registered, merely exported functions. passes checks S3 methods required registered. cld() deprecated favor CLD(). headache. multcomp wrong place generic ; fancy dance export cld without multcomp installed. Added vignette caution regarding interdependent covariates Improved glmmADMB support recover contrasts correctly","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-122","dir":"Changelog","previous_headings":"","what":"emmeans 1.2.2","title":"emmeans 1.2.2","text":"CRAN release: 2018-06-26 Removed ggplot2, multcomp, coda Suggests – thus vastly reducing dependencies Added FAQ FAQs vignette Modified advice xtending.Rmd vignette export methods Fixes revpairwise.emmc cld regarding comparing 1 EMM cld.emm_list now returns results object[[ [1] ]], along warning message. Deprecated emmeans specs like cld ~ group, vestige lsmeans work correctly (already undocumented)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-121","dir":"Changelog","previous_headings":"","what":"emmeans 1.2.1","title":"emmeans 1.2.1","text":"CRAN release: 2018-05-21 Moved brms Suggests (dozens dozens fewer dependencies)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-12","dir":"Changelog","previous_headings":"","what":"emmeans 1.2","title":"emmeans 1.2","text":"CRAN release: 2018-05-08 Index vignette topics added New, improved (taste) vignette formats Fixed df bug regrid (#29) Fixed annotation bug nested models (#30) Better documentation lme models “models” vignette Additional fixes arguments passed .emmc functions (#22) Support added logical predictors (knew ? ) Replaced tex/pdf “Extending” vignette Rmd/html Overhauled faulty logic df methods emm_basis.merMod Added Henrik contributors list (long-standing oversight) Added exclude argument .emmc functions: allows user omit certain levels computing contrasts New hpd.summary() function Bayesian models show HPD intervals rather frequentist summary. Note: summary() automatically reroutes . Also plot() emmip() play along. Rudimentary support brms package Ad hoc Satterthwaite method nlme::lme models","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-113","dir":"Changelog","previous_headings":"","what":"emmeans 1.1.3","title":"emmeans 1.1.3","text":"CRAN release: 2018-04-01 Formatting corrections documentation Fixed bug survival models Surv() interpreted response transformation. Fixed bug (issue #19) multinom support Fixed bug (issue #22) optional arguments interaction contrasts Fixed bug (issue #23) weighting character predictors Clarifying message cld() applied emm_list (issue #24) Added offset argument ref_grid() (scalar offset ) emmeans() (vector offset allowed) – (issue #18) New optional argument [.summary_emm choose whether retain class coerce data.frame (relates issue #14) Added reverse option trt.vs.ctrl relatives (#27)","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-112","dir":"Changelog","previous_headings":"","what":"emmeans 1.1.2","title":"emmeans 1.1.2","text":"CRAN release: 2018-02-24 Changed way terms accessed lme objects make robust emmeans:::convert_scripts() renames output file simply Added [ method class summary_emm Added simple argument contrast - essentially complement Improved estimability handling joint_tests() Made ref_grid() accept ylevs list length > 1; also slight argument change: mult.name -> mult.names Various bug fixes, bullet-proofing Fixes make Markdown files render better","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-11","dir":"Changelog","previous_headings":"","what":"emmeans 1.1","title":"emmeans 1.1","text":"CRAN release: 2018-01-10 Fixed bug emmeans() wherein weights ignored specs list Coerce data argument, supplied data.frame (recover_data() doesn’t like tibbles…) Added .data.frame method emmGrid objects, making often possible pass directly functions data argument. Fixed bug contrast() ignored interaction contrasts Fixed bug .glht() choked df = Inf Fixed bug occurring model call data subset New joint_tests() function tests [interaction] contrasts","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-10","dir":"Changelog","previous_headings":"","what":"emmeans 1.0","title":"emmeans 1.0","text":"CRAN release: 2017-12-05 Added preliminary support gamlss objects (doesn’t support smoothing). Additional argument = c(\"mu\", \"sigma\", \"nu\", \"tau\") seems flaky model interest just ~ 1. Improved support models fancy variable names (containing spaces ) Fixed bug whereby emmeans() might pass data contrast() Added missing documentation summary.emmGrid() Repaired handling emm_options(summary = ...) work advertised. Changed many object names examples vignettes xxx.emmGrid xxx.emm (result overdoing renaming object class ) Changed emmGrid() function emm() intended alternative mcp() multcomp::glht() (result ditto). Fixed error exporting cld.emm_list() Fixed bug whereby CIs computed using first estimate’s degrees freedom. Now using Inf display d.f. asymptotic (z) tests. (NA still work Inf better choice consistency meaning.) Bug fix nesting-detection code model intercept","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-091","dir":"Changelog","previous_headings":"","what":"emmeans 0.9.1","title":"emmeans 0.9.1","text":"CRAN release: 2017-11-05 Documentation corrections (broken links, misspellings, mistakes) sophisticated check randomized data recover_data() now throws error finds recovered data reproducible Added support gam::gam objects Fixes vcov() calls comply recent R-devel changes","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"emmeans-09","dir":"Changelog","previous_headings":"","what":"emmeans 0.9","title":"emmeans 0.9","text":"CRAN release: 2017-10-20 initial major version replaces lsmeans package. Changes shown changes made last real release lsmeans (version 2.27-2). lsmeans versions greater transitional package retired. now emphasize terminology “estimated marginal means” rather “least-squares means” flagship functions now emmeans(), emtrends(), emmip(), etc. lsmeans(), lstrends(), etc. well pmmeans() etc. mapped corresponding emxxxx() functions. addition, trying avoid names get confused S3 methods. , ref.grid -> ref_grid, lsm.options -> emm_options, etc. Classes ref.grid lsmobj gone. replaced class emmGrid. .emmGrid() function provided convert old objects class emmGrid. decided revert back “kenward-roger” default degrees--freedom method lmerMod models. Also added options disable.lmerTest lmerTest.limit, similar pbkrtest. Documentation NAMESPACE now “ROxygenated” Additional neuralgia pigs datasets Dispatching emmmeans() methods now top-rather convoluted intermingling S3 methods Improved display back-transformed contrasts log logit transformation used: change -s labels /s emphasize thnese results ratios. message now displayed nesting auto-detected ref_grid. (Can disabled via emm_options()) Options added several messages users may want suppress, e.g., ones interactions nesting. Greatly overhauled help page models. now vignette, quick reference chart linked details, organized similarities instead packages. Support ‘mer’ objects (lme4.0 package) removed. large number smaller interlinked vignettes replaces one big one using package. Several vignettes linked help pages. Graphics methods plot() emmip() now ggplot2-based. Old lattice-based functionality still available , graphics.engine option choose default. Non-exported utilities convert_workspace() convert_scripts() help transition Moved Suggests pkgs Enhances needed building/testing","code":""},{"path":"https://rvlenth.github.io/emmeans/news/index.html","id":"note-emmeans-is-a-continuation-of-the-lsmeans-package-0-9","dir":"Changelog","previous_headings":"","what":"NOTE: emmeans is a continuation of the lsmeans package.","title":"emmeans 0.9","text":"New developments take place emmeans, lsmeans remain static eventually archived.","code":""}]
