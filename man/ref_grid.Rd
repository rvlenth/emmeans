% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ref-grid.R
\name{ref_grid}
\alias{ref_grid}
\title{Create a reference grid from a fitted model}
\usage{
ref_grid(object, at, cov.reduce = mean, mult.name, mult.levs,
  options = get_emm_option("ref_grid"), data, df, type,
  transform = c("none", "response", "mu", "unlink", "log"), nesting, ...)
}
\arguments{
\item{object}{An object produced by a supported model-fitting function, such
as \code{lm}. Many models are supported. 
See \href{../doc/models.html}{\code{vignette("models", "emmeans")}}.}

\item{at}{Optional named list of levels for the corresponding variables}

\item{cov.reduce}{A function, logical value, or formula; or a named list of
these. Each covariate \emph{not} specified in \code{at} is reduced
according to these specifications. See the section below on 
\dQuote{Using \code{cov.reduce}}.}

\item{mult.name}{Character value: the name to give to the pseudo-factor
whose levels delineate the elements of a multivariate response. If this is
provided, it overrides the default name, e.g., \code{"rep.meas"} for an
\code{\link[=lm]{mlm}} object or \code{"cut"} for a
\code{\link[MASS]{polr}} object.}

\item{mult.levs}{A named list of levels for the dimensions of a multivariate
response. If there is more than one element, the combinations of levels are
used, in \code{\link{expand.grid}} order. The (total) number of levels must
match the number of dimensions. If \code{mult.name} is specified, this
argument is ignored.}

\item{options}{If non-\code{NULL}, a named \code{list} of arguments to pass
to \code{\link{update.emmGrid}}, just after the object is constructed.}

\item{data}{A \code{data.frame} to use to obtain information about the
predictors (e.g. factor levels). If missing, then
\code{\link{recover_data}} is used to attempt to reconstruct the data.}

\item{df}{Numeric value. This is equivalent to specifying
\code{options(df = df)}. See \code{\link{update.emmGrid}}.}

\item{type}{Character value. If provided, this is saved as the
\code{"predict.type"} setting. See \code{\link{update.emmGrid}} and the section
below on prediction types and transformations.}

\item{transform}{Character value. If other than \code{"none"}, the reference 
grid is reconstructed via \code{\link{regrid}} with the given 
\code{transform} argument. See the section below on prediction types and
transformations.}

\item{nesting}{If the model has nested fixed effects, this may be specified
here via a character vector or named \code{list} specifying the nesting
structure. Specifying \code{nesting} overrides any nesting structure that
is automatically detected. See Details.}

\item{...}{Optional arguments passed to \code{\link{emm_basis}}, such as
\code{vcov.} (see Details below) or options for certain models (see
\href{../doc/models.html}{vignette("models", "emmeans")}).}
}
\value{
An object of the S4 class \code{"emmGrid"} (see 
  \code{\link{emmGrid-class}}). These objects encapsulate everything needed 
  to do calculations and inferences for estimated marginal means, and contain
  nothing that depends on the model-fitting procedure.
}
\description{
Using a fitted model object, determine a reference grid for which estimated
marginal means are defined. The resulting \code{ref_grid} object encapsulates
all the information needed to calculate EMMs and make inferences on them.
}
\details{
The reference grid consists of combinations of independent variables over
which predictions are made. Estimated marginal means are defined as these
predictions, or marginal averages thereof. The grid is determined by first
reconstructing the data used in fitting the model (see
\code{\link{recover_data}}), or by using the \code{data.frame} provided in
\code{data}. The default reference grid is determined by the observed
levels of any factors, the ordered unique values of character-valued
predictors, and the results of \code{cov.reduce} for numeric predictors.
These may be overridden using \code{at}. See also the section below on
recovering/overriding model information.
}
\section{Using \code{cov.reduce}}{

\code{cov.reduce} may be a function, logical value, formula, or a named list of
  these.
  
If a single function, it is applied to each covariate. 

If logical and \code{TRUE}, \code{mean} is used. If logical and \code{FALSE},
it is equivalent to specifying \samp{function(x) sort(unique(x))}, and these
values are considered part of the reference grid; thus, it is a handy
alternative to specifying these same values in \code{at}.

If a formula (which must be two-sided), then a model is fitted to that
formula using \code{\link{lm}}; then in the reference grid, its response
variable is set to the results of \code{\link{predict}} for that model, with
the reference grid as \code{newdata}. (This is done \emph{after} the
reference grid is determined.) A formula is appropriate here when you think
experimental conditions affect the covariate as well as the response.

If \code{cov.reduce} is a named list, then the above criteria are used to
determine what to do with covariates named in the list. (However, formula
elements do not need to be named, as those names are determined from the
formulas' left-hand sides.) Any unresolved covariates are reduced using
\code{"mean"}.

Any \code{cov.reduce} specification for a covariate also named in \code{at}
is ignored.
}

\section{Recovering or overriding model information}{

Ability to support a particular class of \code{object} depends on the
existence of \code{recover_data} and \code{emm_basis} methods -- see
\link{extending-emmeans} for details. The call \code{methods("recover_data")}
will help identify these. 

\bold{Data.} In certain models, (e.g., results of \code{\link[lme4]{glmer.nb}}), it is not
possible to identify the original dataset. In such cases, we can work around
this by setting \code{data} equal to the dataset used in fitting the model,
or a suitable subset. Only the complete cases in \code{data} are used, so it
may be necessary to exclude some unused variables. Using \code{data} can also
help save computing, especially when the dataset is large. In any case,
\code{data} must represent all factor levels used in fitting the model. It
\emph{cannot} be used as an alternative to \code{at}. (Note: If there is a
pattern of \code{NAs} that caused one or more factor levels to be excluded
when fitting the model, then \code{data} should also exclude those levels.)

\bold{Covariance matrix.} By default, the variance-covariance matrix for the 
fixed effects is obtained from \code{object}, usually via its
\code{\link{vcov}} method. However, the user may override this via a
\code{vcov.} argument, specifying a matrix or a function. If a matrix, it
must be square and of the same dimension and parameter order of the fixed
effects. If a function, must return a suitable matrix when it is called with
\code{object} as its only argument.

\bold{Nested factors.} Having a nesting structure affects marginal averaging 
in \code{emmeans} in that it is done separately for each level (or 
combination thereof) of the grouping factors. \code{ref_grid} tries to 
discern which factors are nested in other factors, but it is not always 
obvious, and if it misses some, the user must specify this structure via 
\code{nesting}; or later using \code{\link{update.emmGrid}}. The \code{nesting}
argument may be a character vector or a named \code{list}. If a \code{list},
each name should be the name of a single factor in the grid, and its entry a
character vector of the name(s) of its grouping factor(s). \code{nested} may
also be a character value of the form \code{"factor1 \%in\%
(factor2*factor3)"}. If there is more than one such specification, they may
be appended separated by commas, or as separate elements of a character
vector. For example, these specifications are equivalent: \code{nesting =
list(state = "country", city = c("state", "country")}, \code{nesting = "state
\%in\% country, city \%in\% (state*country)"}, and \code{nesting = c("state
\%in\% country)", "city \%in\% (state*country)")}.
}

\section{Prediction types and transformations}{

There is a subtle difference between specifying \samp{type = "response"} and 
\samp{transform = "response"}. While the summary statistics for the grid 
itself are the same, subsequent use in \code{\link{emmeans}} will yield 
different results if there is a response transformation or link function. 
With \samp{type = "response"}, EMMs are computed by averaging together
predictions on the \emph{linear-predictor} scale and then back-transforming
to the response scale; while with \samp{transform = "response"}, the
predictions are already on the response scale so that the EMMs will be
the arithmetic means of those response-scale predictions. To add further to
the possibilities, \emph{geometric} means of the response-scale predictions
are obtainable via \samp{transform = "log", type = "response"}.
}

\section{Side effect}{

The most recent result of \code{ref_grid}, whether called directly or
indirectly via \code{\link{emmeans}}, \code{\link{emtrends}}, or some other
function that calls one of these, is saved in the user's environment as
\code{.Last.ref_grid}. This facilitates checking what reference grid was
used, or reusing the same reference grid for further calculations. This
automatic saving is enabled by default, but may be disabled via
\samp{emm_options(save.ref_grid = FALSE)}, and re-enabled by specifying
\code{TRUE}.
}

\examples{
fiber.lm <- lm(strength ~ machine*diameter, data = fiber)
ref_grid(fiber.lm)
summary(.Last.ref_grid)

ref_grid(fiber.lm, at = list(diameter = c(15, 25)))

\dontrun{
# We could substitute the sandwich estimator vcovHAC(fiber.lm)
# as follows:
summary(ref_grid(fiber.lm, vcov. = sandwich::vcovHAC))
}

# If we thought that the machines affect the diameters
# (admittedly not plausible in this example), then we should use:
ref_grid(fiber.lm, cov.reduce = diameter ~ machine)

# Multivariate example
MOats.lm = lm(yield ~ Block + Variety, data = MOats)
ref_grid(MOats.lm, mult.name = "nitro")
# Silly illustration of how to use 'mult.levs' to make comb's of two factors
ref_grid(MOats.lm, mult.levs = list(T=LETTERS[1:2], U=letters[1:2]))

}
\seealso{
Reference grids are of class \code{\link{emmGrid-class}} and several
  methods exist for them -- for example \code{\link{summary.emmGrid}}. Reference
  grids are fundamental to \code{\link{emmeans}}. Supported models are
  detailed in \href{../doc/models.html}{\code{vignette("models", "emmeans")}}.
}
